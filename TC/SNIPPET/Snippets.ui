<Category>
	<Category Name="PREPROCESSING">
		<Category Name="RARE">
			<Snippet Name="strtovll">vector&lt;string&gt; split(string susu,char dudu = ' ') {
	susu += dudu;
	vector&lt;string&gt; raigeki;
	string water;
	FORIT(i,susu) {
		if ((*i) == dudu) {
			if (water != &quot;&quot;) raigeki.push_back(water);
			water = &quot;&quot;
			continue;
			}
		water += (*i);
		}

	return raigeki;
	}


vector&lt;ll&gt; vstrtovll (vector&lt;string&gt; abcdef) {
	vector&lt;ll&gt; retvalue;
	for (int i = 0;i &lt; abcdef.size();i++) {
		ll temp;
		sscanf(abcdef[i].c_str(),&quot;%lld&quot;,&amp;temp);
		retvalue.push_back(temp);
		}
	return retvalue;
	}

vector&lt;ll&gt; strtovll (string susu,char dudu = ' ') {
	return vstrtovint(split(susu,dudu));
	}</Snippet>			<Snippet Name="numtostr">string numtostr(int a) {
	char la[20];
	sprintf(la,&quot;%d&quot;,a);
	return la;
	}</Snippet>			<Snippet Name="str_to_int_with_limit">ll str_to_int_with_limit(string number, ll limit = 1000000002) {
	ll numberrep = 0;
	if ('.' == number[0]) return -1LL * str_to_int_with_limit(number.substr(1),limit);
	FORN(i,SZ(number)) {
		numberrep *= 10LL;
		numberrep += (ll)(number[i] - '0');
		MN(numberrep,limit);
	}
	return numberrep;
}
//str_to_int_with_limit(&quot;17&quot;,30);
//return number-&gt;long long, but if absolet value &gt; limit then return sign * limit.</Snippet>			<Snippet Name="get_pow_with_limit">ll get_pow_with_limit(ll number, ll power, ll limit = 1000000002) {
	if (power == 0LL) return 1LL;
	if (power % 2LL) return min(limit,get_pow_with_limit(number,power-1,limit) * number);
	ll recursed = get_pow_with_limit(number,power/2,limit);
	return min(limit,recursed*recursed);
}
//get_pow_with_limit(2,30,10000) //positive NUMBERS!
//return number^power, but if exceeds limit return limit</Snippet>		</Category>
		<Snippet Name="StrToVInt">vector&lt;string&gt; StringSplit(string input_str,char separator = ' ') {
	input_str += separator;
	vector&lt;string&gt; ret;
	string running_sum = &quot;&quot;;
	FORIT(i,input_str) {
		if ((*i) == separator) {
			if (running_sum != &quot;&quot;) ret.push_back(running_sum);
			running_sum = &quot;&quot;;
			continue;
			}
		running_sum += (*i);
		}

	return ret;
	}
//vector&lt;string&gt; = StringSplit(&quot; ivana  jahja&quot;, ' ') -&gt; {&quot;ivana&quot;,&quot;jahja&quot;}

vector&lt;int&gt; VStrToVInt (vector&lt;string&gt; input_vstr) {
	vector&lt;int&gt; ret;
	for (int i = 0;i &lt; input_vstr.size();i++) {
		int buffer;
		sscanf(input_vstr[i].c_str(),&quot;%d&quot;,&amp;buffer);
		ret.push_back(buffer);
		}
	return ret;
	}
//vector&lt;int&gt; = VStrToVint(&quot;1&quot;,&quot;7&quot;) -&gt; {1,7}

vector&lt;int&gt; StrToVInt (string input_str,char separator = ' ') {
	return VStrToVInt(StringSplit(input_str,separator));
	}
//vector&lt;int&gt; = StrToVInt(&quot; 1  7&quot;, ' ') -&gt; {1,7}</Snippet>		<Snippet Name="VStrToVVInt">vector&lt;string&gt; StringSplit(string input_str,char separator = ' ') {
	input_str += separator;
	vector&lt;string&gt; ret;
	string running_sum = &quot;&quot;;
	FORIT(i,input_str) {
		if ((*i) == separator) {
			if (running_sum != &quot;&quot;) ret.push_back(running_sum);
			running_sum = &quot;&quot;;
			continue;
			}
		running_sum += (*i);
		}

	return ret;
	}
//vector&lt;string&gt; = StringSplit(&quot; ivana  jahja&quot;, ' ') -&gt; {&quot;ivana&quot;,&quot;jahja&quot;}

vector&lt;int&gt; VStrToVInt (vector&lt;string&gt; input_vstr) {
	vector&lt;int&gt; ret;
	for (int i = 0;i &lt; input_vstr.size();i++) {
		int buffer;
		sscanf(input_vstr[i].c_str(),&quot;%d&quot;,&amp;buffer);
		ret.push_back(buffer);
		}
	return ret;
	}
//vector&lt;int&gt; = VStrToVint(&quot;1&quot;,&quot;7&quot;) -&gt; {1,7}

vector&lt;int&gt; StrToVInt (string input_str,char separator = ' ') {
	return VStrToVInt(StringSplit(input_str,separator));
	}
//vector&lt;int&gt; = StrToVInt(&quot; 1  7&quot;, ' ') -&gt; {1,7}

vector&lt; vector&lt;int&gt; &gt; VStrToVVInt(vector&lt;string&gt; input_vstr, char separator = ' ') {
	vector&lt; vector&lt;int&gt; &gt; ret;
	FORN(i,SZ(input_vstr)) ret.PB(StrToVInt(input_vstr[i], separator));
	return ret;
}
//vector&lt; vector&lt;int&gt; &gt; vector&lt; vint &gt; = VStrToVVInt(&quot;1 7&quot;,&quot; 8  9 &quot;) -&gt; {{1,7},{8,9}}</Snippet>	</Category>
	<Category Name="GEOMETRY">
		<Category Name="DATASTRUCTURE">
			<Snippet Name="DoublyConnectedEdgeList">class DoublyConnectedEdgeList {
 public:
  DoublyConnectedEdgeList(vector&lt; Point &gt; points) {
    int nodes = SZ(points);

    edges_.clear();
    out_edges_ = vector&lt; vector&lt; Edge* &gt; &gt;(nodes);
    points_ = points;
  }

  ~DoublyConnectedEdgeList() {
    FORN(i,SZ(edges_)) {
      delete edges_[i]-&gt;cross_pointer_;
      delete edges_[i];
    }
  }

  void addEdge(int a, int b) {
    Edge* forward = new Edge;
    Edge* backward = new Edge;
    forward-&gt;from_ = a;
    forward-&gt;to_ = b;
    backward-&gt;from_ = b;
    backward-&gt;to_ = a;
    forward-&gt;cross_pointer_ = backward;
    backward-&gt;cross_pointer_ = forward;

    repairOrigin(forward);
    repairOrigin(backward);

    edges_.PB(forward);
  }

  vector&lt; vector&lt;int&gt; &gt; getCavities() const {
    set&lt;Edge* &gt; visited;
    vector&lt; vector&lt;int&gt; &gt; ret;
    FORN(i, SZ(edges_)) {
      FORN(j,2) {
        Edge* edge = edges_[i];
        if (j) edge = edge-&gt;cross_pointer_;
        if (visited.count(edge)) continue;
        vector&lt;int&gt; nodes;
        while (!visited.count(edge)) {
          visited.insert(edge);
          nodes.PB(edge-&gt;to_);
          edge = edge-&gt;next_;
        }
        ret.PB(nodes);
      }
    }
    return ret;
  }

 private:
  struct Edge {
    int from_, to_;
    Edge* cross_pointer_;
    Edge* next_;
    Edge* prev_;
  };

  vector&lt; Edge* &gt; edges_;
  vector&lt; vector&lt; Edge* &gt; &gt; out_edges_;
  vector&lt; Point &gt; points_;

  void repairOrigin(Edge* edge) {
    if (SZ(out_edges_[edge-&gt;from_]) == 0) {
      out_edges_[edge-&gt;from_].PB(edge);
      edge-&gt;prev_ = edge-&gt;cross_pointer_;
      edge-&gt;cross_pointer_-&gt;next_ = edge;
    } else {
      double best_val = INF;
      Edge* best_edge = NULL;
      for (int i = 0; i &lt; SZ(out_edges_[edge-&gt;from_]); ++i) {
        Edge* try_edge = out_edges_[edge-&gt;from_][i]-&gt;cross_pointer_;
        double angle = ThreePointsAngle(points_[try_edge-&gt;from_],
                                        points_[try_edge-&gt;to_],
                                        points_[edge-&gt;to_]);
        if (abs(angle) &lt;= EPS) angle += 2.0 * atan2(0.0, -1.0);
        if (best_val &gt; angle) {
          best_val = angle;
          best_edge = try_edge;
        }
      }
      edge-&gt;prev_ = best_edge;
      edge-&gt;cross_pointer_-&gt;next_ = best_edge-&gt;next_;

      best_edge-&gt;next_-&gt;prev_ = edge-&gt;cross_pointer_;
      best_edge-&gt;next_ = edge;

      out_edges_[edge-&gt;from_].PB(edge);
    }
  }

};

//DoubleyConnectedEdgeList dcel(vector&lt;Point&gt; coordinates);
//dcel.addEdge(node_index1, node_index2); //bidirectional
//vector&lt; vector&lt;int&gt; &gt; getCavities(dcel); //obtain all enclosing space
// given as indexes in clockwise order except outer -&gt; ccw
</Snippet>			<Snippet Name="StaticKDTreeCount">// KD Tree that counts nodes in a square region
class StaticKDTreeCount {
 public:
  StaticKDTreeCount(vector&lt; pair&lt;ll, ll&gt; &gt; points) {
    // build the tree...
    points_ = new pair&lt;ll, ll&gt;[SZ(points)];
    for (int i = 0; i &lt; SZ(points); ++i) {
      points_[i] = points[i];
    }
    root_ = new StaticKDTreeNode_(0, SZ(points)-1, /* parity = */ 1, this);
  }

  ~StaticKDTreeCount() {
    delete[] points_;
    delete root_;
  }

  // count the number of nodes (row, col) such that (row1 &lt;= row &lt;= row2) and
  // (col1 &lt;= col &lt;= col2)
  // works in N^0.5 time.
  int Count(ll row1, ll row2, ll col1, ll col2) {
    return root_-&gt;Count(row1, row2, col1, col2);
  }

 private:
  static bool CompareRowFirst_(
      const pair&lt;ll, ll&gt;&amp; point1, const pair&lt;ll, ll&gt;&amp; point2) {
    return point1 &lt; point2;
  }
  static bool CompareColumnFirst_(
      const pair&lt;ll, ll&gt;&amp; point1, const pair&lt;ll, ll&gt;&amp; point2) {
    return (point1.B &lt; point2.B ||
           (point1.B == point2.B &amp;&amp; point1.A &lt; point2.A));
  }
 
  class StaticKDTreeNode_ {
   public:
    StaticKDTreeNode_(int low, int hi, int parity,
                     StaticKDTreeCount* tree) :
        low_(low), hi_(hi), tree_(tree) {
      more_ = 0;
      less_or_equal_ = 0;
      assert(low &lt;= hi);
      assert(parity &gt;= 0 &amp;&amp; parity &lt;= 2);
      assert(tree);
      // TODO(irvan): if you have infinite time, make this O(N)...?
      // Note that since complexity is bounded by N^(0.5) anyway I guess
      // this doesn't really matter....
      sort(tree-&gt;points_ + low, tree-&gt;points_ + hi + 1,
           parity?CompareRowFirst_:CompareColumnFirst_);
      top_row_ = tree-&gt;points_[low].A;
      bot_row_ = tree-&gt;points_[low].A;
      left_col_ = tree-&gt;points_[low].B;
      right_col_ = tree-&gt;points_[low].B;
      for (int i = low+1; i &lt;= hi; ++i) {
        top_row_ = min(top_row_, tree-&gt;points_[i].A);
        bot_row_ = max(bot_row_, tree-&gt;points_[i].A);
        left_col_ = min(left_col_, tree-&gt;points_[i].B);
        right_col_ = max(right_col_, tree-&gt;points_[i].B);
      }
      is_leaf_ = 0;
      if (tree-&gt;points_[low] == tree-&gt;points_[hi]) {
        // all same
        // done!
        is_leaf_ = 1;
        return;
      }
      if ((parity &amp;&amp; tree-&gt;points_[low].A == tree-&gt;points_[hi].A) ||
          (!parity &amp;&amp; tree-&gt;points_[low].B == tree-&gt;points_[hi].B)) {
        // all same parity wise
        // switch parity
        parity ^= 1;
      }
      // find the &quot;separator&quot;
      ll best = parity?tree-&gt;points_[low].A:tree-&gt;points_[hi].B;
      int jml = 0;
      for (int i = low; i &lt;= hi; ++i) {
        ll x = parity?tree-&gt;points_[i].A:tree-&gt;points_[i].B;
        if (i == hi ||
            x != (parity?tree-&gt;points_[i+1].A:tree-&gt;points_[i+1].B)) {
          // ok change of heart
          int cur_jml = i - low + 1;
          if (jml &lt; min(cur_jml, hi - low + 1 - cur_jml)) {
            jml = min(cur_jml, hi - low + 1 - cur_jml);
            best = x;
          }
        }
      }
      assert(jml &gt; 0);
      // Recurse if necessary
      for (int i = low; i &lt; hi; ++i) {
        ll now = parity?tree-&gt;points_[i].A:tree-&gt;points_[i].B;
        ll nex = parity?tree-&gt;points_[i+1].A:tree-&gt;points_[i+1].B;
        if (now == best &amp;&amp; nex != best) {
          // later
          more_ = new StaticKDTreeNode_(i+1, hi, parity^1, tree);
          less_or_equal_ = new StaticKDTreeNode_(low, i, parity^1, tree);
          break;
        }
      }
      assert(more_);
      assert(less_or_equal_);
    }

    ~StaticKDTreeNode_() {
      if (less_or_equal_) delete less_or_equal_;
      if (more_) delete more_;
    }

    ll Count(const ll&amp; row_lb, const ll&amp; row_ub, const ll&amp; col_lb, const ll&amp; col_ub) {
      if (top_row_ &gt;= row_lb &amp;&amp; bot_row_ &lt;= row_ub &amp;&amp; left_col_ &gt;= col_lb &amp;&amp;
          right_col_ &lt;= col_ub) {
        // included
        return hi_ - low_ + 1LL;
      }
      if (top_row_ &gt; row_ub || bot_row_ &lt; row_lb || left_col_ &gt; col_ub ||
          right_col_ &lt; col_lb) {
        // excluded
        return 0LL;
      }
      // recurse
      assert(!is_leaf_);
      assert(more_);
      assert(less_or_equal_);
      return more_-&gt;Count(row_lb, row_ub, col_lb, col_ub) +
             less_or_equal_-&gt;Count(row_lb, row_ub, col_lb, col_ub);
    }
   private:
    int low_;
    int hi_;
    int is_leaf_;
    ll top_row_;
    ll bot_row_;
    ll left_col_;
    ll right_col_;
    // owned
    StaticKDTreeNode_* less_or_equal_;
    // owned
    StaticKDTreeNode_* more_;
    // not owned
    StaticKDTreeCount* tree_;
  };
  // owned
  pair&lt;ll, ll&gt; *points_;
  // owned
  StaticKDTreeNode_* root_;
};

// StaticKDTreeCount tree(p);   p is a vector&lt; pair&lt;ll, ll&gt; &gt;
// tree.Count(x1, x2, y1, y2)</Snippet>		</Category>
		<Category Name="POINT">
			<Category Name="POINTS">
				<Snippet Name="RemoveCollinearPoints">vector&lt; Point &gt; RemoveCollinearPoints(const vector&lt; Point &gt;&amp; points) {
	// removes three collinear points by deleting the middle one
	vector&lt;int&gt; deleted(SZ(points), 0);
	FORN(i, SZ(points)) FORN(j, SZ(points)) FORN(k, SZ(points)) {
		if (deleted[i] || deleted[j] || deleted[k]) continue;
		if (i == j || j == k || k == i) continue;
		if (SegmentContainsPoint(MP(points[i], points[j]), points[k])) deleted[k] = 1;
	}

	vector&lt; Point &gt; ret;
	FORN(i, SZ(points)) if (!deleted[i]) ret.PB(points[i]);
	return ret;
}</Snippet>				<Snippet Name="ConvexHull">// straight returns false O(1)
bool IsStrictLeftTurn(Point p1, Point p2, Point p3) {
  return ( p2.A - p1.A ) * ( p3.B - p1.B ) - ( p2.B - p1.B ) * ( p3.A - p1.A ) &gt; EPS;
}

// O(N log N - gift wrapping)
vector&lt; Point &gt; ConvexHull (vector&lt; Point &gt; points) {
	if (SZ(points) &lt;= 2) return points;
	sort(ALL(points));
	points.erase(unique(ALL(points)),points.end());
	vector&lt; pair&lt;double, Point &gt; &gt; p; // sorted clockwise with respect to center
	vector&lt; Point &gt; ans;
	int tn = SZ(points);
	double midx = 0.0,midy = 0.0;
	FORN(i,tn) midx += points[i].first;
	FORN(i,tn) midy += points[i].second;
	midx /= (double)tn;
	midy /= (double)tn;
	FORN(i,tn) p.PB(MP(atan2((double)points[i].second - midy,
                           (double)points[i].first - midx),
                  points[i]));
	sort(ALL(p));
	reverse(ALL(p));
	FORN(i,tn) {
		ans.PB(p[i].second);
		while (SZ(ans) &gt; 2) {
			int bz = SZ(ans);
			if (IsStrictLeftTurn(ans[bz - 1], ans[bz - 2], ans[bz - 3])) break;
			swap(ans[bz - 1],ans[bz - 2]);
			ans.pop_back();
    }
  }

	int pd = 0;
	while (SZ(ans) - pd &gt; 2) {
		//check the last as the MID part
		if (!IsStrictLeftTurn(ans[pd], ans[SZ(ans) - 1] ,ans[SZ(ans) - 2])) {
			ans.pop_back();
			continue;
    }
		if (!IsStrictLeftTurn(ans[pd + 1], ans[pd], ans[SZ(ans) - 1])) {
			pd++;
			continue;
    }
		break;
  }

	vector &lt; Point &gt; trans;
	REP(i,pd,SZ(ans)) trans.PB(ans[i]);
	return trans;
}
// vector&lt;Point&gt; res = ConvexHull(vector&lt;Point&gt; points);</Snippet>			</Category>
			<Category Name="ANGLE">
				<Snippet Name="IsStrictLeftTurn">bool IsStrictLeftTurn(Point p1, Point p2, Point p3) {
  return ( p2.A - p1.A ) * ( p3.B - p1.B ) - ( p2.B - p1.B ) * ( p3.A - p1.A ) &gt; EPS;
}</Snippet>				<Snippet Name="IsCollinear">bool IsCollinear(Point p1, Point p2, Point p3) {
  return abs(p1.A * p2.B + p2.A * p3.B + p3.A * p1.B -
			 p1.B * p2.A - p2.B * p3.A - p3.B * p1.A) &lt; EPS;
}</Snippet>				<Snippet Name="ThreePointsAngle">double ThreePointsAngle(Point p1, Point p2, Point p3) {
  return VectorAngle(PointToVector(p2, p1), PointToVector(p2, p3));
}
// how many degrees must p2-&gt;p1 rotated ccw to overlap p2-&gt;p3?</Snippet>				<Snippet Name="PolarAngle">//O(1)
double PolarAngle( Point the_point )
{
    if( fabs( the_point.A ) &lt;= EPS &amp;&amp; fabs( the_point.B ) &lt;= EPS ) return -1.0;
    if( fabs( the_point.A ) &lt;= EPS ) return ( the_point.B &gt; EPS ? 1.0 : 3.0 ) * acos( 0 );
    double theta = atan( 1.0 * the_point.B / the_point.A );
    if( the_point.A &gt; EPS ) return( the_point.B &gt;= -EPS ? theta : ( 4 * acos( 0 ) + theta ) );
    return( 2 * acos( 0 ) + theta );
}
//PolarAngle(point) =&gt; angle [0, 2*pi] counterclockwise from positive x axis
//, -1 if &lt;0,0&gt;</Snippet>			</Category>
			<Category Name="EQUALITY">
				<Snippet Name="PointEquals">bool PointEquals(Point p1, Point p2) {
  return abs(p1.A - p2.A) &lt;= EPS &amp;&amp; abs(p1.B - p2.B) &lt;= EPS;
}</Snippet>				<Snippet Name="PointLess">bool PointLess(Point p1, Point p2) {
  return p2.B + EPS &lt; p1.B || (fabs(p1.B - p2.B) &lt;= EPS &amp;&amp; p1.A + EPS &lt; p2.A);
}</Snippet>			</Category>
			<Category Name="OTHER">
				<Snippet Name="PointToVector">Vector PointToVector(Point p1, Point p2) {
  return MP(p2.A - p1.A, p2.B - p1.B);
}</Snippet>				<Snippet Name="TriangleArea">double TriangleArea(Point p1, Point p2, Point p3) {
	return 0.5 * abs(p1.A * p2.B + p2.A * p3.B + p3.A * p1.B -
					 p1.B * p2.A - p2.B * p3.A - p3.B * p1.A);
}</Snippet>			</Category>
			<Category Name="CMP">
				<Snippet Name="PointsAtan2Cmp">struct PointsAtan2Cmp {
	Point center_;
	PointsAtan2Cmp(Point center) : center_(center) {}
	bool operator() (const Point&amp; p1, const Point&amp; p2) {
		return atan2(p1.B - center_.B, p1.A - center_.A) &lt; atan2(p2.B - center_.B, p2.A - center_.A);
	}
};
// sort points according to the atan2 with a center point given in constructor
// lists them in quadrans : 3, 4, 1, 2</Snippet>			</Category>
		</Category>
		<Category Name="SEGMENT">
			<Snippet Name="IsIntersecting">//O(1)
        bool IsIntersecting(Segment segment1, Segment segment2, int* parallel,
    Point* intersection_point) {

  // renamings
	double xx1 = segment1.A.A; double yy1 = segment1.A.B;
  double xx2 = segment1.B.A; double yy2 = segment1.B.B;
	double xx3 = segment2.A.A; double yy3 = segment2.A.B;
	double xx4 = segment2.B.A; double yy4 = segment2.B.B;

	*parallel = 0;
	if (fabs((yy4 - yy3) * (xx2 - xx1) - (xx4 - xx3) * (yy2 - yy1)) &lt;= EPS) {
		*parallel = 1;
    if (PointEquals(segment1.A, segment2.A) || PointEquals(segment1.A, segment2.B)) {
      *intersection_point = segment1.A;
      return true;
    } else if (PointEquals(segment1.B, segment2.A) || PointEquals(segment1.B, segment2.B)) {
      *intersection_point = segment1.B;
      return true;
    }
		return false;
		}
	double ua = ((xx4 - xx3)*(yy1 - yy3) - (yy4-yy3)*(xx1-xx3)) /
      ((yy4-yy3) * (xx2-xx1) - (xx4-xx3) * (yy2 - yy1));
	double&amp; xi = (*intersection_point).A;
	double&amp; yi = (*intersection_point).B;
	xi = xx1 + ua * (xx2 - xx1);
	yi = yy1 + ua * (yy2 - yy1);
	return ( (xi + EPS &gt;= fmin(xx1,xx2)) &amp;&amp; (xi - EPS &lt;= fmax(xx1,xx2)) &amp;&amp;
	         (yi + EPS &gt;= fmin(yy1,yy2)) &amp;&amp; (yi - EPS &lt;= fmax(yy1,yy2)) &amp;&amp;
			 (xi + EPS &gt;= fmin(xx3,xx4)) &amp;&amp; (xi - EPS &lt;= fmax(xx3,xx4)) &amp;&amp;
	         (yi + EPS &gt;= fmin(yy3,yy4)) &amp;&amp; (yi - EPS &lt;= fmax(yy3,yy4))
			 );
	}
//IsIntersecting(seg1,seg, &amp;isparallel, &amp;intersectionpoint) //intersect ato touch kaga?</Snippet>			<Snippet Name="SegmentContainsPoint">bool SegmentContainsPoint(Segment segment, Point point) {
  if (!IsCollinear(segment.A, segment.B, point)) {
    return false;
  }
  return (point.A + EPS &gt;= min(segment.A.A, segment.B.A) &amp;&amp;
          point.A - EPS &lt;= max(segment.A.A, segment.B.A) &amp;&amp;
          point.B + EPS &gt;= min(segment.A.B, segment.B.B) &amp;&amp;
          point.B - EPS &lt;= max(segment.A.B, segment.B.B));
}
//if point lies or on the boundary of segment</Snippet>			<Snippet Name="SegmentLength">double SegmentLength( Segment seg )
{
    return sqrt( ( seg.A.A - seg.B.A ) * ( seg.A.A - seg.B.A ) + ( seg.A.B - seg.B.B ) * ( seg.A.B - seg.B.B ) );
}</Snippet>		</Category>
		<Category Name="POLYGON">
			<Snippet Name="IsClockwise">bool IsClockwise(Polygon polygon) {
  double tentative_area = 0.0;
  int np = SZ(polygon);
  FORN(i, np) {
    tentative_area += polygon[i].A * polygon[(i+1)%np].B;
    tentative_area -= polygon[i].B * polygon[(i+1)%np].A;
  }
  return tentative_area &lt;= 0.0;
}</Snippet>			<Snippet Name="PolygonArea">//O(N)
double PolygonArea(Polygon polygon) {
	double ret = 0;
	FORN(i,SZ(polygon)) {
		ret += (db)(polygon[i].A * polygon[(i+1)%SZ(polygon)].B);
		ret -= (db)(polygon[i].B * polygon[(i+1)%SZ(polygon)].A);
	}
	return abs(ret) / 2.0;
}
//vector&lt; polygon &gt; polygon;
//return PolygonArea(polygon);</Snippet>			<Snippet Name="PointInsidePolygon">//O(1)
double PolarAngle(Point the_point) {
    if( fabs( the_point.A ) &lt;= EPS &amp;&amp; fabs( the_point.B ) &lt;= EPS ) return -1.0;
    if( fabs( the_point.A ) &lt;= EPS ) return ( the_point.B &gt; EPS ? 1.0 : 3.0 ) * acos( 0 );
    double theta = atan( 1.0 * the_point.B / the_point.A );
    if( the_point.A &gt; EPS ) return( the_point.B &gt;= -EPS ? theta : ( 4 * acos( 0 ) + theta ) );
    return( 2 * acos( 0 ) + theta );
}
// PolarAngle(point) =&gt; angle [0, 2*pi], -1 if &lt;0,0&gt;

// O(N) based on igor's geom
int PointInsidePolygon( Polygon polygon, Point the_point ) {
    int n = polygon.size();
    double ang = 0.0;
    for(int i = n - 1, j = 0; j &lt; n; i = j++) {
        Point v( polygon[i].A - the_point.A, polygon[i].B - the_point.B );
        Point w( polygon[j].A - the_point.A, polygon[j].B - the_point.B );
        double va = PolarAngle( v );
        double wa = PolarAngle( w );
        double xx = wa - va;
        if( va &lt; -0.5 || wa &lt; -0.5 ||
            fabs( fabs( xx ) - 2 * acos( 0 ) ) &lt; EPS ) {
          // point at border
            return true;
        }
        if( xx &lt; -2 * acos( 0 ) ) ang += xx + 4 * acos( 0 );
        else if( xx &gt; 2 * acos( 0 ) ) ang += xx - 4 * acos( 0 );
        else ang += xx;
    }
    return( ang * ang &gt; 1.0 );
}
// PointInsidePolygon(poly, point) == true iff point inside or at the border of poly</Snippet>			<Snippet Name="PolygonIntersection">//O(1)
        bool IsIntersecting(Segment segment1, Segment segment2, int* parallel,
    Point* intersection_point) {

  // renamings
	double xx1 = segment1.A.A; double yy1 = segment1.A.B;
  double xx2 = segment1.B.A; double yy2 = segment1.B.B;
	double xx3 = segment2.A.A; double yy3 = segment2.A.B;
	double xx4 = segment2.B.A; double yy4 = segment2.B.B;

	*parallel = 0;
	if (fabs((yy4 - yy3) * (xx2 - xx1) - (xx4 - xx3) * (yy2 - yy1)) &lt;= EPS) {
		*parallel = 1;
    if (PointEquals(segment1.A, segment2.A) || PointEquals(segment1.A, segment2.B)) {
      *intersection_point = segment1.A;
      return true;
    } else if (PointEquals(segment1.B, segment2.A) || PointEquals(segment1.B, segment2.B)) {
      *intersection_point = segment1.B;
      return true;
    }
		return false;
		}
	double ua = ((xx4 - xx3)*(yy1 - yy3) - (yy4-yy3)*(xx1-xx3)) /
      ((yy4-yy3) * (xx2-xx1) - (xx4-xx3) * (yy2 - yy1));
	double&amp; xi = (*intersection_point).A;
	double&amp; yi = (*intersection_point).B;
	xi = xx1 + ua * (xx2 - xx1);
	yi = yy1 + ua * (yy2 - yy1);
	return ( (xi + EPS &gt;= fmin(xx1,xx2)) &amp;&amp; (xi - EPS &lt;= fmax(xx1,xx2)) &amp;&amp;
	         (yi + EPS &gt;= fmin(yy1,yy2)) &amp;&amp; (yi - EPS &lt;= fmax(yy1,yy2)) &amp;&amp;
			 (xi + EPS &gt;= fmin(xx3,xx4)) &amp;&amp; (xi - EPS &lt;= fmax(xx3,xx4)) &amp;&amp;
	         (yi + EPS &gt;= fmin(yy3,yy4)) &amp;&amp; (yi - EPS &lt;= fmax(yy3,yy4))
			 );
	}
//IsIntersecting(seg1,seg, &amp;isparallel, &amp;intersectionpoint) //intersect ato touch kaga?

// straight returns false O(1)
bool IsStrictLeftTurn(Point p1, Point p2, Point p3) {
  return ( p2.A - p1.A ) * ( p3.B - p1.B ) - ( p2.B - p1.B ) * ( p3.A - p1.A ) &gt; EPS;
}

// O(N log N - gift wrapping)
vector&lt; Point &gt; ConvexHull (vector&lt; Point &gt; points) {
	if (SZ(points) &lt;= 2) return points;
	sort(ALL(points));
	points.erase(unique(ALL(points)),points.end());
	vector&lt; pair&lt;double, Point &gt; &gt; p; // sorted clockwise with respect to center
	vector&lt; Point &gt; ans;
	int tn = SZ(points);
	double midx = 0.0,midy = 0.0;
	FORN(i,tn) midx += points[i].first;
	FORN(i,tn) midy += points[i].second;
	midx /= (double)tn;
	midy /= (double)tn;
	FORN(i,tn) p.PB(MP(atan2((double)points[i].second - midy,
                           (double)points[i].first - midx),
                  points[i]));
	sort(ALL(p));
	reverse(ALL(p));
	FORN(i,tn) {
		ans.PB(p[i].second);
		while (SZ(ans) &gt; 2) {
			int bz = SZ(ans);
			if (IsStrictLeftTurn(ans[bz - 1], ans[bz - 2], ans[bz - 3])) break;
			swap(ans[bz - 1],ans[bz - 2]);
			ans.pop_back();
    }
  }

	int pd = 0;
	while (SZ(ans) - pd &gt; 2) {
		//check the last as the MID part
		if (!IsStrictLeftTurn(ans[pd], ans[SZ(ans) - 1] ,ans[SZ(ans) - 2])) {
			ans.pop_back();
			continue;
    }
		if (!IsStrictLeftTurn(ans[pd + 1], ans[pd], ans[SZ(ans) - 1])) {
			pd++;
			continue;
    }
		break;
  }

	vector &lt; Point &gt; trans;
	REP(i,pd,SZ(ans)) trans.PB(ans[i]);
	return trans;
}
// vector&lt;Point&gt; res = ConvexHull(vector&lt;Point&gt; points);

//O(1)
double PolarAngle(Point the_point) {
    if( fabs( the_point.A ) &lt;= EPS &amp;&amp; fabs( the_point.B ) &lt;= EPS ) return -1.0;
    if( fabs( the_point.A ) &lt;= EPS ) return ( the_point.B &gt; EPS ? 1.0 : 3.0 ) * acos( 0 );
    double theta = atan( 1.0 * the_point.B / the_point.A );
    if( the_point.A &gt; EPS ) return( the_point.B &gt;= -EPS ? theta : ( 4 * acos( 0 ) + theta ) );
    return( 2 * acos( 0 ) + theta );
}
// PolarAngle(point) =&gt; angle [0, 2*pi], -1 if &lt;0,0&gt;

// O(N) based on igor's geom
int PointInsidePolygon( Polygon polygon, Point the_point ) {
    int n = polygon.size();
    double ang = 0.0;
    for(int i = n - 1, j = 0; j &lt; n; i = j++) {
        Point v( polygon[i].A - the_point.A, polygon[i].B - the_point.B );
        Point w( polygon[j].A - the_point.A, polygon[j].B - the_point.B );
        double va = PolarAngle( v );
        double wa = PolarAngle( w );
        double xx = wa - va;
        if( va &lt; -0.5 || wa &lt; -0.5 ||
            fabs( fabs( xx ) - 2 * acos( 0 ) ) &lt; EPS ) {
          // point at border
            return true;
        }
        if( xx &lt; -2 * acos( 0 ) ) ang += xx + 4 * acos( 0 );
        else if( xx &gt; 2 * acos( 0 ) ) ang += xx - 4 * acos( 0 );
        else ang += xx;
    }
    return( ang * ang &gt; 1.0 );
}
// PointInsidePolygon(poly, point) == true iff point inside or at the border of poly

// O(N^3) very slow
Polygon PolygonIntersection(Polygon p1, Polygon p2) {
  vector&lt; Point &gt; ps;
  FORN(i, SZ(p1)) if (PointInsidePolygon(p2, p1[i])) ps.PB(p1[i]);
  FORN(i, SZ(p2)) if (PointInsidePolygon(p1, p2[i])) {
    bool ok = true;
    FORN(j, SZ(ps)) if (PointEquals(ps[j], p2[i])) {
      ok = false;
      break;
    }
    if (ok) ps.PB(p2[i]);
  }

  FORN(i, SZ(p1)) FORN(j, SZ(p2)) {
    Point inter;
    int dummy;
    Segment seg1 = MP(p1[i], p1[(i+1)%SZ(p1)]);
    Segment seg2 = MP(p2[j], p2[(j+1)%SZ(p2)]);
    if (IsIntersecting(seg1, seg2, &amp;dummy, &amp;inter) &amp;&amp; !dummy) {
      bool ok = true;
      FORN(k, SZ(ps)) if (PointEquals(ps[k], inter)) {
        ok = false;
        break;
      }
      if (ok) ps.PB(inter);
    }
  }

  if (SZ(ps) &lt;= 2) {
    // polygons don't intersect
    return Polygon();
  }

  vector&lt; Point &gt; ch = ConvexHull(ps);

  return ch;
}
// SLOW!
// Polygon res = PolygonIntersection(polygon1, polygon2)
// if don't intersect returns an empty Polygon()</Snippet>		</Category>
		<Category Name="LINE">
			<Snippet Name="DistanceToLine">double SegmentLength( Segment seg )
{
    return sqrt( ( seg.A.A - seg.B.A ) * ( seg.A.A - seg.B.A ) + ( seg.A.B - seg.B.B ) * ( seg.A.B - seg.B.B ) );
}

double DistanceToLine(
    Segment line,
    Point point_x,
    Point* out_point = NULL)
{
    pair&lt;double, double&gt; point_a, point_b;
    point_a = line.A;
    point_b = line.B;
    double cpx, cpy;
    //Formula: cp = a + (p-a).(b-a) / |b-a| * (b-a)

    double proj = ( ( point_x.A - point_a.A ) * ( point_b.A - point_a.A ) + ( point_x.B - point_a.B ) * ( point_b.B - point_a.B ) ) /
                  ( ( point_b.A - point_a.A ) * ( point_b.A - point_a.A ) + ( point_b.B - point_a.B ) * ( point_b.B - point_a.B ) );
    cpx = point_a.A + proj * ( point_b.A - point_a.A );
    cpy = point_a.B + proj * ( point_b.B - point_a.B );
    if (out_point != NULL) {
      *out_point = MP(cpx, cpy);
    }
    return SegmentLength( MP(point_x, MP(cpx, cpy)) );
}</Snippet>		</Category>
		<Category Name="VECTOR">
			<Snippet Name="VectorEquals">typedef pair&lt;double, double&gt; Vector;

bool VectorEquals(Vector first_vec, Vector second_vec) {
  return fabs(first_vec.A - second_vec.A) &lt;= EPS &amp;&amp;
         fabs(first_vec.B - second_vec.B) &lt;= EPS;
}</Snippet>			<Snippet Name="VectorAngle">double VectorAngle(Vector rotated_vec, Vector target_vec) {
  double rotangle = PositiveAtan2(rotated_vec.B, rotated_vec.A);
  double tarangle = PositiveAtan2(target_vec.B, target_vec.A);
  if (tarangle &gt;= rotangle) return tarangle - rotangle;
  return tarangle + 2.0 * atan2(0.0, -1.0) - rotangle;
}
// how many degrees must rotated_vec rotated ccw to overlap target_vec?</Snippet>			<Snippet Name="PointToVector">Vector PointToVector(Point p1, Point p2) {
  return MP(p2.A - p1.A, p2.B - p1.B);
}</Snippet>		</Category>
		<Snippet Name="typedefs">typedef pair&lt;double, double&gt; Point;
typedef pair&lt;Point, Point&gt; Segment;
typedef vector&lt;Point&gt; Polygon;
typedef pair&lt;double, double&gt; Vector;

bool PointEquals(Point p1, Point p2) {
  return abs(p1.A - p2.A) &lt;= EPS &amp;&amp; abs(p1.B - p2.B) &lt;= EPS;
}</Snippet>		<Category Name="LEGACY">
			<Category Name="RECTANGLE">
				<Snippet Name="isoverlapping">#define ppiipii pair&lt; pair&lt;int,int&gt;, pair&lt;int,int&gt; &gt;
//rectangle : pair((x1,y1)(x2,y2))
int isoverlapping(ppiipii a,ppiipii b) {
	FORN(i,2) {
		if (a.A.A + a.B.A &gt; b.A.A &amp;&amp; a.A.B + a.B.B &gt; b.A.B &amp;&amp; a.A.A &lt; b.A.A + b.B.A &amp;&amp; a.A.B &lt; b.A.B + b.B.B) return 1;
		swap(a,b);
		}
	return 0;
	}</Snippet>				<Snippet Name="splitrec">#define ppiipii pair&lt; pair&lt;int,int&gt;, pair&lt;int,int&gt; &gt;

int isoverlapping(ppiipii a,ppiipii b) {
	FORN(i,2) {
		if (a.A.A + a.B.A &gt; b.A.A &amp;&amp; a.A.B + a.B.B &gt; b.A.B &amp;&amp; a.A.A &lt; b.A.A + b.B.A &amp;&amp; a.A.B &lt; b.A.B + b.B.B) return 1;
		swap(a,b);
		}
	return 0;
	}

//input : pair&lt;r,c&gt; pair&lt;r,c&gt; koor kiri atas, tinggi row, pnj col, a dikurang b
vector&lt; ppiipii &gt; splitrec(ppiipii a,ppiipii b)  {
	vector&lt; ppiipii &gt; ret;
	if (!isoverlapping(a,b)) {
		ret.PB(a);
		return ret;
		}
	if (a.A.A &lt; b.A.A) {
		ret.PB(MP(MP(a.A.A,max(a.A.B,b.A.B)),MP(b.A.A - a.A.A,min(a.A.B+a.B.B,b.A.B + b.B.B) - max(a.A.B,b.A.B))));
		}
	if (a.A.A + a.B.A &gt; b.A.A + b.B.A) {
		ret.PB(MP(MP(b.A.A+b.B.A,max(a.A.B,b.A.B)),MP(a.A.A+a.B.A-b.A.A-b.B.A,min(a.A.B+a.B.B,b.A.B+b.B.B)-max(a.A.B,b.A.B))));
		}
	if (a.A.B &lt; b.A.B) {
		ret.PB(MP(a.A,MP(a.B.A,b.A.B-a.A.B)));
		}
	if (a.A.B+a.B.B&gt;b.A.B+b.B.B) {
		ret.PB(MP(MP(a.A.A,b.A.B+b.B.B),MP(a.B.A,a.A.B+a.B.B-b.A.B-b.B.B)));
		}
	return ret;
	}</Snippet>			</Category>
			<Category Name="CONVEX HULL">
				<Snippet Name="convexhull[DOUBLE]">//LURUS BUKAN LEFT TURN!
bool leftturn(double x1, double y1, double x2, double y2, double x3, double y3 ) {
    return ( x2 - x1 ) * ( y3 - y1 ) - ( y2 - y1 ) * ( x3 - x1 ) &gt; EPS;
	}

//input : points (x,y). must contain at least 3!
//kalau masukannya mau double, itu int tinggal diganti double

vector&lt; pair&lt;double,double&gt; &gt; convexhull (vector&lt; pair&lt;double,double&gt; &gt; abc) {

	sort(ALL(abc));
	abc.erase(unique(ALL(abc)),abc.end());
	vector&lt; pair&lt;double, pair&lt;double,double&gt; &gt; &gt; p;
	vector&lt; pair&lt;double,double&gt; &gt; ans;
	int tn = SZ(abc);
	double midx = 0.0,midy = 0.0;
	FORN(i,tn) midx += abc[i].first;
	FORN(i,tn) midy += abc[i].second;
	midx /= (double)tn;
	midy /= (double)tn;
	FORN(i,tn) p.PB(MP(atan2((double)abc[i].second - midy,(double)abc[i].first - midx),MP(abc[i].first,abc[i].second)));
	sort(ALL(p));
	reverse(ALL(p));
	FORN(i,tn) {
		ans.PB(MP(p[i].second.first,p[i].second.second));
		while (SZ(ans) &gt; 2) {
			int bz = SZ(ans);
			if (leftturn(ans[bz - 1].first,ans[bz - 1].second,ans[bz - 2].first,ans[bz - 2].second,ans[bz - 3].first,ans[bz - 3].second)) break;
			swap(ans[bz - 1],ans[bz - 2]);
			ans.pop_back();
			}
		}

	int pd = 0;
	while (SZ(ans) - pd &gt; 2) {
		//check the last as the MID part
		if (!leftturn(ans[pd].first,ans[pd].second,ans[SZ(ans) - 1].first,ans[SZ(ans) - 1].second,ans[SZ(ans) - 2].first,ans[SZ(ans) - 2].second)) {
			ans.pop_back();
			continue;
			}
		if (!leftturn(ans[pd + 1].first,ans[pd + 1].second,ans[pd].first,ans[pd].second,ans[SZ(ans) - 1].first,ans[SZ(ans) - 1].second)) {
			pd++;
			continue;
			}
		break;
		}

	vector &lt;pair &lt;double,double&gt; &gt; trans;
	REP(i,pd,SZ(ans)) trans.PB(ans[i]);
	return trans;
	}</Snippet>				<Snippet Name="convexhull[INT]">bool leftturn(long long x1, long long y1, long long x2, long long y2, long long x3, long long y3 ) {
    return ( x2 - x1 ) * ( y3 - y1 ) - ( y2 - y1 ) * ( x3 - x1 ) &gt; 0LL;
	}

vector&lt; pair&lt;int,int&gt; &gt; convexhull (vector&lt; pair&lt;int,int&gt; &gt; abc) {

	sort(ALL(abc));
	abc.erase(unique(ALL(abc)),abc.end());
	vector&lt; pair&lt;double, pair&lt;int,int&gt; &gt; &gt; p;
	vector&lt; pair&lt;int,int&gt; &gt; ans;
	int tn = SZ(abc);

	double midx = 0.0,midy = 0.0;
	FORN(i,tn) midx += abc[i].first;
	FORN(i,tn) midy += abc[i].second;
	midx /= (double)tn;
	midy /= (double)tn;
	FORN(i,tn) p.PB(MP(atan2((double)abc[i].second - midy,(double)abc[i].first - midx),MP(abc[i].first,abc[i].second)));
	sort(ALL(p));
	reverse(ALL(p));

	FORN(i,tn) {
		ans.PB(MP(p[i].second.first,p[i].second.second));
		while (SZ(ans) &gt; 2) {
			int bz = SZ(ans);
			if (leftturn(ans[bz - 1].first,ans[bz - 1].second,ans[bz - 2].first,ans[bz - 2].second,ans[bz - 3].first,ans[bz - 3].second)) break;
			swap(ans[bz - 1],ans[bz - 2]);
			ans.pop_back();
			}
		}
	int pd = 0;
	while (SZ(ans) - pd &gt; 2) {
		if (!leftturn(ans[pd].first,ans[pd].second,ans[SZ(ans) - 1].first,ans[SZ(ans) - 1].second,ans[SZ(ans) - 2].first,ans[SZ(ans) - 2].second)) {
			ans.pop_back();
			continue;
			}
		if (!leftturn(ans[pd + 1].first,ans[pd + 1].second,ans[pd].first,ans[pd].second,ans[SZ(ans) - 1].first,ans[SZ(ans) - 1].second)) {
			pd++;
			continue;
			}
		break;
		}
	vector&lt; pair&lt;int,int&gt; &gt; trans;
	REP(i,pd,SZ(ans)) trans.PB(ans[i]);
	return trans;
	}</Snippet>			</Category>
			<Category Name="LINE">
				<Snippet Name="SegmentLength">template&lt;class Cl1, class Cl2, class Cl3, class Cl4&gt;
double SegmentLength(pair&lt;Cl1, Cl2&gt; p1, pair&lt;Cl3, Cl4&gt; p2) {
	return hypot(p1.A - p2.A, p1.B - p2.B);
}</Snippet>				<Snippet Name="findx">//given a segment, and a Y, return the compatible X.

int invalid;

double findx(double xx1,double yy1, double xx2, double yy2, double yy3) {
	invalid = 0;
	if (fabs(yy2 - yy1) &lt;= EPS) {
		invalid = 1;
		return 0.0;
		}
	return (xx2 - xx1) / (yy2 - yy1) * yy3 + xx1 - (xx2 - xx1) / (yy2 - yy1) * yy1;
	}</Snippet>				<Snippet Name="GetMultiplier">template &lt;class Cl1, class Cl2, class Cl3, class Cl4, class Cl5, class Cl6&gt;
double GetMultiplier(pair&lt;Cl1,Cl2&gt; point, pair&lt;Cl3,Cl4&gt; p1, pair&lt;Cl5,Cl6&gt; p2) {
	if (abs(p1.A - p2.A) &gt; abs(p1.B - p2.B)) {
		//bagi x
		return (point.A - p1.A) / (p2.A - p1.A);
	}
	return (point.B - p1.B) / (p2.B - p1.B);
}</Snippet>				<Snippet Name="MergeSegments">template &lt;class cType&gt; int IsSegmentOverlappingOrTouching( pair&lt; pair&lt;cType, cType&gt;, pair&lt;cType, cType&gt; &gt; segment1, pair&lt; pair&lt;cType, cType&gt;, pair&lt;cType, cType&gt; &gt; segment2) {
	db xx1 = segment1.A.A;
	db xx2 = segment1.B.A;
	db yy1 = segment1.A.B;
	db yy2 = segment1.B.B;
	db xx3 = segment2.A.A;
	db xx4 = segment2.B.A;
	db yy3 = segment2.A.B;
	db yy4 = segment2.B.B;
	if (xx1 &gt; xx2) {
		swap(xx1,xx2);
		swap(yy1,yy2);
		}
	if (xx3 &gt; xx4) {
		swap(xx3,xx4);
		swap(yy3,yy4);
		}
	if (fabs(((db)yy2 - (db)yy1) * ((db)xx4 - (db)xx3) - ((db)yy4 - (db)yy3) * ((db)xx2 - (db)xx1)) &gt; EPS) return 0;
	if (fabs((db)xx2 - (db)xx1) &lt; EPS) {
		if (fabs((db)xx2 - (db)xx3) &gt; EPS) return 0;
		if (yy2 &lt; yy1) swap(yy2, yy1);
		if (yy4 &lt; yy3) swap(yy4, yy3);
		if ((db)yy2 + EPS &gt;= (db)yy3 &amp;&amp; (db)yy1 &lt;= (db)yy4 + EPS) return 1;
		return 0;
		}

	if (xx2 &lt; xx3 || xx1 &gt; xx4) return 0;

	if (fabs((db)(yy3 * (xx2 - xx1)) - (db)((yy2 - yy1) * xx3 + yy1 * (xx2 - xx1) - (yy2 - yy1) * xx1)) &gt; EPS) return 0;

	return 1;
	}

//IsSegmentOverlappingOrTouching(segment1, segment2); //truefalse

template &lt;class cType&gt; pair&lt; pair&lt; cType, cType&gt;, pair&lt;cType, cType&gt; &gt; MergeSegment (pair&lt; pair&lt; cType, cType&gt;, pair&lt;cType, cType&gt; &gt; segment1, pair&lt; pair&lt; cType, cType&gt;, pair&lt;cType, cType&gt; &gt; segment2) {
	vector&lt; pair&lt;cType,cType&gt; &gt; avp;
	avp.PB(segment1.A);
	avp.PB(segment1.B);
	avp.PB(segment2.A);
	avp.PB(segment2.B);
	return MP(*min_element(ALL(avp)), *max_element(ALL(avp)));
	}

//MergeSegment(segment1, segment2);
//return the merging of two segments THAT OVERLAPS

template &lt;class cType&gt; vector&lt; pair&lt; pair&lt;cType,cType&gt;, pair&lt;cType,cType&gt; &gt; &gt; MergeSegments (vector &lt;pair&lt; pair&lt;cType,cType&gt;, pair&lt;cType,cType&gt; &gt; &gt; abc) {
	int jml = 1;
	while (jml) {
	jml = 0;
	FORN(i,SZ(abc)) REP(j,i + 1,SZ(abc)) {
		if (i == j) continue;
		if (!IsSegmentOverlappingOrTouching(abc[i], abc[j])) continue;
		abc[i] = MergeSegment(abc[i], abc[j]);
		abc.erase(abc.begin() + j);
		jml++;
		}
	}
	return abc;
	}

//vector&lt;seg&gt; = MergeSegments(vector&lt;seg&gt;) //return segment yg sudah dioverlap</Snippet>				<Snippet Name="FindY">template &lt;class cType1, class cType2&gt;
double FindY(pair&lt;cType1,cType1&gt; point1, pair&lt;cType2,cType2&gt; point2, double x_point, int* is_invalid = NULL) {
	double xx1,yy1,xx2,yy2,xx3;
	xx1 = point1.A;
	yy1 = point1.B;
	xx2 = point2.A;
	yy2 = point2.B;
	xx3 = x_point;
	if (is_invalid != NULL) *is_invalid = 0;
	if (fabs(xx2 - xx1) &lt;= EPS) {
		if (is_invalid != NULL) *is_invalid = 1;
		return 0.0;
		}
	return (yy2 - yy1) / (xx2 - xx1) * xx3 + yy1 - (yy2 - yy1) / (xx2 - xx1) * xx1;
	}
//double y = FindY(&lt;1,2&gt;, &lt;3,6&gt;, 2) == 4</Snippet>			</Category>
			<Category Name="DOUBLE">
				<Snippet Name="Equal">bool Equal(double d1, double d2) {
	return (abs(d1-d2) &lt;= EPS);
}</Snippet>			</Category>
			<Category Name="POINTPOLYGONLINE">
				<Snippet Name="DistanceToLineSegment">double SegmentLength( pair&lt;db,db&gt; point_a, pair&lt;db,db&gt; point_b )
{
    return sqrt( ( point_a.A - point_b.A ) * ( point_a.A - point_b.A ) + ( point_a.B - point_b.B ) * ( point_a.B - point_b.B ) );
}

double DistanceToLine(
    pair&lt; pair&lt;double, double&gt;, pair&lt;double, double&gt; &gt; line,
    pair&lt;double, double&gt; point_x,
    pair&lt;double, double&gt;* out_point = NULL)
{
    pair&lt;double, double&gt; point_a, point_b;
    point_a = line.A;
    point_b = line.B;
    double cpx, cpy;
    //Formula: cp = a + (p-a).(b-a) / |b-a| * (b-a)

    double proj = ( ( point_x.A - point_a.A ) * ( point_b.A - point_a.A ) + ( point_x.B - point_a.B ) * ( point_b.B - point_a.B ) ) /
                  ( ( point_b.A - point_a.A ) * ( point_b.A - point_a.A ) + ( point_b.B - point_a.B ) * ( point_b.B - point_a.B ) );
    cpx = point_a.A + proj * ( point_b.A - point_a.A );
    cpy = point_a.B + proj * ( point_b.B - point_a.B );
    if (out_point != NULL) {
      *out_point = MP(cpx, cpy);
    }
    return SegmentLength( point_x, MP(cpx, cpy) );
}

//distance = DistanceToLine(line, point, &amp;intersection);

double DistanceToLineSegment(
    pair&lt; pair&lt;double, double&gt;, pair&lt;double, double&gt; &gt; line,
    pair&lt;double, double&gt; point_x,
    pair&lt;double, double&gt;* out_point = NULL)
{
    double ax, bx, ay, by, px, py, cpx, cpy;

    ax = line.A.A;
    ay = line.A.B;
    bx = line.B.A;
    by = line.B.B;
    px = point_x.A;
    py = point_x.B;

    if( ( bx - ax ) * ( px - ax ) + ( by - ay ) * ( py - ay ) &lt; EPS )
    {
        cpx = ax;
        cpy = ay;
        if (out_point != NULL) *out_point = MP(cpx, cpy);
        return SegmentLength( MP(ax,ay), MP(px,py) );
    }

    if( ( ax - bx ) * ( px - bx ) + ( ay - by ) * ( py - by ) &lt; EPS )
    {
        cpx = bx;
        cpy = by;
        if (out_point != NULL) *out_point = MP(cpx, cpy);
        return SegmentLength( MP(bx,by), MP(px,py) );
    }

    return DistanceToLine( MP(MP(ax,ay), MP(bx,by)), MP(px,py), out_point );
}

//distance = DistanceToLineSegment(linesegment, point, &amp;intersection);</Snippet>				<Snippet Name="PointTranslate">pair&lt;db, db&gt; PointTranslate(pair&lt;db, db&gt; point_x, pair&lt;db, db&gt; delta) {
  return MP(point_x.A + delta.A, point_x.B + delta.B);
}
//&lt;5,6&gt; = PointTranslate(&lt;8,3&gt;, &lt;-3,3&gt;);</Snippet>				<Snippet Name="PointRotate">double PolarAngle( pair&lt;double, double&gt; the_point )
{
    if( fabs( the_point.A ) &lt;= EPS &amp;&amp; fabs( the_point.B ) &lt;= EPS ) return -1.0;
    if( fabs( the_point.A ) &lt;= EPS ) return ( the_point.B &gt; EPS ? 1.0 : 3.0 ) * acos( 0 );
    double theta = atan( 1.0 * the_point.B / the_point.A );
    if( the_point.A &gt; EPS ) return( the_point.B &gt;= -EPS ? theta : ( 4 * acos( 0 ) + theta ) );
    return( 2 * acos( 0 ) + theta );
}
//PolarAngle(point) =&gt; angle [0, 2*pi], -1 if &lt;0,0&gt;

double SegmentLength( pair&lt;db,db&gt; point_a, pair&lt;db,db&gt; point_b )
{
    return sqrt( ( point_a.A - point_b.A ) * ( point_a.A - point_b.A ) + ( point_a.B - point_b.B ) * ( point_a.B - point_b.B ) );
}

pair&lt; db, db &gt; PointRotate(pair&lt;db, db&gt; center_of_rotation, double angle, pair&lt;db, db&gt; point_x) {
  if (center_of_rotation != MP(0.0,0.0)) {
    pair&lt;db,db&gt; masked = PointRotate(MP(0.0,0.0), angle, MP(point_x.A-center_of_rotation.A, point_x.B-center_of_rotation.B));
    return MP(masked.A + center_of_rotation.A, masked.B + center_of_rotation.B);
  }
  angle += PolarAngle(point_x);
  double panjang = SegmentLength(MP(0.0, 0.0), point_x);
  pair&lt;db,db&gt; ret;
  ret.A = cos(angle) * panjang;
  ret.B = sin(angle) * panjang;
  return ret;
}
//pair&lt;db,db&gt; hasil = PointRotate(&lt;1,1&gt;, pi, &lt;2,0&gt;)</Snippet>				<Snippet Name="PointReflect">double PolarAngle( pair&lt;double, double&gt; the_point )
{
    if( fabs( the_point.A ) &lt;= EPS &amp;&amp; fabs( the_point.B ) &lt;= EPS ) return -1.0;
    if( fabs( the_point.A ) &lt;= EPS ) return ( the_point.B &gt; EPS ? 1.0 : 3.0 ) * acos( 0 );
    double theta = atan( 1.0 * the_point.B / the_point.A );
    if( the_point.A &gt; EPS ) return( the_point.B &gt;= -EPS ? theta : ( 4 * acos( 0 ) + theta ) );
    return( 2 * acos( 0 ) + theta );
}
//PolarAngle(point) =&gt; angle [0, 2*pi], -1 if &lt;0,0&gt;

double SegmentLength( pair&lt;db,db&gt; point_a, pair&lt;db,db&gt; point_b )
{
    return sqrt( ( point_a.A - point_b.A ) * ( point_a.A - point_b.A ) + ( point_a.B - point_b.B ) * ( point_a.B - point_b.B ) );
}

pair&lt; db, db &gt; PointRotate(pair&lt;db, db&gt; center_of_rotation, double angle, pair&lt;db, db&gt; point_x) {
  if (center_of_rotation != MP(0.0,0.0)) {
    pair&lt;db,db&gt; masked = PointRotate(MP(0.0,0.0), angle, MP(point_x.A-center_of_rotation.A, point_x.B-center_of_rotation.B));
    return MP(masked.A + center_of_rotation.A, masked.B + center_of_rotation.B);
  }
  angle += PolarAngle(point_x);
  double panjang = SegmentLength(MP(0.0, 0.0), point_x);
  pair&lt;db,db&gt; ret;
  ret.A = cos(angle) * panjang;
  ret.B = sin(angle) * panjang;
  return ret;
}
//pair&lt;db,db&gt; hasil = PointRotate(&lt;1,1&gt;, pi, &lt;2,0&gt;)

const db kPi = 4.0 * atan(1.0);

pair&lt; db, db &gt; PointReflect(pair&lt; pair&lt;db,db&gt;, pair&lt;db,db&gt; &gt; line, pair&lt;db,db&gt; point_x) {
  //find its reflection point then rotate 180 degrees through this point
  pair&lt;db,db&gt; reflection_point;
  DistanceToLine(line, point_x, &amp;reflection_point);
  return PointRotate(reflection_point, kPi, point_x);
}
//pair&lt;db,db&gt; hasilrefleksi = PointReflect(line, pointnya);</Snippet>				<Snippet Name="PolygonMap">double PolarAngle( pair&lt;double, double&gt; the_point )
{
    if( fabs( the_point.A ) &lt;= EPS &amp;&amp; fabs( the_point.B ) &lt;= EPS ) return -1.0;
    if( fabs( the_point.A ) &lt;= EPS ) return ( the_point.B &gt; EPS ? 1.0 : 3.0 ) * acos( 0 );
    double theta = atan( 1.0 * the_point.B / the_point.A );
    if( the_point.A &gt; EPS ) return( the_point.B &gt;= -EPS ? theta : ( 4 * acos( 0 ) + theta ) );
    return( 2 * acos( 0 ) + theta );
}
//PolarAngle(point) =&gt; angle [0, 2*pi], -1 if &lt;0,0&gt;

double SegmentLength( pair&lt;db,db&gt; point_a, pair&lt;db,db&gt; point_b )
{
    return sqrt( ( point_a.A - point_b.A ) * ( point_a.A - point_b.A ) + ( point_a.B - point_b.B ) * ( point_a.B - point_b.B ) );
}

pair&lt; db, db &gt; PointRotate(pair&lt;db, db&gt; center_of_rotation, double angle, pair&lt;db, db&gt; point_x) {
  if (center_of_rotation != MP(0.0,0.0)) {
    pair&lt;db,db&gt; masked = PointRotate(MP(0.0,0.0), angle, MP(point_x.A-center_of_rotation.A, point_x.B-center_of_rotation.B));
    return MP(masked.A + center_of_rotation.A, masked.B + center_of_rotation.B);
  }
  angle += PolarAngle(point_x);
  double panjang = SegmentLength(MP(0.0, 0.0), point_x);
  pair&lt;db,db&gt; ret;
  ret.A = cos(angle) * panjang;
  ret.B = sin(angle) * panjang;
  return ret;
}
//pair&lt;db,db&gt; hasil = PointRotate(&lt;1,1&gt;, pi, &lt;2,0&gt;)

const db kPi = 4.0 * atan(1.0);

pair&lt; db, db &gt; PointReflect(pair&lt; pair&lt;db,db&gt;, pair&lt;db,db&gt; &gt; line, pair&lt;db,db&gt; point_x) {
  //find its reflection point then rotate 180 degrees through this point
  pair&lt;db,db&gt; reflection_point;
  DistanceToLine(line, point_x, &amp;reflection_point);
  return PointRotate(reflection_point, kPi, point_x);
}
//pair&lt;db,db&gt; hasilrefleksi = PointReflect(line, pointnya);

pair&lt; db, db &gt; VectorDistance(pair&lt; db, db &gt; point1, pair&lt; db, db &gt; point2) {
  return MP(point2.A - point1.A, point2.B - point1.B);
}

vector&lt; pair&lt;db,db&gt; &gt; PolygonMap(vector&lt; pair&lt;db,db&gt; &gt; polygon, pair&lt;db,db&gt; new_point_0, pair&lt;db,db&gt; new_point_1) {
  //translate to new_point_0
  REP(i,1,SZ(polygon)) {
    polygon[i] = PointTranslate(polygon[i], VectorDistance(polygon[0], new_point_0));
  }
  polygon[0] = new_point_0;
  //find the angle of the old and new_point_1
  double old_angle = PolarAngle(VectorDistance(polygon[0], polygon[1]));
  double new_angle = PolarAngle(VectorDistance(new_point_0, new_point_1));
  double rotation_angle = new_angle - old_angle;
  REP(i,1,SZ(polygon)) polygon[i] = PointRotate(polygon[0], rotation_angle, polygon[i]);
  return polygon;
}
//vector&lt; pair&lt;db,db&gt; &gt; PolygonMap(polygon, new_point_1, new_point_2); //diputer clockwise</Snippet>			</Category>
			<Snippet Name="3pointcircle">//prerequisite
bool circlelineIntersect( double x[], double y[], double r[] )
{
    double n[2]; n[0] = y[3] - y[2]; n[1] = x[2] - x[3];
    double denom = n[0] * ( x[1] - x[0] ) + n[1] * ( y[1] - y[0] );
    if( fabs( denom ) &lt; 0.0000001 ) return false;
    double num = n[0] * ( x[0] - x[2] ) + n[1] * ( y[0] - y[2] );
    double t = -num / denom;
    r[0] = x[0] + t * ( x[1] - x[0] );
    r[1] = y[0] + t * ( y[1] - y[0] );
    return true;
}

double cenx,ceny; //posisi titik tengah

//return radius
template &lt;class a_type&gt; double circle3( a_type x1,a_type y1,a_type x2,a_type y2,a_type x3,a_type y3)
{
    double lix[4], liy[4];
	double r[2];
    lix[0] = 0.5 * ( (db)x1 + (db)x2 ); liy[0] = 0.5 * ( (db)y1 + (db)y2 );
    lix[1] = lix[0] + (db)y2 - (db)y1;  liy[1] = liy[0] + (db)x1 - (db)x2;
    lix[2] = 0.5 * ( (db)x2 + (db)x3 ); liy[2] = 0.5 * ( (db)y2 + (db)y3 );
    lix[3] = lix[2] + (db)y3 - (db)y2;  liy[3] = liy[2] + (db)x2 - (db)x3;
    if( !circlelineIntersect( lix, liy, r ) ) return -1.0;
	cenx = r[0];
	ceny = r[1];
    return sqrt(
        ( r[0] - (db)x1 ) * ( r[0] - (db)x1 ) +
        ( r[1] - (db)y1 ) * ( r[1] - (db)y1 ) );
}</Snippet>			<Snippet Name="circleintersect">int circleintersect(int xa,int ya,int ra,int xb,int yb,int rb) {
	double jarak = sqrt((xb-xa)*(xb-xa)+(yb-ya)*(yb-ya));
	if ((double)ra &gt; jarak + (db)rb) return 1;
	return 0;
	}</Snippet>			<Snippet Name="PositiveAtan2">double PositiveAtan2(double dy, double dx) {
  double ret = atan2(dy, dx);
  if (ret &gt;= 0.0) return ret;
  return 2.0 * atan2(0.0, -1.0) + ret;
}
// return angle between positive x with &lt;dx, dy&gt; [0, 2pi)
</Snippet>		</Category>
	</Category>
	<Category Name="GRAPH">
		<Category Name="POLYMORPHICGRAPH">
			<Category Name="LEGACY">
				<Category Name="UNWEIGHTEDGRAPH">
					<Category Name="UNDIRECTEDUNWEIGHTEDGRAPH">
						<Category Name="RARE">
							<Snippet Name="GraphColoring">class GraphColoring : public UndirectedUnweightedGraph {
  public:
  	explicit GraphColoring(int number_of_nodes) : UndirectedUnweightedGraph(number_of_nodes) {}

  	//return minimum number of colors to color the graph, -1 if impossible.
  	int MinimumColor() {
  		int nnodes = SZ(adj_);
  		vint dp(1 &lt;&lt; nnodes, INF);
  		vint used(1 &lt;&lt; nnodes, -1);
  		queue&lt;int&gt; q;
  		vint isindependent(1 &lt;&lt; nnodes,1);
  		FORN(mask,1 &lt;&lt; nnodes) {
  			FORN(j,nnodes) if (mask &amp; (1 &lt;&lt; j)) FORIT(k, adj_[j]) if (mask &amp; (1 &lt;&lt; (*k))) if (*k != j) isindependent[mask] = 0;
  		}
  		q.push(0);
  		dp[0] = 0;
  		while (!q.empty()) {
  			int mask = q.front();
  			q.pop();
  			if (mask == (1 &lt;&lt; nnodes)-1) {
  				colors = vint(nnodes);
  				int curnode = mask;
  				int cnt = dp[mask]-1;
  				while (used[curnode] != -1) {
  					FORN(j, nnodes) if (j &amp; used[curnode]) colors[j] = cnt;
  					--cnt;
  					curnode -= used[curnode];
  				}
  				return dp[mask];
  			}
  			for(int i = (1 &lt;&lt; nnodes)-1; i &gt;=  1; --i) if (isindependent[i] &amp;&amp; i + mask == (i | mask) &amp;&amp; dp[i | mask] &gt; dp[mask] + 1) {
  				dp[i | mask] = dp[mask] + 1;
  				used[i | mask] = i;
  				q.push(i | mask);
  			}
  		}
  		DEBUG(&quot;error&quot;);
  		return -100;
  	}
  	vint GetColors() {
  		MinimumColor();
  		return colors;
  	}
  private:
  	vint colors;
};

//O(4^N)
//GraphColoring gc(jumlah_node);
//ts.AddEdge(0,5);
//int jumlah_color_minimum = gc.MinimumColor();
//vint warna_lexicographically_minimum = gc.GetColors();</Snippet>						</Category>
						<Snippet Name="UndirectedUnweightedGraphSet">class Graph {
  public:
  	virtual ~Graph() {};
  	virtual void Simplify() {};
};

class UnweightedGraph : public Graph {
  public:
  	UnweightedGraph(int number_of_nodes) : adj_(number_of_nodes) {}
  	UnweightedGraph&amp; operator=(const UnweightedGraph&amp; input_graph) {
  		adj_ = vector&lt;vint&gt;(SZ(input_graph.adj_));
  		FORN(i, SZ(input_graph.adj_)) FORIT(j, input_graph.adj_[i]) this-&gt;AddEdge(i, *j);
  		return *this;
  	}
  	virtual void AddEdge(int from, int to) {
  		adj_[from].PB(to);
  	}
  	virtual int Size() {
  		return adj_.size();
  	}
  	vector&lt; vint &gt; adj_;
};

class UndirectedUnweightedGraph : public UnweightedGraph {
  public:
  	UndirectedUnweightedGraph(int number_of_nodes) : UnweightedGraph(number_of_nodes) {}
  	virtual void AddEdge(int from, int to) {
  		UnweightedGraph::AddEdge(from, to);
  		UnweightedGraph::AddEdge(to, from);
  	}
};</Snippet>					</Category>
					<Category Name="FUNCTIONS">
						<Snippet Name="SimplifyUnweightedGraph">void SimplifyUnweightedGraph(UnweightedGraph* input_graph) {
	input_graph-&gt;Simplify();
	FORN(i,SZ(input_graph-&gt;adj_)) {
		sort(ALL(input_graph-&gt;adj_[i]));
		input_graph-&gt;adj_[i].erase(unique(ALL(input_graph-&gt;adj_[i])), input_graph-&gt;adj_[i].end());
		FORIT(j, input_graph-&gt;adj_[i]) if (*j == i) {
			input_graph-&gt;adj_[i].erase(j);
			break;
		}
	}
}

//UnweightedGraph a
//SimplifyUnweightedGraph(&amp;a); //remove all duplicate edges, self-loops;</Snippet>						<Snippet Name="StronglyConnectedComponents">class DisjointSet {
  public:
  	explicit DisjointSet(int n) {
  		whichset_ = vector&lt;int&gt;(n);
  		height_ = vector&lt;int&gt;(n, 1);
  		for (int i = 0; i &lt; n; ++i) whichset_[i] = i;
  	}

  	int Find(int node) {
  		if (whichset_[node] == node) return node;
  		return (whichset_[node] = Find(whichset_[node]));
  	}

  	void Merge(int first_node, int second_node) {
  		//cek siapa mo jadi bokapnya?
  		int h1 = height_[Find(first_node)];
  		int h2 = height_[Find(second_node)];
  		if (h1 &lt; h2) {
	  		whichset_[Find(first_node)] = Find(second_node);
	  		return;
	  	}
	  	whichset_[Find(second_node)] = Find(first_node);
	  	if (h2 &lt; h1) return;
	  	++height_[Find(second_node)];
  	}

  private:
  	vector&lt;int&gt; whichset_;
  	vector&lt;int&gt; height_;
};

//DisjointSet ds(jumlah_node);
//ds.Merge(0,1);
//ds.Find(1) //return 0 ato 1

vector&lt;int&gt; StronglyConnectedComponents(UnweightedGraph* graph, bool should_merge) {

	stack&lt;int&gt; urutan;
	DisjointSet ds(graph-&gt;Size());
	stack&lt; pair&lt;int,int&gt; &gt; ngurut;
	vector&lt;int&gt; sudah(graph-&gt;Size(), 0);
	vector&lt;int&gt; adadiurutan(graph-&gt;Size(), 0);
	for (int i = 0;i &lt; graph-&gt;Size();i++) {
		if (sudah[i]) continue;
		urutan.push(i);
		ngurut.push(make_pair(i,0));
		adadiurutan[i] = 1;
		sudah[i] = 1;
		while (!ngurut.empty()) {
			int id = ngurut.top().first;
			int val = ngurut.top().second;
			ngurut.pop();
			if (val == graph-&gt;adj_[id].size()) {
				while (!urutan.empty() &amp;&amp; urutan.top() == id) urutan.pop();
				adadiurutan[ds.Find(id)] = 0;
				if (!urutan.empty()) adadiurutan[ds.Find(urutan.top())] = 1;
				continue;
				}
			ngurut.push(make_pair(id,val + 1));

			int next = graph-&gt;adj_[id][val];
			if (sudah[next] &amp;&amp; !adadiurutan[ds.Find(next)]) continue;
			if (!sudah[next]) {
				sudah[next] = 1;
				urutan.push(next);
				ngurut.push(make_pair(next,0));
				adadiurutan[next] = 1;
				continue;
				}
			if (ds.Find(id) == ds.Find(next)) continue;
			while (!urutan.empty() &amp;&amp; ds.Find(urutan.top()) != ds.Find(next)) {
				ds.Merge(urutan.top(), next);
				urutan.pop();
				}
			adadiurutan[ds.Find(id)] = 1;
			}
		}
	vector&lt;int&gt; ret(graph-&gt;Size());
  	FORN(i, graph-&gt;Size()) ret[i] = ds.Find(i);

  	if (should_merge) {
   	 	MergeableUnweightedGraph* mwg = dynamic_cast&lt;MergeableUnweightedGraph* &gt;(graph);
   	 	int n = graph-&gt;Size();
   	 	FORN(i, n) mwg-&gt;Merge(i, ret[i]);
  	}
 	 return ret;
}

//MergeableUnweightedGraph muug(n);
//vector&lt;int&gt; groups = StronglyConnectedComponents(&amp;muug, 1); // langsung sama dia dimerge juga, kalo 0 ngga dimerge</Snippet>					</Category>
					<Snippet Name="UnweightedGraphSet">class Graph {
  public:
  	virtual ~Graph() {};
  	virtual void Simplify() {};
};

class UnweightedGraph : public Graph {
  public:
  	UnweightedGraph(int number_of_nodes) : adj_(number_of_nodes) {}
  	UnweightedGraph&amp; operator=(const UnweightedGraph&amp; input_graph) {
  		adj_ = vector&lt;vint&gt;(SZ(input_graph.adj_));
  		FORN(i, SZ(input_graph.adj_)) FORIT(j, input_graph.adj_[i]) this-&gt;AddEdge(i, *j);
  		return *this;
  	}
  	virtual void AddEdge(int from, int to) {
  		adj_[from].PB(to);
  	}
  	virtual int Size() {
  		return adj_.size();
  	}
  	vector&lt; vint &gt; adj_;
};</Snippet>					<Snippet Name="MergeableUnweightedGraph">class MergeableUnweightedGraph : public UnweightedGraph {
  public:
  	explicit MergeableUnweightedGraph(int number_of_nodes) : UnweightedGraph(number_of_nodes), disjoint_set_(number_of_nodes), deleted_edges_count_(0), is_simplified_(0), is_n_changed_(1) {}
  	virtual void AddEdge(int from, int to) {
  		is_simplified_ = 0;
  		UnweightedGraph::AddEdge(from, to);
  	}
  	void Merge(int first_node, int second_node);
  	int Find(int node) {
  		if (!is_simplified_) Simplify();
  		return second_map_[node];
  	}
  	int Size() {
  		if (!is_n_changed_) return n_;
  		is_n_changed_ = 0;
  		n_ = 0;
  		FORN(i,SZ(adj_)) if (disjoint_set_.Find(i) == i) ++n_;
  		return n_;
	}
	template &lt;class cInType&gt;
  	void MoveData(cInType* input_graph);
  	virtual void Simplify();
  	int DeletedEdgesCount() {
  		if (!is_simplified_) Simplify();
  		return deleted_edges_count_;
  	}

  private:
  	GraphOptimizedDisjointSet disjoint_set_;
  	vector&lt;int&gt; second_map_;
  	int deleted_edges_count_;
  	int is_simplified_;
  	int is_n_changed_;
  	int n_;
};

//return true if any edge degrades (a-&gt;b, a merge b)
void MergeableUnweightedGraph::Merge(int first_node, int second_node) {
  	is_simplified_ = 0;
  	is_n_changed_ = 1;
  	int real_first = disjoint_set_.Find(first_node);
  	int real_second = disjoint_set_.Find(second_node);
  	if (real_first == real_second) return;
  	if (!disjoint_set_.Merge(real_first, real_second)) swap(real_first, real_second);
  	//first node is the child of second node
  	FORIT(i, adj_[real_first]) {
  		if (disjoint_set_.Find((*i)) == disjoint_set_.Find(real_first)) {
  			++deleted_edges_count_;
  			continue;
  		}
  		adj_[real_second].PB(disjoint_set_.Find(*i));
  	}
  	adj_[real_first].clear();
  	return;
}

template &lt;class cInType&gt;
void MergeableUnweightedGraph::MoveData(cInType* input_graph) {
  	if (!is_simplified_) Simplify();
  	//pemasangan edges
  	(*input_graph) = cInType(Size());
  	FORN(i,SZ(adj_)) FORIT(j, adj_[i]) input_graph-&gt;AddEdge(second_map_[i], second_map_[*j]);
}

void MergeableUnweightedGraph::Simplify() {
	is_simplified_ = 1;

  	//EXPENSIVE substituting adjacencies
  	FORN(i,SZ(adj_)) FORIT(j, adj_[i]) *j = disjoint_set_.Find(*j);

  	//EXPENSIVE removing degradates
  	FORN(i,SZ(adj_)) {
  		int org = SZ(adj_[i]);
  		adj_[i].erase(remove_if(ALL(adj_[i]), bind1st(equal_to&lt;int&gt;(), i)), adj_[i].end());
  		deleted_edges_count_ += org - SZ(adj_[i]);
  	}

  	//simplifying nodes
  	vector&lt;int&gt; active_nodes;
  	FORN(i,SZ(adj_)) if (disjoint_set_.Find(i) == i) active_nodes.PB(i);
  	vector&lt;int&gt; tmp_map = SequenceSimplify(active_nodes);
  	second_map_ = vector&lt;int&gt;(SZ(adj_));
  	FORN(i,SZ(active_nodes)) second_map_[active_nodes[i]] = tmp_map[i];
  	FORN(i,SZ(adj_)) second_map_[i] = second_map_[disjoint_set_.Find(i)];
}

//MergeableUnweightedGraph muug(n);
//muug.Merge(0,1);
//muug.AddEdge(2,3);
//muug.AddEdge(1,0);
//muug.Size() == n-1; amortized o(1)
//muug.Simplify()
//muug.DeletedEdgesCount() == 1;
//UnweightedGraph another(muug.Size());
//muug.MoveData(&amp;another); //jadi yg sudah tercompres, bisa dicek pake muug.Find(node) ke siapa dicompressnya</Snippet>				</Category>
				<Category Name="WEIGHTEDGRAPH">
					<Category Name="SHORTESTPATH">
						<Snippet Name="DjikstraMemoizedWeightedGraph">template &lt;class cWeight&gt;
class DjikstraWeightedGraph : public WeightedGraph&lt;cWeight&gt; {
  public:
    //selector dari bokap
    vector&lt; vector&lt; pair&lt;int, cWeight&gt; &gt; &gt;&amp; adj_;
    explicit DjikstraWeightedGraph(int number_of_nodes) :
        WeightedGraph&lt;cWeight&gt;(number_of_nodes),
        adj_(WeightedGraph&lt;cWeight&gt;::adj_) {}
  int Size() { return SZ(adj_); }
  virtual vector&lt; cWeight &gt; SingleSourceShortestPath(int source, int stop_condition = -1);
  virtual cWeight ShortestPath(int source, int target) {
    vector&lt; cWeight &gt; min_distance = SingleSourceShortestPath(source, target);
    return min_distance[target];
  }
  private:
    static const cWeight kUnreachable = -1;
};

template &lt;class cWeight&gt;
vector&lt; cWeight &gt; DjikstraWeightedGraph&lt;cWeight&gt;::SingleSourceShortestPath(int source, int stop_condition) {
	vector&lt; cWeight &gt; min_distances(Size(), kUnreachable);
	min_distances[source] = 0;
	set&lt; pair&lt; cWeight, int &gt; &gt; pq;
	pq.insert(MP(0, source));

	while (!pq.empty()) {
		cWeight top_weight = pq.begin()-&gt;A;
		int top_node = pq.begin()-&gt;B;
		pq.erase(pq.begin());
		if (top_node == stop_condition) return min_distances;
		FORIT(i, adj_[top_node]) {
			if (min_distances[i-&gt;A] == -1 || min_distances[i-&gt;A] &gt; top_weight + i-&gt;B) {
				min_distances[i-&gt;A] = top_weight + i-&gt;B;
				pq.insert(MP(top_weight + i-&gt;B, i-&gt;A));
			}
		}
	}
	return min_distances;
}

template &lt;class cWeight&gt;
class DjikstraMemoizedWeightedGraph : public DjikstraWeightedGraph&lt;cWeight&gt; {
  public:
  	//selector dari bokap
  	vector&lt; vector&lt; pair&lt;int, cWeight&gt; &gt; &gt;&amp; adj_ ;

  	explicit DjikstraMemoizedWeightedGraph(int number_of_nodes) : DjikstraWeightedGraph&lt;cWeight&gt;(number_of_nodes),
  	                                                      		  adj_(DjikstraWeightedGraph&lt;cWeight&gt;::adj_), is_computed_(0),
  	                                                      		  memo_(number_of_nodes) {}

  	virtual void AddEdge(int from, int to, cWeight weight) {
  		if (is_computed_) {
  			is_computed_ = 0;
  			memo_ = vector&lt; vector&lt; cWeight &gt; &gt;(SZ(adj_));
  		}
  		WeightedGraph&lt;cWeight&gt;::AddEdge(from, to, weight);
  	}

  	virtual vector&lt; cWeight &gt; SingleSourceShortestPath(int source) {
  		if (SZ(memo_[source]) != 0) return memo_[source];
  		is_computed_ = 1;
  		return memo_[source] = DjikstraWeightedGraph&lt;cWeight&gt;::SingleSourceShortestPath(source, -1);
  		}
  	virtual cWeight ShortestPath(int source, int target) {
  		if (SZ(memo_[source]) == 0) SingleSourceShortestPath(source);
  		return memo_[source][target];
  		}
  private:
  	int is_computed_;
  	vector&lt; vector&lt; cWeight &gt; &gt; memo_;
};

//N : jumlah node
//memory : N^2
//complexity : N^2 log N
//DjikstraMemoizedWeightedGraph&lt;double&gt; dmwg(n);
//dmwg.AddEdge(0,1,50.5);
//dmwg.ShortestPath(0,1) == 50.5;
//dmwg.SingleSourceShortestPath(0) == vector&lt;double&gt;</Snippet>						<Snippet Name="DjikstraWeightedGraph">template &lt;class cWeight&gt;
class DjikstraWeightedGraph : public WeightedGraph&lt;cWeight&gt; {
  public:
    //selector dari bokap
    vector&lt; vector&lt; pair&lt;int, cWeight&gt; &gt; &gt;&amp; adj_;
    explicit DjikstraWeightedGraph(int number_of_nodes) :
        WeightedGraph&lt;cWeight&gt;(number_of_nodes),
        adj_(WeightedGraph&lt;cWeight&gt;::adj_) {}
  int Size() { return SZ(adj_); }
  virtual vector&lt; cWeight &gt; SingleSourceShortestPath(int source, int stop_condition = -1);
  virtual cWeight ShortestPath(int source, int target) {
    vector&lt; cWeight &gt; min_distance = SingleSourceShortestPath(source, target);
    return min_distance[target];
  }
  private:
    static const cWeight kUnreachable = -1;
};

template &lt;class cWeight&gt;
vector&lt; cWeight &gt; DjikstraWeightedGraph&lt;cWeight&gt;::SingleSourceShortestPath(int source, int stop_condition) {
	vector&lt; cWeight &gt; min_distances(Size(), kUnreachable);
	min_distances[source] = 0;
	set&lt; pair&lt; cWeight, int &gt; &gt; pq;
	pq.insert(MP(0, source));

	while (!pq.empty()) {
		cWeight top_weight = pq.begin()-&gt;A;
		int top_node = pq.begin()-&gt;B;
		pq.erase(pq.begin());
		if (top_node == stop_condition) return min_distances;
		FORIT(i, adj_[top_node]) {
			if (min_distances[i-&gt;A] == -1 || min_distances[i-&gt;A] &gt; top_weight + i-&gt;B) {
				min_distances[i-&gt;A] = top_weight + i-&gt;B;
				pq.insert(MP(top_weight + i-&gt;B, i-&gt;A));
			}
		}
	}
	return min_distances;
}

//N : nodes, M : jumlah func_call, E : jumlah edges
//memory : E
//complexity : M * N log N
//DjikstraWeightedGraph&lt;double&gt; dwg(n);
//dwg.AddEdge(0,1,50.5);
//dwg.ShortestPath(0,1) == 50.5
//dwg.Size() == n
//dwg.SingleSourceShortestPath(0) == vector&lt;double&gt; {1.0, -1.0, ...}</Snippet>					</Category>
					<Snippet Name="WeightedGraphSet">class Graph {
  public:
  	virtual ~Graph() {};
  	virtual void Simplify() {};
};

template &lt;class cWeight&gt;
class WeightedGraph : public Graph {
  public:
  	WeightedGraph(int number_of_nodes) : adj_(number_of_nodes) {}
  	template &lt;class cWeight2&gt;
  	WeightedGraph&lt;cWeight&gt;&amp; operator=(const WeightedGraph&lt;cWeight2&gt;&amp; input_graph) {
  		adj_ = vector&lt;vint&gt;(SZ(input_graph.adj_));
  		FORN(i, SZ(input_graph.adj_)) FORIT(j, input_graph.adj_[i]) this-&gt;AddEdge(i, j-&gt;A, j-&gt;B);
  		return *this;
  	}
  	virtual void AddEdge(int from, int to, cWeight weight) {
  		adj_[from].PB(MP(to, weight));
  	}
  	vector&lt; vector&lt; pair&lt;int, cWeight&gt; &gt; &gt; adj_;
};</Snippet>					<Snippet Name="MergeableWeightedGraph">class GraphOptimizedDisjointSet {
  public:
  	explicit GraphOptimizedDisjointSet(int n) {
  		whichset_ = vector&lt;int&gt;(n);
  		node_count_ = vector&lt;int&gt;(n, 1);
  		for (int i = 0; i &lt; n; ++i) whichset_[i] = i;
  	}

  	int Find(int node) {
  		if (whichset_[node] == node) return node;
  		return (whichset_[node] = Find(whichset_[node]));
  	}

  	//return 1 if first_node become child of second_node
  	int Merge(int first_node, int second_node) {
  		//cek siapa mo jadi bokapnya?
  		if (node_count_[Find(first_node)] &lt; node_count_[Find(second_node)]) {
  			whichset_[Find(first_node)] = Find(second_node);
  			node_count_[Find(second_node)] += node_count_[Find(first_node)];
  			return 1;
  		}
  		whichset_[Find(second_node)] = Find(first_node);
	  	node_count_[Find(first_node)] += node_count_[Find(second_node)];
	  	return 0;
  	}

  private:
  	mutable vector&lt;int&gt; whichset_;
  	vector&lt;int&gt; node_count_;
};

//O(n log n)
vector&lt;int&gt; SequenceSimplify(vector&lt;int&gt; seq) {
	int lowest = 0;
	vector&lt;int&gt; disort = seq;
	sort(ALL(disort));
	disort.erase(unique(ALL(disort)),disort.end());
	FORN(i,SZ(seq)) {
		seq[i] = (lower_bound(ALL(disort),seq[i]) - disort.begin()) + lowest;
		}
	return seq;
	}

//vint a = {10, 50, 5, 50, 10, 70}
//SequenceSimplify(a) = {1, 2, 0, 2, 1, 3}



template &lt;class cWeight&gt;
class MergeableWeightedGraph : public WeightedGraph&lt;cWeight&gt; {
  public:
  	//selector dari bokap
  	vector&lt; vector&lt; pair&lt;int, cWeight&gt; &gt; &gt;&amp; adj_;

  	explicit MergeableWeightedGraph(int number_of_nodes) : WeightedGraph&lt;cWeight&gt;(number_of_nodes), adj_(WeightedGraph&lt;cWeight&gt;::adj_),
  														   disjoint_set_(number_of_nodes), deleted_edges_count_(0), is_simplified_(0) {}

	virtual void AddEdge(int first_node, int second_node, cWeight weight) {
		is_simplified_ = 0;
		WeightedGraph&lt;cWeight&gt;::AddEdge(first_node, second_node, weight);
	}

  	void Merge(int first_node, int second_node);
  	int Find(int node) {
  		if (!is_simplified_) Simplify();
  		return second_map_[node];
  	}
  	int Size() {
  		int ret = 0;
  		FORN(i,SZ(adj_)) if (disjoint_set_.Find(i) == i) ++ret;
  		return ret;
	}
	template &lt;class cInType&gt;
  	void MoveData(cInType* input_graph);
  	virtual void Simplify();
  	int DeletedEdgesCount() {
  		if (!is_simplified_) Simplify();
  		return deleted_edges_count_;
  	}

  private:
  	class CmpEdge : public binary_function&lt;int, pair&lt;int, cWeight&gt;, bool&gt; {
		public:
		bool operator() (const int first_element, const pair&lt;int,cWeight&gt; adj_element) const { return first_element == adj_element.A; }
	};
  	GraphOptimizedDisjointSet disjoint_set_;
  	vector&lt;int&gt; second_map_;
  	int deleted_edges_count_;
  	int is_simplified_;

};

//return true if any edge degrades (a-&gt;b, a merge b)
template &lt;class cWeight&gt;
void MergeableWeightedGraph&lt;cWeight&gt;::Merge(int first_node, int second_node) {
	is_simplified_ = 0;
  	int real_first = disjoint_set_.Find(first_node);
  	int real_second = disjoint_set_.Find(second_node);
  	if (real_first == real_second) return;
  	if (!disjoint_set_.Merge(real_first, real_second)) swap(real_first, real_second);
  	//first node is the child of second node
  	FORIT(i, adj_[real_first]) {
  		if (disjoint_set_.Find((i-&gt;A)) == disjoint_set_.Find(real_first)) {
  			++deleted_edges_count_;
  			continue;
  		}
  		adj_[real_second].PB(MP(disjoint_set_.Find(i-&gt;A), i-&gt;B));
  	}
  	adj_[real_first].clear();
  	return;
}

template &lt;class cWeight&gt;
template &lt;class cInType&gt;
void MergeableWeightedGraph&lt;cWeight&gt;::MoveData(cInType* input_graph) {
  	if (!is_simplified_) Simplify();
  	//pemasangan edges
  	FORN(i,SZ(adj_)) FORIT(j, adj_[i]) input_graph-&gt;AddEdge(second_map_[i], second_map_[j-&gt;A], j-&gt;B);
}


template &lt;class cWeight&gt;
void MergeableWeightedGraph&lt;cWeight&gt;::Simplify() {
	is_simplified_ = 1;
  	//EXPENSIVE substituting adjacencies
  	FORN(i,SZ(adj_)) FORIT(j, adj_[i]) j-&gt;A = disjoint_set_.Find(j-&gt;A);
  	//EXPENSIVE removing degradates
  	FORN(i,SZ(adj_)) {
  		int org = SZ(adj_[i]);
  		adj_[i].erase(remove_if(ALL(adj_[i]), (bind1st(CmpEdge(), i))), adj_[i].end());
  		deleted_edges_count_ += org - SZ(adj_[i]);
  	}
  	//simplifying nodes
  	vector&lt;int&gt; active_nodes;
  	FORN(i,SZ(adj_)) if (disjoint_set_.Find(i) == i) active_nodes.PB(i);
  	vector&lt;int&gt; tmp_map = SequenceSimplify(active_nodes);
  	second_map_ = vector&lt;int&gt;(SZ(adj_));
  	FORN(i,SZ(active_nodes)) second_map_[active_nodes[i]] = tmp_map[i];
  	FORN(i,SZ(adj_)) second_map_[i] = second_map_[disjoint_set_.Find(i)];
}

//MergeableWeightedGraph&lt;double&gt; mwg(n);
//mwg.Merge(0,1);
//mwg.AddEdge(2,3,6.5);
//mwg.Size() == n-1;
//mwg.Simplify() //O(N) hati2
//mwg.DeletedEdgesCount() == 1
//WeightedGraph another(muug.Size());
//mwg.MoveData(&amp;another); //jadi yg sudah tercompres, bisa dicek pake muug.Find(node) ke siapa dicompressnya</Snippet>				</Category>
			</Category>
			<Snippet Name="Graph">class Graph {
  public:
    Graph(int n) {
      assert(n &gt;= 0);
      adj_ = new vector&lt;int&gt;[n];
      wei_  = new vector&lt;int&gt;[n];
      id_ = new vector&lt;int&gt;[n];
      n_ = n;
      m_ = 0;
    }
  
  	virtual ~Graph() {
      delete[] adj_;
      delete[] wei_;
      delete[] id_;
    };
  	
    // Add directed edge
    virtual void AddDirEdge(int from, int to, int weight=0) {
      assert(from &gt;= 0 &amp;&amp; from &lt; n());
      assert(to &gt;= 0 &amp;&amp; to &lt; n());
      id_[from].PB(m_);
      adj_[from].PB(to);
      wei_[from].PB(weight);
      ++m_;
    }
    
    // Add bidirectional edge
    virtual void AddBiEdge(int a, int b, int weight=0) {
      assert(a &gt;= 0 &amp;&amp; a &lt; n());
      assert(b &gt;= 0 &amp;&amp; b &lt; n());
      AddDirEdge(a, b, weight);
      if (a != b) {
        // this edge should be treated like the previous one.
        --m_;
        AddDirEdge(b, a, weight);
      }
    }
    
    vector&lt;int&gt;* adj() { return adj_; }
    vector&lt;int&gt;* wei() { return wei_; }
    vector&lt;int&gt;* id() { return id_; }
    int n() { return n_; }
    int m() { return m_; }
    
  private:
    vector&lt;int&gt;* adj_;  // adjacency list. Using pointer for efficiency.
    vector&lt;int&gt;* wei_;  // corresponding weight.
    vector&lt;int&gt;* id_;  // id of edge. First edge added = 0, dst.
    int m_;  // number of edges
    int n_;  // number of nodes
};</Snippet>		</Category>
		<Category Name="MAP PROCESS">
			<Category Name="TRANSFORMATION">
				<Snippet Name="rotate90degrees">//counterclockwise
vector&lt;string&gt; rotate90degrees(vector&lt;string&gt; abc) {
	vector&lt;string&gt; def = vector&lt;string&gt;(SZ(abc[0]),string(SZ(abc),'.'));
	FORN(i,SZ(abc)) {
		FORN(j,SZ(abc[0])) {
			def[SZ(abc[0]) - 1 - j][i] = abc[i][j];
			}
		}
	return def;
	}	</Snippet>				<Snippet Name="vreflect">/*
AB -&gt; BA
CD    DC*/
vector&lt;string&gt; vreflect(vector&lt;string&gt;&amp;abc) {
	vector&lt;string&gt; def = abc;
	FORN(i,SZ(abc)) FORN(j,SZ(abc[0])) def[i][j] = abc[i][SZ(abc[0])-j-1];
	return def;
	}</Snippet>				<Snippet Name="hreflect">/*
AB -&gt; CD
CD -&gt; AB*/
vector&lt;string&gt; hreflect(vector&lt;string&gt;&amp; abc) {
	vector&lt;string&gt; def = abc;
	FORN(i,SZ(abc)) FORN(j,SZ(abc[0])) def[i][j] = abc[SZ(abc)-i-1][j];
	return def;
	}</Snippet>			</Category>
			<Category Name="ALGORITHMS">
				<Snippet Name="Map2D">class Map2D {
  public:
	vector&lt;string&gt; peta_;
	char impassable_;
	int row_, col_;
	Map2D(vector&lt;string&gt; peta, string impassable) {
		row_ = SZ(peta);
		col_ = SZ(peta[0]);
		peta_ = peta;
		FORN(i, SZ(impassable)) FORN(r,row_) FORN(c,col_) if (peta_[r][c] == impassable[i]) {
			peta_[r][c] = impassable[0];
		}
		impassable_ = impassable[0];
	}

	bool IsInside(int row, int col) {
		return row &gt;= 0 &amp;&amp; row &lt; row_ &amp;&amp; col &gt;= 0 &amp;&amp; col &lt; col_;
	}

	vector&lt; vector&lt;int&gt; &gt; Distance(int row, int col, int dr[], int dc[]) {
		vector&lt; vint &gt; ret(row_, vint(col_, -1));
		ret[row][col] = 0;
		queue&lt; pair&lt;int,int&gt; &gt; q;
		q.push(MP(row,col));
		while (!q.empty()) {
			int r = q.front().first;
			int c = q.front().second;
			q.pop();
			for (int dir = 0; dir &lt; 4; ++dir) {
				if (IsInside(r+dr[dir], c+dc[dir]) &amp;&amp;
					ret[r+dr[dir]][c+dc[dir]] == -1 &amp;&amp;
					peta_[r+dr[dir]][c+dc[dir]] != impassable_) {
					ret[r+dr[dir]][c+dc[dir]] = ret[r][c]+1;
					q.push(MP(r+dr[dir],c+dc[dir]));
				}
			}
		}
		return ret;
	}
};
//Map2D m2(vector&lt;string&gt; peta, &quot;#X&quot; - impassables)
//vector&lt;vint&gt; m2.Distance(0,1,dr,dc); //distance dari 0,1 ke smua, -1 kalo ga bisa</Snippet>				<Snippet Name="FloodFill w Separate">namespace flood_fill_arrays {
int dr_[] = {1,0,-1,0};
int dc_[] = {0,1,0,-1};
int move_count_ = 4;
}

vector&lt;string&gt; removeborders(vector&lt;string&gt; abc, char diremove) {
	int retop=0,redown=0,rekiri=0,rekanan=0;
	while (retop &lt; SZ(abc)) {
		int boleh = 1;
		FORN(i,SZ(abc[0])) if (abc[retop][i] != diremove) boleh = 0;
		if (!boleh) break;
		retop++;
		}
	while (redown &lt; SZ(abc)) {
		int boleh = 1;
		FORN(i,SZ(abc[0])) if (abc[SZ(abc) - redown - 1][i] != diremove) boleh = 0;
		if (!boleh) break;
		redown++;
		}
	while (rekiri &lt; SZ(abc[0])) {
		int boleh = 1;
		FORN(i,SZ(abc)) if (abc[i][rekiri] != diremove) boleh = 0;
		if (!boleh) break;
		rekiri++;
		}
	while (rekanan &lt; SZ(abc[0])) {
		int boleh = 1;
		FORN(i,SZ(abc)) if (abc[i][SZ(abc[0]) - rekanan - 1] != diremove) boleh = 0;
		if (!boleh) break;
		rekanan++;
		}
	vector&lt;string&gt; hasil;
	REP(i,retop,SZ(abc) - redown) {
		string dumi = &quot;&quot;;
		REP(j,rekiri,SZ(abc[0]) - rekanan) {
			dumi += abc[i][j];
			}
		hasil.PB(dumi);
		}
	return hasil;
	}

class FloodFill {
  public:
	FloodFill(const vector&lt;string&gt;&amp; board, const char impassable) : board_(board), impassable_(impassable) {flood_fill();}
	~FloodFill() {}
	int component_count() const {return component_count_;}
	vector&lt; vector&lt;int&gt; &gt; flood_result() const {return flood_result_;}
	vector&lt; vector&lt;string&gt; &gt; separate() const {return separate_;}

  private:
  	vector&lt;string&gt; board_;
  	vector&lt; vector&lt;int&gt; &gt; flood_result_;
  	vector&lt; vector&lt;string&gt; &gt; separate_;
  	char impassable_;
  	int component_count_;

  	void enframe() {
		string huhu(SZ(board_[0]) + 2,impassable_);
		FORN(i,SZ(board_)) board_[i] = impassable_ + board_[i] + impassable_;
		board_.insert(board_.begin(),huhu);
		board_.push_back(huhu);
		return;
	}

  	void flood_fill() {
  		using namespace flood_fill_arrays;
  		flood_result_ = vector&lt; vector&lt; int &gt; &gt;(SZ(board_),vint(SZ(board_[0]),-1));
  		component_count_ = 0;
  		enframe();
  		stack&lt; pair&lt;int,int&gt; &gt; spii;
  		FORN(i,SZ(board_)) FORN(j,SZ(board_[i])) if (board_[i][j] != impassable_ &amp;&amp; flood_result_[i-1][j-1] == -1) {
  			flood_result_[i-1][j-1] = component_count_;
  			spii.push(MP(i,j));
  			while (!spii.empty()) {
  				int topr = spii.top().A;
  				int topc = spii.top().B;
  				spii.pop();
  				FORN(k,move_count_) {
  					topr += dr_[k];
  					topc += dc_[k];
  					if (board_[topr][topc] != impassable_ &amp;&amp; flood_result_[topr-1][topc-1] == -1) {
  						flood_result_[topr-1][topc-1] = component_count_;
  						spii.push(MP(topr,topc));
  					}
  					topr -= dr_[k];
  					topc -= dc_[k];
  				}
  			}
  			++component_count_;
  		}

  		separate_.clear();
  		FORN(i, component_count_) {
  			vector&lt; string &gt; component(SZ(flood_result_), string(SZ(flood_result_[0]), impassable_));
  			FORN(j, SZ(flood_result_)) FORN(k, SZ(flood_result_[0])) {
  				if (flood_result_[j][k] == i) component[j][k] = board_[j+1][k+1];
  			}
  			component = removeborders(component, '.');
  			separate_.PB(component);
  		}

  	}

};

/*
FloodFill ff(vector&lt;string&gt; petanya, char impassable);
int jumlahkomponen = ff.component_count();
vector&lt; vint &gt; whosecomponent = ff.flood_result(); //-1 kalau dia air, trus id component diindex dari 0
vector&lt; vector&lt;string&gt; &gt; components = ff.separate(); // tiap2 potongan bentuk kotak2 sudah sekecil mungkin
*/</Snippet>			</Category>
			<Snippet Name="enframe(vector&lt;str&gt; char)">vector&lt;string&gt; enframe(vector&lt;string&gt; abc, char impassable) {
	string huhu(SZ(abc[0]) + 2,impassable);
	FORN(i,SZ(abc)) abc[i] = impassable + abc[i] + impassable;
	abc.insert(abc.begin(),huhu);
	abc.push_back(huhu);
	return abc;
	}</Snippet>			<Snippet Name="removeborders">vector&lt;string&gt; removeborders(vector&lt;string&gt; abc, char diremove) {
	int retop=0,redown=0,rekiri=0,rekanan=0;
	while (retop &lt; SZ(abc)) {
		int boleh = 1;
		FORN(i,SZ(abc[0])) if (abc[retop][i] != diremove) boleh = 0;
		if (!boleh) break;
		retop++;
		}
	while (redown &lt; SZ(abc)) {
		int boleh = 1;
		FORN(i,SZ(abc[0])) if (abc[SZ(abc) - redown - 1][i] != diremove) boleh = 0;
		if (!boleh) break;
		redown++;
		}
	while (rekiri &lt; SZ(abc[0])) {
		int boleh = 1;
		FORN(i,SZ(abc)) if (abc[i][rekiri] != diremove) boleh = 0;
		if (!boleh) break;
		rekiri++;
		}
	while (rekanan &lt; SZ(abc[0])) {
		int boleh = 1;
		FORN(i,SZ(abc)) if (abc[i][SZ(abc[0]) - rekanan - 1] != diremove) boleh = 0;
		if (!boleh) break;
		rekanan++;
		}
	vector&lt;string&gt; hasil;
	REP(i,retop,SZ(abc) - redown) {
		string dumi = &quot;&quot;;
		REP(j,rekiri,SZ(abc[0]) - rekanan) {
			dumi += abc[i][j];
			}
		hasil.PB(dumi);
		}
	return hasil;
	}</Snippet>		</Category>
		<Category Name="FLOW">
			<Category Name="MAXIMUM FLOW">
				<Snippet Name="mf[PushRelabel]">//Adjacency List Network Flow INTEGER BASED NON EPSILON
//O(V^3 + VE)
//memory 2 * V^2
template &lt;class ta&gt;
pair&lt;ta, vector&lt; vector&lt; ta &gt; &gt; &gt; netFlow (vector&lt; vector&lt; pair&lt;int, ta&gt; &gt; &gt; nfadj, int tap, int sink) {

	vector&lt; vector&lt; pair&lt;int, ta&gt; &gt; &gt; org = nfadj;

	int nnf = SZ(nfadj);
	vector&lt; vint &gt; neighbor;
	vint current;
	vint h;
	vector&lt; ta &gt; excess;

	list &lt;int&gt; li;

	FORN(i,nnf) {
		current.PB(0);
		excess.PB( (ta) 0);
		vint tempneighbor;
		neighbor.PB(tempneighbor);
		h.PB(0);
		if (i != sink &amp;&amp; i != tap) li.PB(i);
		}

	h[tap] = nnf;
	vector&lt; vector&lt; ta &gt; &gt; capacity(nnf,vector&lt; ta &gt;(nnf,(ta)0));
	vector&lt; vector&lt; ta &gt; &gt; flow(nnf,vector&lt; ta &gt;(nnf,(ta)0));

	FORN(i,nnf) {
		FORN(j,SZ(nfadj[i])) {
			neighbor[i].PB(nfadj[i][j].A);
			neighbor[nfadj[i][j].A].PB(i);
			capacity[i][nfadj[i][j].A] += nfadj[i][j].B;
			}
		}

	FORN(i,nnf) {
		sort(ALL(neighbor[i]));
		neighbor[i].erase(unique(ALL(neighbor[i])),neighbor[i].end());

		}

	FORN(i,SZ(nfadj[tap])) {
		flow[tap][nfadj[tap][i].A] += nfadj[tap][i].B;
		flow[nfadj[tap][i].A][tap] -= nfadj[tap][i].B;
		excess[nfadj[tap][i].A] += nfadj[tap][i].B;
		}

	list&lt;int&gt;::iterator it;
	it = li.begin();
	while (it != li.end()) {
		int oldh = h[*it];
		while (excess[*it] &gt; (ta)0) {
			if (current[*it] == SZ(neighbor[*it])) {
				//relabel
				int newh = INF;
				FORN(i,SZ(neighbor[*it])) {
					int j = neighbor[*it][i];
					if (capacity[*it][j] - flow[*it][j] &gt; (ta)0) MN(newh,h[j]+1);
					}
				h[*it] = newh;
				current[*it] = 0;
				//end of relabel
				}
			else {
				//push
				int j = neighbor[*it][current[*it]];
				if (h[*it] != h[j]+1 || capacity[*it][j] - flow[*it][j] &lt;= (ta)0) {
					current[*it]++;
					continue;
					}
				ta pushthis = min(capacity[*it][j] - flow[*it][j],excess[*it]);
				excess[*it] -= pushthis;
				excess[j] += pushthis;
				flow[*it][j] += pushthis;
				flow[j][*it] -= pushthis;
				}
			}

		if (oldh != h[*it]) {
			//push to front
			li.push_front(*it);
			li.erase(it);
			it = li.begin();
			}
		it++;
		}

	vector&lt; vector&lt; ta &gt; &gt; orgflow(SZ(org));

	FORN(i,SZ(org)) FORN(j,SZ(org[i])) {
		ta cand = 0;
		if (flow[i][org[i][j].A] &gt; (ta)0) {
			cand = min(flow[i][org[i][j].A],org[i][j].B);
			}
		flow[i][org[i][j].A] -= cand;
		orgflow[i].PB(cand);
		}

	return MP(excess[sink],orgflow);
	}

template &lt;class _c&gt;
struct mf {
	vector&lt; vector&lt; pair&lt; int, _c &gt; &gt; &gt; adj;
	vector&lt; int &gt; status;
	vector&lt; vector&lt; _c &gt; &gt; flow;
	_c maxflowvalue;

	mf (int nm) {
		adj = vector&lt; vector&lt; pair&lt; int, _c &gt; &gt; &gt;(nm);
		status = vint(nm,0);
		}

	void addedge(int from,int to,_c cap=(_c)1) {
		adj[from].PB(MP(to,cap));
		}

	void addbiedge(int from,int to, _c cap=(_c)1) {
		addedge(from,to,cap);
		addedge(to,from,cap);
		}

	void solve(int tap,int sink) {
		pair&lt;_c, vector&lt; vector&lt; _c &gt; &gt; &gt; ja = netFlow(adj,tap,sink);
		maxflowvalue = ja.A;
		flow = ja.B;
		}

	_c maxflow(int tap, int sink) {
		solve(tap,sink);
		return maxflowvalue;
		}
	};

/*
mf&lt;int&gt; a(n);
a.addedge(FROM,TO,CAPACITY);
a.maxflow(TAP,SINK);
*/</Snippet>				<Snippet Name="mf_S[maxaugment]">//Adjacency List Network Flow INTEGER BASED NON EPSILON
//max augmenting path
//memory 2 * V^2
template &lt;class ta&gt;
pair&lt;ta, vector&lt; vector&lt; ta &gt; &gt; &gt; netFlow (vector&lt; vector&lt; pair&lt;int, ta&gt; &gt; &gt; nfadj, int tap, int sink, ta infin = 1123123123LL) {
	//debug(&quot;ndut&quot;);
	int n = SZ(nfadj);

	vector&lt; vector&lt; pair&lt;int,ta&gt; &gt; &gt; copynfadj = nfadj;

	//creating reverse adjacency list
	vector&lt; vector&lt; int &gt; &gt; reverseadj(n,vint());
	//debug(n);
	FORN(i,n) {
		//debug(i);
		FORN(j,SZ(nfadj[i])) {
			//find the corresponding partner
			int to = nfadj[i][j].A;
			//debug(to);
			int found = 0;
			FORN(k,SZ(nfadj[to])) {
				//debug(k);
				if (nfadj[to][k].A == i) {
					found = 1;
					//debug(k);
					reverseadj[i].PB(k);
					break;
					}
				}
			if (!found) {
				reverseadj[i].PB(SZ(nfadj[to]));
				nfadj[to].PB(MP(i,0));
				if (to &lt; i) reverseadj[to].PB(j);
				}
			}
		}

	vector&lt; ta &gt; maxpipe(n);
	vector&lt; int &gt; from(n);
	vector&lt; int &gt; jalan(n);

	typedef pair&lt; ta, int &gt; pti;


	ta total = (ta)0;

	while (1) {
		//debug(total);
		//find an augmenting path with maximum you-know-what
		priority_queue &lt; pti &gt; pq;
		FORN(i,n) maxpipe[i] = (ta)0;
		FORN(i,n) from[i] = -1;
		maxpipe[tap] = infin; //huge number representative
		pq.push(MP(infin,tap));

		while (!pq.empty()) {
			ta a = pq.top().A;
			int b = pq.top().B;
			pq.pop();
			if (maxpipe[b] != a) continue;

			if (b == sink) {
				//pq.clear();
				break;
				}

			FORN(i,SZ(nfadj[b])) if (nfadj[b][i].B &gt; (ta)0) {
				//found
				int to = nfadj[b][i].A;
				int trynext = min(a,nfadj[b][i].B);
				if (maxpipe[to] &gt;= trynext) continue;
				from[to] = b;
				jalan[to] = i;
				maxpipe[to] = trynext;
				pq.push(MP(trynext,to));
				}
			}

		//if no path is found break
		if (maxpipe[sink] == (ta)0) break;
		ta nflow = maxpipe[sink];

		total += nflow;
		//augment
		int terakhir = sink;
		while (from[terakhir] != -1) {
			//decrease the flow
			nfadj[from[terakhir]][jalan[terakhir]].B -= nflow;
			//increase the flow
			nfadj[terakhir][reverseadj[from[terakhir]][jalan[terakhir]]].B += nflow;
			terakhir = from[terakhir];
			}
		}

	//well well, what do we want here?
	vector&lt; vector&lt; ta &gt; &gt; retmaxflow(n, vector&lt; ta &gt;());

	FORN(i,n) FORN(j,SZ(copynfadj[i])) {
		if (copynfadj[i][j].B &gt; nfadj[i][j].B) retmaxflow[i].PB(copynfadj[i][j].B - nfadj[i][j].B); else
		retmaxflow[i].PB(0);
		}

	return MP(total,retmaxflow);

	}

template &lt;class _c&gt;
struct mf {
	vector&lt; vector&lt; pair&lt; int, _c &gt; &gt; &gt; adj;
	vector&lt; int &gt; status;
	vector&lt; vector&lt; _c &gt; &gt; flow;
	_c maxflowvalue;

	mf (int nm) {
		adj = vector&lt; vector&lt; pair&lt; int, _c &gt; &gt; &gt;(nm);
		status = vint(nm,0);
		}

	void addedge(int from,int to,_c cap=(_c)1) {
		adj[from].PB(MP(to,cap));
		}

	void addbiedge(int from,int to, _c cap=(_c)1) {
		addedge(from,to,cap);
		addedge(to,from,cap);
		}

	void solve(int tap,int sink) {
		pair&lt;_c, vector&lt; vector&lt; _c &gt; &gt; &gt; ja = netFlow(adj,tap,sink);
		maxflowvalue = ja.A;
		flow = ja.B;
		}

	_c maxflow(int tap, int sink) {
		solve(tap,sink);
		return maxflowvalue;
		}
	};

/*
mf&lt;int&gt; a(n);
a.addedge(FROM,TO,CAPACITY);
a.maxflow(TAP,SINK);
*/</Snippet>				<Category Name="LEGACY">
					<Snippet Name="pushToFront[INT][ADJLIST]">//Adjacency List Network Flow INTEGER BASED NON EPSILON
//O(V^3 + VE)
//memory 2 * V^2
template &lt;class ta&gt;
ta netFlow (vector&lt; vector&lt; pair&lt;int, ta&gt; &gt; &gt; nfadj, int tap, int sink) {
	int nnf = SZ(nfadj);
	vector&lt; vint &gt; neighbor;
	vint current;
	vint h;
	vector&lt; ta &gt; excess;

	list &lt;int&gt; li;

	FORN(i,nnf) {
		current.PB(0);
		excess.PB( (ta) 0);
		vint tempneighbor;
		neighbor.PB(tempneighbor);
		h.PB(0);
		if (i != sink &amp;&amp; i != tap) li.PB(i);
		}

	h[tap] = nnf;
	vector&lt; vector&lt; ta &gt; &gt; capacity(nnf,vint(nnf,(ta)0));
	vector&lt; vector&lt; ta &gt; &gt; flow(nnf,vint(nnf,(ta)0));

	FORN(i,nnf) {
		FORN(j,SZ(nfadj[i])) {
			neighbor[i].PB(nfadj[i][j].A);
			neighbor[nfadj[i][j].A].PB(i);
			capacity[i][nfadj[i][j].A] += nfadj[i][j].B;
			}
		}

	FORN(i,nnf) {
		sort(ALL(neighbor[i]));
		neighbor[i].erase(unique(ALL(neighbor[i])),neighbor[i].end());

		}

	FORN(i,SZ(nfadj[tap])) {
		flow[tap][nfadj[tap][i].A] += nfadj[tap][i].B;
		flow[nfadj[tap][i].A][tap] -= nfadj[tap][i].B;
		excess[nfadj[tap][i].A] += nfadj[tap][i].B;
		}

	list&lt;int&gt;::iterator it;
	it = li.begin();
	while (it != li.end()) {
		int oldh = h[*it];
		while (excess[*it] &gt; (ta)0) {
			if (current[*it] == SZ(neighbor[*it])) {
				//relabel
				int newh = INF;
				FORN(i,SZ(neighbor[*it])) {
					int j = neighbor[*it][i];
					if (capacity[*it][j] - flow[*it][j] &gt; (ta)0) MN(newh,h[j]+1);
					}
				h[*it] = newh;
				current[*it] = 0;
				//end of relabel
				}
			else {
				//push
				int j = neighbor[*it][current[*it]];
				if (h[*it] != h[j]+1 || capacity[*it][j] - flow[*it][j] &lt;= (ta)0) {
					current[*it]++;
					continue;
					}
				ta pushthis = min(capacity[*it][j] - flow[*it][j],excess[*it]);
				excess[*it] -= pushthis;
				excess[j] += pushthis;
				flow[*it][j] += pushthis;
				flow[j][*it] -= pushthis;
				}
			}

		if (oldh != h[*it]) {
			//push to front
			li.push_front(*it);
			li.erase(it);
			it = li.begin();
			}
		it++;
		}

	return excess[sink];
	}</Snippet>				</Category>
			</Category>
			<Category Name="MCMF">
				<Snippet Name="MinCostMaxFlowLongLong">// computes the min-cost max-flow of a graph
// also computes the flow in each edges, stored implicitly
class MinCostMaxFlowLongLong {
 public:
  class MinCostMaxFlowEdge {
   private:
	int destination_;
    long long capacity_;
    long long cost_;
    long long flow_;

   public:
    MinCostMaxFlowEdge(int destination, long long capacity, long long cost) {
      this-&gt;destination_ = destination;
      this-&gt;capacity_ = capacity;
      this-&gt;cost_ = cost;
      this-&gt;flow_ = 0L;
    }

    // @Override
    MinCostMaxFlowEdge(MinCostMaxFlowEdge&amp; ref) {
      this-&gt;destination_ = ref.destination();
      this-&gt;capacity_ = ref.capacity();
      this-&gt;cost_ = ref.cost();
      this-&gt;flow_ = ref.flow();
    }

    int destination() {return destination_;}
    long long capacity() {return capacity_;}
    long long cost() {return cost_;}
    long long flow() {return flow_;}
    void setFlow(long long flow) {flow_ = flow;}
  };

  // adjacency list
  vector&lt; vector&lt;MinCostMaxFlowEdge*&gt; &gt; adj_;

  // supply of flow, sinks are positive, taps are negative
  vector&lt;long long&gt; supply_;

  	// constructor
  MinCostMaxFlowLongLong(int node_count) {
    supply_ = vector&lt;long long&gt;(node_count, 0LL);

    adj_ = vector&lt; vector&lt;MinCostMaxFlowEdge*&gt; &gt;(node_count, vector&lt;MinCostMaxFlowEdge*&gt;());
  }

  // adds an edge to this graph
  void addEdge(int from, int to, long long capacity, long long cost) {
    adj_[from].PB(new MinCostMaxFlowEdge(to, capacity, cost));
  }

  void setSupply(int node, long long amount) {
    supply_[node] = amount;
  }

  // Returns the minimum cost flow in the graph
  // If flow is not feasible, returns special value given as input parameter
  // by default it's set to -1
  // kHuge should be filled with a cost and flow so large that it won't be used
  long long solve(long long fail_value, long long kHuge = 1120120123LL) {

    int n = SZ(supply_);

    vector&lt; vector&lt;MinCostMaxFlowEdge*&gt; &gt; adjcopy = adj_;
    for (int i = 0; i &lt; SZ(adj_); ++i) {
    	for (int j = 0; j &lt; SZ(adj_[i]); ++j) {
    		adjcopy[i][j] = new MinCostMaxFlowEdge(*(adj_[i][j]));
    	}
    }

    vector&lt; long long &gt; supplycopy = supply_;

    //add artificial arcs towards node 0
    for (int i = 0; i &lt; n; ++i) {
      if (i &gt; 0) {
        adjcopy[0].PB(new MinCostMaxFlowEdge(i, kHuge, kHuge));
        adjcopy[i].PB(new MinCostMaxFlowEdge(0, kHuge, kHuge));
      }
    }

    // creating reverse adjacencies for the edges
    vector&lt; vector&lt; MinCostMaxFlowEdge* &gt; &gt; reverse_adj(n, vector&lt;MinCostMaxFlowEdge*&gt;());

    for (int i = 0; i &lt; n; ++i) {
      for (int j = 0; j &lt; SZ(adjcopy[i]); ++j) {
      	reverse_adj[i].PB(NULL);
      }
    }

    for (int i = 0; i &lt; n; ++i) {
      for (int j = 0; j &lt; SZ(adjcopy[i]); ++j) {
        if (reverse_adj[i][j] == NULL) {
          int destination = adjcopy[i][j]-&gt;destination();
          long long cost = adjcopy[i][j]-&gt;cost();
          MinCostMaxFlowEdge* new_edge = new MinCostMaxFlowEdge(i, 0, -cost);
          adjcopy[destination].PB(new_edge);
          reverse_adj[destination].PB(adjcopy[i][j]);
          reverse_adj[i][j] = new_edge;
        }
      }
    }

    // pi func
    vector&lt;long long&gt; pi(n, 0LL);

    // reset flows to zero
    for (int i = 0; i &lt; n; ++i) {
      for (int j = 0; j &lt; SZ(adjcopy[i]); ++j) {
        adjcopy[i][j]-&gt;setFlow(0);
      }
    }

    // find maximum amount of flow possible
    long long maximum_flow_at_a_time = -1;
    for (int i = 0; i &lt; n; ++i) {
      maximum_flow_at_a_time = max(maximum_flow_at_a_time,
              supplycopy[i]);

      for (int j = 0; j &lt; SZ(adjcopy[i]); ++j) {
        maximum_flow_at_a_time = max(maximum_flow_at_a_time,
                adjcopy[i][j]-&gt;capacity());
      }

    }

    // find the scaling upper limit
    long long delta = 1LL;
    while (delta &lt; maximum_flow_at_a_time) delta *= 2LL;

    // backtracking stuffs
    vector&lt;int&gt; pred(n, 0), pred_adj(n, 0);
    vector&lt;long long&gt; shortest(n, 0LL);

	typedef pair&lt; long long, int &gt; MaxFlowDijkstraEntity;
	set&lt; MaxFlowDijkstraEntity &gt; pq;

    // main scaling iteration
    while (delta &gt;= 1LL) {
      //saturate all arcs that exceeds delta and of negative cost

      for (int i = 0; i &lt; n; ++i) {
        for (int j = 0; j &lt; SZ(adjcopy[i]); ++j) {
          if (adjcopy[i][j]-&gt;capacity() -
                  adjcopy[i][j]-&gt;flow() &gt;= delta &amp;&amp;
                  adjcopy[i][j]-&gt;cost() - pi[i] +
                  pi[adjcopy[i][j]-&gt;destination()] &lt; 0LL) {
            int destination = adjcopy[i][j]-&gt;destination();
            long long add_flow = adjcopy[i][j]-&gt;capacity() -
                    adjcopy[i][j]-&gt;flow();
            supplycopy[i] -= add_flow;
            supplycopy[destination] += add_flow;
            adjcopy[i][j]-&gt;setFlow(
                    adjcopy[i][j]-&gt;flow() + add_flow);
            reverse_adj[i][j]-&gt;setFlow(
                    reverse_adj[i][j]-&gt;flow() - add_flow);
          }
        }
      }

      for (int i = 0; i &lt; n; ++i) {
        // push extra supply at this node
        while (supplycopy[i] &gt;= delta) {

          // Dijkstra with respect to cost of flow
          for (int j = 0; j &lt; n; ++j) {
            shortest[j] = -1LL; // sentinel value
          }
          shortest[i] = 0LL;

          pred[i] = -1;
          pq.insert(MP(0LL, i));
          while (!pq.empty()) {
            long long top_value = (*(pq.begin())).A;
            int node = (*(pq.begin())).B;
            pq.erase(pq.begin());

            if (shortest[node] &lt; top_value) {
              // deprecated dijkstra branch
              continue;
            }

            for (int j = 0; j &lt; SZ(adjcopy[node]); ++j) {
              if (adjcopy[node][j]-&gt;capacity() -
                      adjcopy[node][j]-&gt;flow() &gt;= delta) {
                int destination = adjcopy[node][j]-&gt;destination();
                long long cost = top_value + adjcopy[node][j]-&gt;cost() -
                        pi[node] + pi[destination];

                if (shortest[destination] == -1LL ||
                        shortest[destination] &gt; cost) {
                  pred[destination] = node;
                  pred_adj[destination] = j;
                  shortest[destination] = cost;
                  pq.insert(MP(cost, destination));
                }
              }
            }
          }

          // find a willing receiver node that's reachable for updating pi
          int def = -1;
          for (int j = 0; j &lt; n; ++j) {
            if (supplycopy[j] &lt; 0LL &amp;&amp;
                    shortest[j] != -1LL) {
              def = j;
              break;
            }
          }
          // update pi value from shortest paths
          for (int j = 0; j &lt; n; ++j) {
            if (shortest[j] != -1LL) {
              pi[j] = pi[j] - shortest[j] + shortest[def];
            }
          }
          supplycopy[def] += delta;
          supplycopy[i] -= delta;
          // backtrack the route and put the flow

          while (pred[def] != -1) {
            int previous = pred[def];
            adjcopy[previous][pred_adj[def]]-&gt;setFlow(
                    adjcopy[previous][pred_adj[def]]-&gt;flow() +
                    delta);
            reverse_adj[previous][pred_adj[def]]-&gt;setFlow(
                    reverse_adj[previous][pred_adj[def]]-&gt;flow() -
                    delta);
            def = previous;
          }
        }
      }

      delta /= 2LL;
    }
    // check feasibility
    bool feasible = true;
    for (int i = 0; i &lt; n; ++i) {
      for (int j = SZ(adj_[i]); j &lt; SZ(adjcopy[i]); ++j) {
        if (adjcopy[i][j]-&gt;flow() &gt; 0LL) {
          feasible = false;
        }
      }
    }

    if (!feasible) {
      return fail_value;
    }

    // compute answer
    long long answer = 0;

    for (int i = 0; i &lt; n; ++i) {
      for (int j = 0; j &lt; SZ(adjcopy[i]); ++j) {
        if (adjcopy[i][j]-&gt;flow() &gt; 0LL) {
          answer += adjcopy[i][j]-&gt;flow() * adjcopy[i][j]-&gt;cost();
        }
      }
    }

    // store the optimal flow in the real adjacency list
    for (int i = 0; i &lt; n; ++i) {
      for (int j = 0; j &lt; SZ(adj_[i]); ++j) {
        adj_[i][j]-&gt;setFlow(adjcopy[i][j]-&gt;flow());
      }
    }

    return answer;
  }
};

/*
MinCostMaxFlowLongLong mcmf(N)
mcmf.addEdge(FROM,TO,CAPACITY,COST)
mcmf.setSupply(NODE, SUPPLY) (negative supply = sink, tap otherwise)
mcmf.solve()
*/</Snippet>				<Snippet Name="mcmf_STRUCT">template &lt;class _c&gt;
//pair&lt; DESTINATION, pair&lt; CAPACITY, COST &gt; &gt;
//positive supply tau la, negative = demand
//O(m^2 log U log n) capacity scaling
//pair &lt; FEASIBLE, pair&lt; JAWAB, FLOWS &gt; &gt;
pair&lt;int, pair&lt; _c, vector&lt; vector&lt; _c &gt; &gt; &gt; &gt; mcmfx ( vector&lt; vector&lt; pair&lt; int, pair&lt; _c, _c &gt; &gt; &gt; &gt; adj, vector&lt; _c &gt; supply ) {

	int nm = SZ(supply);

	vector&lt; vector&lt; pair&lt; int, pair&lt; _c, _c &gt; &gt; &gt; &gt; org = adj;

	//add artificial arcs
	ll angkabesar = 123123123LL;
	FORN(i,nm) if (i) {
		adj[0].PB(MP(i,MP(angkabesar,angkabesar)));
		adj[i].PB(MP(0,MP(angkabesar,angkabesar)));
		}

	vector&lt; vector&lt; pair&lt; int,int &gt; &gt; &gt; radj(nm);

	FORN(i,nm) FORIT(j,adj[i]) radj[i].PB(MP(-1,-1));

	FORN(i,nm) FORN(j,SZ(adj[i])) if (radj[i][j].A == -1) {
		int a = adj[i][j].A; _c c = adj[i][j].B.B;
		adj[a].PB(MP(i,MP(0,-c)));
		radj[a].PB(MP(i,j));
		radj[i][j] = MP(a,SZ(adj[a])-1);
		}

	vector&lt; _c &gt; pi(nm,0);

	vector&lt; vector&lt; _c &gt; &gt; flow(nm);
	FORN(i,nm) FORIT(j,adj[i]) flow[i].PB(0);

	_c maxnum = -1;
	FORN(i,nm) MX(maxnum,supply[i]);
	FORN(i,nm) FORN(j,SZ(adj[i])) MX(maxnum,adj[i][j].B.A);

	_c delta = 1;
	while (delta &lt; maxnum) delta *= (_c)2;

	vector&lt; int &gt; pred(nm), predadj(nm);
	vector&lt; _c &gt; shortest(nm);

	typedef pair&lt; _c, int &gt; pci;
	priority_queue&lt; pci, vector&lt; pci &gt;, greater&lt; pci &gt; &gt; pq;

	while (delta) {

		//saturate all arc that does not satisfy the u-kno-what constraint
		FORN(i,nm) FORN(j,SZ(adj[i])) if (adj[i][j].B.A - flow[i][j] &gt;= delta &amp;&amp; adj[i][j].B.B - pi[i] + pi[adj[i][j].A] &lt; 0) {
			int k = adj[i][j].A;
			int addflow = adj[i][j].B.A - flow[i][j];
			supply[i] -= addflow;
			supply[k] += addflow;
			flow[i][j] += addflow;
			flow[k][radj[i][j].B] -= addflow;
			}

		FORN(i,nm) while (supply[i] &gt;= delta) {

			FORN(j,nm) shortest[j] = -1;
			shortest[i] = 0;
			pred[i] = -1;
			pq.push(MP(0,i));
			while (!pq.empty()) {
				_c a = pq.top().A; int b = pq.top().B;
				pq.pop();

				if (shortest[b] &lt; a) continue;
				FORN(j,SZ(adj[b])) if (adj[b][j].B.A - flow[b][j] &gt;= delta) {
					int d = adj[b][j].A;
					_c c = a + adj[b][j].B.B - pi[b] + pi[d];
					if (shortest[d] == (_c)-1 || shortest[d] &gt; c) {
						pred[d] = b;
						predadj[d] = j;
						shortest[d] = c;
						pq.push(MP(c,d));
						}
					}
				}
			int def = -1;
			FORN(j,nm) if (supply[j] &lt; (_c)0 &amp;&amp; shortest[j] != (_c)-1) {
				def = j;
				break;
				}

			FORN(j,nm) if (shortest[j] != (_c)-1) pi[j] = pi[j] - shortest[j] + shortest[def];

			supply[def] += delta;
			supply[i] -= delta;

			while (pred[def] != -1) {

				int dul = pred[def];
				flow[dul][predadj[def]] += delta;
				flow[def][radj[dul][predadj[def]].B] -= delta;
				def = dul;
				}

			}

		delta /= (_c)2;
		}

	//cek feasibility
	int feas = 1;
	FORN(i,nm) REP(j,SZ(org[i]),SZ(adj[i])) if (flow[i][j] &gt; (_c)0) feas = 0;

	_c answer = 0;
	FORN(i,nm) FORN(j,SZ(adj[i])) if (flow[i][j] &gt; (_c)0) answer += flow[i][j] * adj[i][j].B.B;

	vector&lt; vector&lt; _c &gt; &gt; retflow(nm);
	FORN(i,nm) FORN(j,SZ(org[i])) retflow[i].PB(flow[i][j]);

	return MP(feas,MP(answer,retflow));

	}


template &lt;class _c&gt;
struct mcf {

	vector&lt; vector&lt; pair&lt; int, pair&lt; _c, _c &gt; &gt; &gt; &gt; adj;
	vector&lt; _c &gt; sup;
	vector&lt; vector&lt; _c &gt; &gt; flow;
	int feasible;
	_c mincost;
	int solved;

	mcf(int nm) {
		sup = vector&lt; _c &gt;(nm,0);
		adj = vector&lt; vector&lt; pair&lt; int, pair&lt; _c, _c &gt; &gt; &gt; &gt;(nm);
		feasible = mincost = solved = 0;
		}

	void addedge(int from,int to,_c capacity,_c cost) {
		adj[from].PB(MP(to,MP(capacity,cost)));
		solved=0;
		}

	void solve(void) {
		pair&lt; int, pair&lt; _c, vector&lt; vector&lt; _c &gt; &gt; &gt; &gt; coba = mcmfx(adj,sup);
		feasible = coba.A;
		flow = coba.B.B;
		mincost = coba.B.A;
		solved = 1;
		}

	_c mcmf(void) {
		solve();
		return mincost;
		}

	};
	/*
mcf&lt;int&gt; a(N)
a.ADDEDGE(FROM,TO,CAPACITY,COST)
a.MCMF()
*/</Snippet>				<Snippet Name="extendedmcmf_S">//Adjacency List Network Flow INTEGER BASED NON EPSILON
//O(V^3 + VE)
//memory 2 * V^2
template &lt;class ta&gt;
ta netFlow (vector&lt; vector&lt; pair&lt;int, ta&gt; &gt; &gt; nfadj, int tap, int sink) {
	int nnf = SZ(nfadj);
	vector&lt; vint &gt; neighbor;
	vint current;
	vint h;
	vector&lt; ta &gt; excess;

	list &lt;int&gt; li;

	FORN(i,nnf) {
		current.PB(0);
		excess.PB( (ta) 0);
		vint tempneighbor;
		neighbor.PB(tempneighbor);
		h.PB(0);
		if (i != sink &amp;&amp; i != tap) li.PB(i);
		}

	h[tap] = nnf;
	vector&lt; vector&lt; ta &gt; &gt; capacity(nnf,vint(nnf,(ta)0));
	vector&lt; vector&lt; ta &gt; &gt; flow(nnf,vint(nnf,(ta)0));

	FORN(i,nnf) {
		FORN(j,SZ(nfadj[i])) {
			neighbor[i].PB(nfadj[i][j].A);
			neighbor[nfadj[i][j].A].PB(i);
			capacity[i][nfadj[i][j].A] += nfadj[i][j].B;
			}
		}

	FORN(i,nnf) {
		sort(ALL(neighbor[i]));
		neighbor[i].erase(unique(ALL(neighbor[i])),neighbor[i].end());

		}

	FORN(i,SZ(nfadj[tap])) {
		flow[tap][nfadj[tap][i].A] += nfadj[tap][i].B;
		flow[nfadj[tap][i].A][tap] -= nfadj[tap][i].B;
		excess[nfadj[tap][i].A] += nfadj[tap][i].B;
		}

	list&lt;int&gt;::iterator it;
	it = li.begin();
	while (it != li.end()) {
		int oldh = h[*it];
		while (excess[*it] &gt; (ta)0) {
			if (current[*it] == SZ(neighbor[*it])) {
				//relabel
				int newh = INF;
				FORN(i,SZ(neighbor[*it])) {
					int j = neighbor[*it][i];
					if (capacity[*it][j] - flow[*it][j] &gt; (ta)0) MN(newh,h[j]+1);
					}
				h[*it] = newh;
				current[*it] = 0;
				//end of relabel
				}
			else {
				//push
				int j = neighbor[*it][current[*it]];
				if (h[*it] != h[j]+1 || capacity[*it][j] - flow[*it][j] &lt;= (ta)0) {
					current[*it]++;
					continue;
					}
				ta pushthis = min(capacity[*it][j] - flow[*it][j],excess[*it]);
				excess[*it] -= pushthis;
				excess[j] += pushthis;
				flow[*it][j] += pushthis;
				flow[j][*it] -= pushthis;
				}
			}

		if (oldh != h[*it]) {
			//push to front
			li.push_front(*it);
			li.erase(it);
			it = li.begin();
			}
		it++;
		}

	return excess[sink];
	}



template &lt;class _c&gt;
//pair&lt; DESTINATION, pair&lt; CAPACITY, COST &gt; &gt;
//positive supply tau la, negative = demand
//O(m^2 log U log n) capacity scaling
//pair &lt; FEASIBLE, pair&lt; JAWAB, FLOWS &gt; &gt;
pair&lt;int, pair&lt; _c, vector&lt; vector&lt; _c &gt; &gt; &gt; &gt; mcmfx ( vector&lt; vector&lt; pair&lt; int, pair&lt; _c, _c &gt; &gt; &gt; &gt; adj, vector&lt; _c &gt; supply ) {

	int nm = SZ(supply);

	vector&lt; vector&lt; pair&lt; int, pair&lt; _c, _c &gt; &gt; &gt; &gt; org = adj;

	//add artificial arcs
	ll angkabesar = 123123123LL;
	FORN(i,nm) if (i) {
		adj[0].PB(MP(i,MP(angkabesar,angkabesar)));
		adj[i].PB(MP(0,MP(angkabesar,angkabesar)));
		}

	vector&lt; vector&lt; pair&lt; int,int &gt; &gt; &gt; radj(nm);

	FORN(i,nm) FORIT(j,adj[i]) radj[i].PB(MP(-1,-1));

	FORN(i,nm) FORN(j,SZ(adj[i])) if (radj[i][j].A == -1) {
		int a = adj[i][j].A; _c c = adj[i][j].B.B;
		adj[a].PB(MP(i,MP(0,-c)));
		radj[a].PB(MP(i,j));
		radj[i][j] = MP(a,SZ(adj[a])-1);
		}

	vector&lt; _c &gt; pi(nm,0);

	vector&lt; vector&lt; _c &gt; &gt; flow(nm);
	FORN(i,nm) FORIT(j,adj[i]) flow[i].PB(0);

	_c maxnum = -1;
	FORN(i,nm) MX(maxnum,supply[i]);
	FORN(i,nm) FORN(j,SZ(adj[i])) MX(maxnum,adj[i][j].B.A);

	_c delta = 1;
	while (delta &lt; maxnum) delta *= (_c)2;

	vector&lt; int &gt; pred(nm), predadj(nm);
	vector&lt; _c &gt; shortest(nm);

	typedef pair&lt; _c, int &gt; pci;
	priority_queue&lt; pci, vector&lt; pci &gt;, greater&lt; pci &gt; &gt; pq;

	while (delta) {

		//saturate all arc that does not satisfy the u-kno-what constraint
		FORN(i,nm) FORN(j,SZ(adj[i])) if (adj[i][j].B.A - flow[i][j] &gt;= delta &amp;&amp; adj[i][j].B.B - pi[i] + pi[adj[i][j].A] &lt; 0) {
			int k = adj[i][j].A;
			int addflow = adj[i][j].B.A - flow[i][j];
			supply[i] -= addflow;
			supply[k] += addflow;
			flow[i][j] += addflow;
			flow[k][radj[i][j].B] -= addflow;
			}

		FORN(i,nm) while (supply[i] &gt;= delta) {

			FORN(j,nm) shortest[j] = -1;
			shortest[i] = 0;
			pred[i] = -1;
			pq.push(MP(0,i));
			while (!pq.empty()) {
				_c a = pq.top().A; int b = pq.top().B;
				pq.pop();

				if (shortest[b] &lt; a) continue;
				FORN(j,SZ(adj[b])) if (adj[b][j].B.A - flow[b][j] &gt;= delta) {
					int d = adj[b][j].A;
					_c c = a + adj[b][j].B.B - pi[b] + pi[d];
					if (shortest[d] == (_c)-1 || shortest[d] &gt; c) {
						pred[d] = b;
						predadj[d] = j;
						shortest[d] = c;
						pq.push(MP(c,d));
						}
					}
				}
			int def = -1;
			FORN(j,nm) if (supply[j] &lt; (_c)0 &amp;&amp; shortest[j] != (_c)-1) {
				def = j;
				break;
				}

			FORN(j,nm) if (shortest[j] != (_c)-1) pi[j] = pi[j] - shortest[j] + shortest[def];

			supply[def] += delta;
			supply[i] -= delta;

			while (pred[def] != -1) {

				int dul = pred[def];
				flow[dul][predadj[def]] += delta;
				flow[def][radj[dul][predadj[def]].B] -= delta;
				def = dul;
				}

			}

		delta /= (_c)2;
		}

	//cek feasibility
	int feas = 1;
	FORN(i,nm) REP(j,SZ(org[i]),SZ(adj[i])) if (flow[i][j] &gt; (_c)0) feas = 0;

	_c answer = 0;
	FORN(i,nm) FORN(j,SZ(adj[i])) if (flow[i][j] &gt; (_c)0) answer += flow[i][j] * adj[i][j].B.B;

	vector&lt; vector&lt; _c &gt; &gt; retflow(nm);
	FORN(i,nm) FORN(j,SZ(org[i])) retflow[i].PB(flow[i][j]);

	return MP(feas,MP(answer,retflow));

	}


template &lt;class _c&gt;
struct mcf {

	vector&lt; vector&lt; pair&lt; int, pair&lt; _c, _c &gt; &gt; &gt; &gt; adj;
	vector&lt; _c &gt; sup;
	vector&lt; vector&lt; _c &gt; &gt; flow;
	int feasible;
	_c mincost;
	int solved;

	mcf(int nm) {
		sup = vector&lt; _c &gt;(nm,0);
		adj = vector&lt; vector&lt; pair&lt; int, pair&lt; _c, _c &gt; &gt; &gt; &gt;(nm);
		feasible = mincost = solved = 0;
		}

	void addedge(int from,int to,_c capacity,_c cost) {
		adj[from].PB(MP(to,MP(capacity,cost)));
		solved=0;
		}

	_c mf(int tap, int sink) {
		vector&lt; vector&lt; pair&lt;int, _c &gt; &gt; &gt; nfadj(SZ(sup));
		FORN(i,SZ(adj)) FORN(j,SZ(adj[i])) nfadj[i].PB(MP(adj[i][j].A,adj[i][j].B.A));
		return netFlow(nfadj,tap,sink);
		}

	void solve(void) {
		pair&lt; int, pair&lt; _c, vector&lt; vector&lt; _c &gt; &gt; &gt; &gt; coba = mcmfx(adj,sup);
		feasible = coba.A;
		flow = coba.B.B;
		mincost = coba.B.A;
		solved = 1;
		}

	_c mcmf(void) {
		solve();
		return mincost;
		}

	};

/*
mcf&lt;int&gt; a(N)
a.ADDEDGE(FROM,TO,CAPACITY,COST)
a.MF(TAP,SINK)
a.MCMF()
*/</Snippet>				<Category Name="LEGACY">
					<Snippet Name="mincostmaxflow">template &lt;class _c&gt;
//pair&lt; DESTINATION, pair&lt; CAPACITY, COST &gt; &gt;
//positive supply tau la, negative = demand
//O(m^2 log U log n) capacity scaling
_c mcmf ( vector&lt; vector&lt; pair&lt; int, pair&lt; _c, _c &gt; &gt; &gt; &gt; adj, vector&lt; _c &gt; supply ) {

	int nm = SZ(supply);

	//add artificial arcs
	ll angkabesar = 123123123LL;
	FORN(i,nm) if (i) {
		adj[0].PB(MP(i,MP(angkabesar,angkabesar)));
		adj[i].PB(MP(0,MP(angkabesar,angkabesar)));
		}

	vector&lt; vector&lt; pair&lt; int,int &gt; &gt; &gt; radj(nm);

	FORN(i,nm) FORIT(j,adj[i]) radj[i].PB(MP(-1,-1));

	FORN(i,nm) FORN(j,SZ(adj[i])) if (radj[i][j].A == -1) {
		int a = adj[i][j].A; _c c = adj[i][j].B.B;
		adj[a].PB(MP(i,MP(0,-c)));
		//flow[a].PB(0);
		radj[a].PB(MP(i,j));
		radj[i][j] = MP(a,SZ(adj[a])-1);
		}

	vector&lt; _c &gt; pi(nm,0);

	vector&lt; vector&lt; _c &gt; &gt; flow(nm);
	FORN(i,nm) FORIT(j,adj[i]) flow[i].PB(0);

	_c maxnum = -1;
	FORN(i,nm) MX(maxnum,supply[i]);
	FORN(i,nm) FORN(j,SZ(adj[i])) MX(maxnum,adj[i][j].B.A);

	_c delta = 1;
	while (delta &lt; maxnum) delta *= (_c)2;

	vector&lt; int &gt; pred(nm), predadj(nm);
	vector&lt; _c &gt; shortest(nm);

	typedef pair&lt; _c, int &gt; pci;
	priority_queue&lt; pci, vector&lt; pci &gt;, greater&lt; pci &gt; &gt; pq;

	while (delta) {

		//saturate all arc that does not satisfy the u-kno-what constraint
		FORN(i,nm) FORN(j,SZ(adj[i])) if (adj[i][j].B.A - flow[i][j] &gt;= delta &amp;&amp; adj[i][j].B.B - pi[i] + pi[adj[i][j].A] &lt; 0) {
			int k = adj[i][j].A;
			int addflow = adj[i][j].B.A - flow[i][j];
			supply[i] -= addflow;
			supply[k] += addflow;
			flow[i][j] += addflow;
			flow[k][radj[i][j].B] -= addflow;
			}

		FORN(i,nm) while (supply[i] &gt;= delta) {

			FORN(j,nm) shortest[j] = -1;
			shortest[i] = 0;
			pred[i] = -1;
			pq.push(MP(0,i));
			while (!pq.empty()) {
				_c a = pq.top().A; int b = pq.top().B;
				pq.pop();

				if (shortest[b] &lt; a) continue;
				FORN(j,SZ(adj[b])) if (adj[b][j].B.A - flow[b][j] &gt;= delta) {
					int d = adj[b][j].A;
					_c c = a + adj[b][j].B.B - pi[b] + pi[d];
					if (shortest[d] == (_c)-1 || shortest[d] &gt; c) {
						pred[d] = b;
						predadj[d] = j;
						shortest[d] = c;
						pq.push(MP(c,d));
						}
					}
				}
			int def = -1;
			FORN(j,nm) if (supply[j] &lt; (_c)0 &amp;&amp; shortest[j] != (_c)-1) {
				def = j;
				break;
				}

			FORN(j,nm) if (shortest[j] != (_c)-1) pi[j] = pi[j] - shortest[j] + shortest[def];

			supply[def] += delta;
			supply[i] -= delta;

			while (pred[def] != -1) {

				int dul = pred[def];
				flow[dul][predadj[def]] += delta;
				flow[def][radj[dul][predadj[def]].B] -= delta;
				def = dul;
				}

			}

		delta /= (_c)2;
		}

	_c answer = 0;
	FORN(i,nm) FORN(j,SZ(adj[i])) if (flow[i][j] &gt; (_c)0) answer += flow[i][j] * adj[i][j].B.B;
	return answer;
	}</Snippet>				</Category>
				<Snippet Name="SuccessiveShortestPath">// computes the min-cost max-flow of a graph
// also computes the flow in each edges, stored implicitly
class SuccessiveShortestPath {
 public:
  class MinCostMaxFlowEdge {
   public:   
    MinCostMaxFlowEdge(int destination, long long capacity, long long cost) {
      this-&gt;destination_ = destination;
      this-&gt;capacity_ = capacity;
      this-&gt;cost_ = cost;
      this-&gt;flow_ = 0L;
    }

    // @Override
    MinCostMaxFlowEdge(MinCostMaxFlowEdge&amp; ref) {
      this-&gt;destination_ = ref.destination_;
      this-&gt;capacity_ = ref.capacity_;
      this-&gt;cost_ = ref.cost_;
      this-&gt;flow_ = ref.flow_;
    }
    
    int destination_;
    long long capacity_;
    long long cost_;
    long long flow_;
  };

  // adjacency list
  vector&lt; vector&lt;MinCostMaxFlowEdge*&gt; &gt; adj_;

  // supply of flow: sinks are positive, taps are negative
  vector&lt;long long&gt; supply_;
  
  // constructor
  SuccessiveShortestPath(int node_count) {
    supply_ = vector&lt;long long&gt;(node_count, 0LL);

    adj_ = vector&lt; vector&lt;MinCostMaxFlowEdge*&gt; &gt;(node_count, vector&lt;MinCostMaxFlowEdge*&gt;());
  }

  // adds an edge to this graph
  void addEdge(int from, int to, long long capacity, long long cost) {
    adj_[from].PB(new MinCostMaxFlowEdge(to, capacity, cost));
  }

  // supply of flow: sinks are positive, taps are negative
  void setSupply(int node, long long amount) {
    supply_[node] = amount;
  }

  // Returns the minimum cost flow in the graph.
  // Flags whether the flow is feasible or not.
  long long solve(int* is_infeasible) {
    *is_infeasible = 0;
    int n = SZ(supply_);

    vector&lt; vector&lt;MinCostMaxFlowEdge*&gt; &gt; adjcopy = adj_;
    for (int i = 0; i &lt; SZ(adj_); ++i) {
    	for (int j = 0; j &lt; SZ(adj_[i]); ++j) {
    		adjcopy[i][j] = new MinCostMaxFlowEdge(*(adj_[i][j]));
    	}
    }
    
    // creating reverse adjacencies for the edges
    vector&lt; vector&lt; MinCostMaxFlowEdge* &gt; &gt; reverse_adj(n, vector&lt;MinCostMaxFlowEdge*&gt;());
    for (int i = 0; i &lt; n; ++i) {
      for (int j = 0; j &lt; SZ(adjcopy[i]); ++j) {
      	reverse_adj[i].PB(NULL);
      }
    }
    
    vector&lt;ll&gt; supply_cpy = supply_;
    
    for (int i = 0; i &lt; n; ++i) {
      int sigma = SZ(adjcopy[i]);
      for (int j = 0; j &lt; sigma; ++j) {
        if (reverse_adj[i][j] == NULL) {
          int destination = adjcopy[i][j]-&gt;destination_;
          long long cost = adjcopy[i][j]-&gt;cost_;
          MinCostMaxFlowEdge* new_edge = new MinCostMaxFlowEdge(i, 0, -cost);
          adjcopy[destination].PB(new_edge);
          reverse_adj[destination].PB(adjcopy[i][j]);
          reverse_adj[i][j] = new_edge;
          
          if (cost &lt; 0LL) {
            // Augment
            adjcopy[i][j]-&gt;flow_ = adjcopy[i][j]-&gt;capacity_;
            reverse_adj[i][j]-&gt;flow_ = -adjcopy[i][j]-&gt;capacity_;
            supply_cpy[i] -= adjcopy[i][j]-&gt;capacity_;
            supply_cpy[adjcopy[i][j]-&gt;destination_] += adjcopy[i][j]-&gt;capacity_;
          }
        }
      }
    }
    
    // Augments two additional nodes: tap and sink
    int tap = n;
    int sink = n+1;
    adjcopy.PB(vector&lt;MinCostMaxFlowEdge*&gt;());
    adjcopy.PB(vector&lt;MinCostMaxFlowEdge*&gt;());
    reverse_adj.PB(vector&lt;MinCostMaxFlowEdge*&gt;());
    reverse_adj.PB(vector&lt;MinCostMaxFlowEdge*&gt;());
    
    // Add paths
    long long flow_snd = 0LL;
    long long flow_rcv = 0LL;
    for (int i = 0; i &lt; n; ++i) {
      if (supply_cpy[i] &gt; 0LL) {
        flow_snd += supply_cpy[i];
        MinCostMaxFlowEdge* fwd = new MinCostMaxFlowEdge(i, supply_cpy[i], 0LL);
        MinCostMaxFlowEdge* bck = new MinCostMaxFlowEdge(tap, 0, 0LL);
        adjcopy[tap].PB(fwd);
        reverse_adj[tap].PB(bck);
        
        adjcopy[i].PB(bck);
        reverse_adj[i].PB(fwd);
      } else if (supply_cpy[i] &lt; 0LL) {
        flow_rcv += -supply_cpy[i];
        MinCostMaxFlowEdge* fwd = new MinCostMaxFlowEdge(sink, -supply_cpy[i], 0LL);
        MinCostMaxFlowEdge* bck = new MinCostMaxFlowEdge(i, 0, 0LL);
        adjcopy[i].PB(fwd);
        reverse_adj[i].PB(bck);
        
        adjcopy[sink].PB(bck);
        reverse_adj[sink].PB(fwd);
      }
    }
    
    if (flow_snd != flow_rcv) {
      *is_infeasible = 1;
      return -13LL;
    }
    
    // pi func
    vector&lt;long long&gt; pi(n+2, 0LL);

    // backtracking stuffs
    vector&lt;int&gt; pred(n+2, 0), pred_adj(n+2, 0);
    vector&lt;long long&gt; shortest(n+2, 0LL);

    typedef pair&lt; long long, int &gt; MaxFlowDijkstraEntity;
    set&lt; MaxFlowDijkstraEntity &gt; pq;
    
    long long total_flow = 0LL;
    // Iterate Dijkstra
    while (true) {
      pq.insert(MP(0LL, tap));
      
      for (int i = 0; i &lt; n+2; ++i) {
        shortest[i] = -1LL;
      }
      
      shortest[tap] = 0LL;
      
      // Dijk
      while (!pq.empty()) {
        ll dist = pq.begin()-&gt;A;
        int node = pq.begin()-&gt;B;
        pq.erase(pq.begin());
        
        if (shortest[node] != dist) continue;  // Deprecated branch
        
        for (int i = 0; i &lt; SZ(adjcopy[node]); ++i) {
          MinCostMaxFlowEdge* ed = adjcopy[node][i];
          if (ed-&gt;capacity_ - ed-&gt;flow_ &lt;= 0LL) {
            continue;
          }
          int dest = ed-&gt;destination_;
          ll new_dist = dist + ed-&gt;cost_ - pi[node] + pi[dest];
          assert(new_dist &gt;= dist);
          
          if (shortest[dest] == -1LL || shortest[dest] &gt; new_dist) {
            shortest[dest] = new_dist;
            pq.insert(MP(new_dist, dest));
            pred[dest] = node;
            pred_adj[dest] = i;
          }
        }
      }

      if (shortest[sink] == -1LL) {
        break;
      }
      
      // Update pi value for shortest path
      for (int j = 0; j &lt; n+2; ++j) {
        if (shortest[j] != -1LL) {
          pi[j] = pi[j] - shortest[j];
        }
      }
      
      // Retrieve the amount of flow possible
      vector&lt;int&gt; nodes;
      vector&lt;int&gt; go_next;
      
      nodes.PB(sink);
      go_next.PB(-1);
      
      while (nodes.back() != tap) {
        go_next.PB(pred_adj[nodes.back()]);
        nodes.PB(pred[nodes.back()]);
      }
      
      reverse(ALL(nodes));
      reverse(ALL(go_next));
      
      long long flow = flow_snd;
      FORN(i, SZ(nodes)-1) MN(flow, adjcopy[nodes[i]][go_next[i]]-&gt;capacity_ -
          adjcopy[nodes[i]][go_next[i]]-&gt;flow_);
      
      total_flow += flow;
      
      FORN(i, SZ(nodes)-1) {
        adjcopy[nodes[i]][go_next[i]]-&gt;flow_ += flow;
        reverse_adj[nodes[i]][go_next[i]]-&gt;flow_ -= flow;
      }
    }
    
    if (total_flow != flow_snd) {
      *is_infeasible = 1;
      return 0LL;
    }

    // store the optimal flow in the real adjacency list and compute
    // answer
    long long answer = 0LL;
    for (int i = 0; i &lt; n; ++i) {
      for (int j = 0; j &lt; SZ(adj_[i]); ++j) {
        adj_[i][j]-&gt;flow_ = adjcopy[i][j]-&gt;flow_;
        answer += adj_[i][j]-&gt;flow_ * adj_[i][j]-&gt;cost_;
      }
    }

    return answer;
  }
};

/*
SuccessiveShortestPath mcmf(N)
mcmf.addEdge(FROM,TO,CAPACITY,COST)
mcmf.setSupply(NODE, SUPPLY) (negative supply = sink, tap otherwise)
mcmf.solve(&amp;is_infeasible)
*/</Snippet>			</Category>
			<Category Name="BIPARTITEMATCHING">
				<Snippet Name="MaximumMatching">class MaximumMatching {
 public:
  MaximumMatching(int p, int h) {
    p_ = p;
    h_ = h;

    g_ = new int*[p];
    FORN(i, p_) g_[i] = new int[h];

    FORN(i, p) FORN(j, h) g_[i][j] = 0;
    s_ = new int[h];
    pl_ = new int[p];
    pr_ = new int[h];
  }
  
  ~MaximumMatching() {
    FORN(i, p_) {
      delete[] g_[i];
    }
    delete[] g_;
    delete[] s_;
    delete[] pl_;
    delete[] pr_;
  }
  
  void AddEdge(int p, int h) {
    g_[p][h] = 1;
  }
  
  int** g_;  // adjacency MATRIX
  int p_;  // number of pidgeys
  int h_;  // number of holes
  int* s_;  // has been seen?
  int* pl_;  // pigeon to which hole
  int* pr_;  // hole used by which pigeon

  int Dfs(int u) {
    FORN(v, h_) if (g_[u][v]) {
      if (pr_[v] &lt; 0) {
        pl_[u] = v;
        pr_[v] = u;
        return 1;
      }
    }
    
    FORN(v, h_) if (g_[u][v]) {
      if (s_[v]) continue;
      s_[v] = 1;
      if (Dfs(pr_[v])) {
        pl_[u] = v;
        pr_[v] = u;
        return 1;
      }
    }
    return 0;
  }
  
  //n jml pigeon, m jml hole, return jml pigeon yg happy
  int Solve() {
    FORN(i, p_) pl_[i] = -1;
    FORN(i, h_) pr_[i] = -1;
    int cnt = 0;
    FORN(i, p_) {
      FORN(j, h_) s_[j] = 0;
      cnt += Dfs(i);
    }
    return cnt;
  }
};</Snippet>				<Snippet Name="bipartite">/*
#define M 128
#define N 128

//graph[M][N] true bila dari pigeon[M] bisa ke hole [N]
int graph[M][N];
int seen[N];
int pasangleft[M], pasangright[N]; //pasangleft = burung ke-i di hole mana? //pasangright = hole apa dipake burung mana
int n, m;

int bpm( int u, int n )
{
    for( int v = 0; v &lt; n; v++ ) if( graph[u][v] )
    {
        if( seen[v] ) continue;
        seen[v] = 1;

        if( pasangright[v] &lt; 0 || bpm( pasangright[v],n ) )
        {
            pasangleft[u] = v;
            pasangright[v] = u;
            return 1;
        }
    }
    return 0;
}
//n jml pigeon, m jml hole, return jml pigeon yg happy
int bipartite(int levantinegraph[M][N],int n, int m) {
	FORN(i,M) FORN(j,N) graph[i][j] = levantinegraph[i][j];
	memset( pasangleft, -1, sizeof( pasangleft ) );
    memset( pasangright, -1, sizeof( pasangright ) );
    int cnt = 0;
    for( int i = 0; i &lt; m; i++ )
    {
        memset( seen, 0, sizeof( seen ) );
        if( bpm( i,n ) ) cnt++;
    }
	return cnt;
	}</Snippet>			</Category>
			<Category Name="MAXIMUM_FLOW">
			</Category>
		</Category>
		<Category Name="RARE">
			<Snippet Name="isgraphpossible">//return true if a graph with connectivity like this possible
	int isgraphpossible(vint neighbors) {
	FORN(i,n) {
		//coba abisin neighbor ke i
		sort(ALL(neighbors));
		reverse(ALL(neighbors));
		REP(j,1,SZ(neighbors)) if (neighbors[j] &amp;&amp; neighbors[0]) {
			neighbors[0]--;
			neighbors[j]--;
			}
		if (neighbors[0]) return 0;
		}
	return 1;
	}</Snippet>			<Snippet Name="biconnectedcomponents">//n = vertex, edges[2*i] dan edges[2*i+1] adjacent. return SZ(bicedges)/2 elements, i-th element = bicon part of the i-th edge
vint biconnectedcomponents (int n, vector&lt;int&gt; edges) {

	//create adjacency list
	vector&lt; vector&lt; pair&lt;int,int&gt; &gt; &gt; adj(n,vector&lt; pair&lt;int,int&gt; &gt;());//connect to, edge code

	vector&lt; pair&lt;int,int&gt; &gt; crossadj;

	FORN(i,SZ(edges)) {
		int a = edges[i];
		int b = edges[i+1];
		int code = i/2;
		i++;
		adj[a].PB(MP(b,code));
		adj[b].PB(MP(a,code));
		crossadj.PB(MP(a,b));
		}
	//end

	vint nextvisit(n,-1);
	vint from(n,-1);
	stack&lt;int&gt; s,se;
	vint low(n,-1);
	vint depth(n,-1);
	vint fromid(n,-1);
	int numedge = SZ(edges) / 2;
	vint ret(numedge,-1);
	int cnt=0;

	vint discovered(numedge,0);

	FORN(i,n) if (nextvisit[i] == -1) {
		s.push(i);
		nextvisit[i] = 0;
		depth[i] = 0;
		while (!s.empty()) {
			int a = s.top();
			s.pop();
			if (nextvisit[a] == SZ(adj[a])) {
				//compute low bica
				low[a] = depth[a];
				FORN(j,SZ(adj[a])) {
					int b = adj[a][j].A;
					if (from[a] == b) continue;
					MN(low[a],depth[b]);
					if (depth[b] &gt; depth[a]) {
						MN(low[a],low[b]);
						}
					}

				//articulation?
				if (from[a] == i || low[a] &gt;= depth[from[a]]) {
					while (se.top() != fromid[a]) {
						ret[se.top()] = cnt;
						se.pop();
						}
					ret[se.top()] = cnt;
					se.pop();
					cnt++;
					}

				continue;
				}

			s.push(a);
			int visit = adj[a][nextvisit[a]].A;
			int id = adj[a][nextvisit[a]].B;
			nextvisit[a]++;

			if (!discovered[id]) {
				discovered[id] = 1;
				se.push(id);
				}

			if (depth[visit] != -1) continue;

			depth[visit] = depth[a]+1;
			from[visit] = a;
			fromid[visit] = id;
			nextvisit[visit] = 0;
			s.push(visit);
			}
		}

	return ret;
	}</Snippet>			<Snippet Name="GraphColoring">class GraphColoring {
  public:
  	explicit GraphColoring(int number_of_nodes) : adj_(number_of_nodes) {}
  	void AddEdge(int from, int to) {
  		adj_[from].PB(to);
  		adj_[to].PB(from);
  	}

  	//return minimum number of colors to color the graph, -1 if impossible.
  	int MinimumColor() {
  		int nnodes = SZ(adj_);
  		vint dp(1 &lt;&lt; nnodes, INF);
  		vint used(1 &lt;&lt; nnodes, -1);
  		queue&lt;int&gt; q;
  		vint isindependent(1 &lt;&lt; nnodes,1);
  		FORN(mask,1 &lt;&lt; nnodes) {
  			FORN(j,nnodes) if (mask &amp; (1 &lt;&lt; j)) FORIT(k, adj_[j]) if (mask &amp; (1 &lt;&lt; (*k))) if (*k != j) isindependent[mask] = 0;
  		}
  		q.push(0);
  		dp[0] = 0;
  		while (!q.empty()) {
  			int mask = q.front();
  			q.pop();
  			if (mask == (1 &lt;&lt; nnodes)-1) {
  				colors = vint(nnodes);
  				int curnode = mask;
  				int cnt = dp[mask]-1;
  				while (used[curnode] != -1) {
  					FORN(j, nnodes) if (j &amp; used[curnode]) colors[j] = cnt;
  					--cnt;
  					curnode -= used[curnode];
  				}
  				return dp[mask];
  			}
  			for(int i = (1 &lt;&lt; nnodes)-1; i &gt;=  1; --i) if (isindependent[i] &amp;&amp; i + mask == (i | mask) &amp;&amp; dp[i | mask] &gt; dp[mask] + 1) {
  				dp[i | mask] = dp[mask] + 1;
  				used[i | mask] = i;
  				q.push(i | mask);
  			}
  		}
  		DEBUG(&quot;error&quot;);
  		return -100;
  	}
  	vint GetColors() {
  		MinimumColor();
  		return colors;
  	}
  private:
  	vint colors;
	vector&lt; vint &gt; adj_;
};

//O(4^N)
//GraphColoring gc(jumlah_node);
//ts.AddEdge(0,5);
//int jumlah_color_minimum = gc.MinimumColor();
//vint warna_lexicographically_minimum = gc.GetColors();</Snippet>		</Category>
		<Snippet Name="cycledmerge">
int fp(int abc, int parent[]) {
	if (parent[abc] == abc) return abc;
	int def = fp(parent[abc],parent);
	parent[abc] = def;
	return def;
	}

//hub adjacency list
//n : jumlah node
//parent : ntar jadi siapa parentnya siapa tea yg link
void cycledmerge(vector&lt;int&gt; hub[],int n,int parent[]) {
	stack&lt;int&gt; urutan;
	for (int i = 0;i &lt; n;i++) parent[i] = i;
	stack&lt; pair&lt;int,int&gt; &gt; ngurut;
	vector&lt;int&gt; sudah(n,0);
	vector&lt;int&gt; adadiurutan(n,0);
	for (int i = 0;i &lt; n;i++) {
		if (sudah[i]) continue;
		urutan.push(i);
		ngurut.push(make_pair(i,0));
		adadiurutan[i] = 1;
		sudah[i] = 1;
		while (!ngurut.empty()) {
			int id = ngurut.top().first;
			int val = ngurut.top().second;
			ngurut.pop();
			if (val == hub[id].size()) {
				while (!urutan.empty() &amp;&amp; urutan.top() == id) urutan.pop();
				adadiurutan[id] = 0;
				continue;
				}
			ngurut.push(make_pair(id,val + 1));
			int next = hub[id][val];
			if (sudah[next] &amp;&amp; !adadiurutan[fp(next,parent)]) continue;
			if (!sudah[next]) {
				sudah[next] = 1;
				urutan.push(next);
				ngurut.push(make_pair(next,0));
				adadiurutan[next] = 1;
				continue;
				}
			if (parent[fp(id,parent)] == fp(next,parent)) continue;
			parent[fp(id,parent)] = fp(next,parent);
			while (!urutan.empty() &amp;&amp; urutan.top() != fp(next,parent)) {
				parent[fp(urutan.top(),parent)] = fp(next,parent);
				urutan.pop();
				}
			}
		}
	//generate hub yang bener
	FORN(i,n) if (fp(i,parent) == i) {
		vint rusuh;
		FORN(j,n) if (fp(j,parent) == i) FORN(k,SZ(hub[j])) rusuh.PB(fp(hub[j][k],parent));
		sort(ALL(rusuh));
		rusuh.erase(unique(ALL(rusuh)),rusuh.end());
		hub[i] = rusuh;
		}
	return;
	}</Snippet>		<Snippet Name="bidirectionalcycledmerge">int fp(int abc, int parent[]) {
  if (parent[abc] == abc) return abc;
  int def = fp(parent[abc],parent);
  parent[abc] = def;
  return def;
  }

//hub adjacency list
//n : jumlah node
//parent : ntar jadi siapa parentnya siapa tea yg link
void bidirectionalcycledmerge(vector&lt;int&gt; hub[],int n,int parent[]) {
  stack&lt;int&gt; urutan;
  for (int i = 0;i &lt; n;i++) parent[i] = i;
  stack&lt; pair&lt;int,int&gt; &gt; ngurut;
  vector&lt;int&gt; sudah(n,0);
  vector&lt;int&gt; adadiurutan(n,0);
  vector&lt;int&gt; from(n,0);
  for (int i = 0;i &lt; n;i++) {
    if (sudah[i]) continue;
    urutan.push(i);
    ngurut.push(make_pair(i,0));
    adadiurutan[i] = 1;
    sudah[i] = 1;
    from[i] = -1;
    while (!ngurut.empty()) {
      int id = ngurut.top().first;
      int val = ngurut.top().second;
      ngurut.pop();
      if (val == hub[id].size()) {
        while (!urutan.empty() &amp;&amp; urutan.top() == id) urutan.pop();
        adadiurutan[id] = 0;
        continue;
        }
      ngurut.push(make_pair(id,val + 1));
      int next = hub[id][val];
      if (from[id] == next) continue;
      if (sudah[next] &amp;&amp; !adadiurutan[fp(next,parent)]) continue;
      if (!sudah[next]) {
        sudah[next] = 1;
        urutan.push(next);
        ngurut.push(make_pair(next,0));
        adadiurutan[next] = 1;
        from[next] = id;
        continue;
        }
      if (parent[fp(id,parent)] == fp(next,parent)) continue;
      parent[fp(id,parent)] = fp(next,parent);
      while (!urutan.empty() &amp;&amp; urutan.top() != fp(next,parent)) {
        parent[fp(urutan.top(),parent)] = fp(next,parent);
        urutan.pop();
        }
      }
    }

  FORN(i,n) parent[i] = fp(i,parent);

  return;
  }

/*
vint adj[MAXN];
int p[MAXN];
bidirectionalcycledmerge(adj,n,p);
*/</Snippet>		<Snippet Name="TopologicalSort">class TopologicalSort {
  public:
  	explicit TopologicalSort(int number_of_nodes) : adj_(number_of_nodes) {}
  	void AddEdge(int from, int to) {
  		adj_[from].PB(to);
  	}

  	//return empty list kalo no order possible, otherwise get the any ordering. O(N)
  	vector&lt;int&gt; GetOrder() {
  		stack&lt;int&gt; node_stack;
  		vector&lt;int&gt; in_degree(SZ(adj_),0);
  		vector&lt;int&gt; order;
  		FORN(i,SZ(adj_)) FORIT(j,adj_[i]) ++in_degree[*j];
  		FORN(i,SZ(adj_)) if (in_degree[i] == 0) node_stack.push(i);

  		while (!node_stack.empty()) {
  			int curnode = node_stack.top();
  			node_stack.pop();
  			order.PB(curnode);
  			FORIT(i,adj_[curnode]) {
  				--in_degree[*i];
  				if (in_degree[*i] == 0) node_stack.push(*i);
  			}
  		}
  		if (SZ(order) != SZ(adj_)) return vint();
  		return order;
  	}

  private:
	vector&lt; vint &gt; adj_;
};

//TopologicalSort ts(jumlah_node);
//ts.AddEdge(3,6); //3 harus sebelum 6
//vector&lt;int&gt; urutan = ts.GetOrder();</Snippet>		<Snippet Name="MinimumSpanningTree">class DisjointSet {
  public:
  	explicit DisjointSet(int n) {
  		whichset_ = vector&lt;int&gt;(n);
  		for (int i = 0; i &lt; n; ++i) whichset_[i] = i;
  	}

  	int Find(int node) {
  		if (whichset_[node] == node) return node;
  		return (whichset_[node] = Find(whichset_[node]));
  	}

  	void Merge(int first_node, int second_node) {
  		whichset_[Find(first_node)] = Find(second_node);
  	}

  private:
  	vector&lt;int&gt; whichset_;
};

//DisjointSet ds(jumlah_node);
//ds.Merge(0,1);
//ds.Find(1) //return 0 ato 1

//multiple cables possible
template &lt;class CLength&gt;
class MinimumSpanningTree {
  public:
  	explicit MinimumSpanningTree(int n) {
		adj_ = vector&lt; vector&lt; pair&lt;int, CLength&gt; &gt; &gt;(n);
	}
	//bidirectional
	void AddEdge(int from, int to, CLength length) {

		adj_[from].push_back(MP(to,length));
		adj_[to].push_back(MP(from,length));
		edges_.PB(MP(length, MP(from, to)));
	}

	//return -1 if any pair of nodes are not connected
	CLength CountMST(void) {
		int nmerges = 0;
		sort(ALL(edges_));
		DisjointSet ds(SZ(adj_));
		CLength retval = 0;
		for (int i = 0; i &lt; SZ(edges_); ++i) {
			if (ds.Find(edges_[i].B.A) != ds.Find(edges_[i].B.B)) {
				ds.Merge(edges_[i].B.A, edges_[i].B.B);
				retval += edges_[i].A;
				++nmerges;
			}
		}
		if (nmerges != SZ(adj_) - 1) return -1;
		return retval;
	}
  private:
	vector&lt; vector&lt; pair&lt;int, CLength&gt; &gt; &gt; adj_;
	vector&lt; pair&lt; CLength, pair&lt;int,int&gt; &gt; &gt; edges_;
};

//MinimumSpanningTree&lt;CLength&gt; mst(jml_node);
//mst.AddEdge(1,3,40.5); //dari 1 ke 3 panjang 40.5
//mst.AddEdge(1,3,40.52); //bisa multiple edges
//return mst.CountMST();</Snippet>		<Snippet Name="GraphColoring">class Graph {
  public:
  	virtual ~Graph() {};
  	virtual void Simplify() {};
};

class UnweightedGraph : public Graph {
  public:
  	UnweightedGraph(int number_of_nodes) : adj_(number_of_nodes) {}
  	UnweightedGraph&amp; operator=(const UnweightedGraph&amp; input_graph) {
  		adj_ = vector&lt;vint&gt;(SZ(input_graph.adj_));
  		FORN(i, SZ(input_graph.adj_)) FORIT(j, input_graph.adj_[i]) this-&gt;AddEdge(i, *j);
  		return *this;
  	}
  	virtual void AddEdge(int from, int to) {
  		adj_[from].PB(to);
  	}
  	vector&lt; vint &gt; adj_;
};

class UndirectedUnweightedGraph : public UnweightedGraph {
  public:
  	UndirectedUnweightedGraph(int number_of_nodes) : UnweightedGraph(number_of_nodes) {}
  	virtual void AddEdge(int from, int to) {
  		UnweightedGraph::AddEdge(from, to);
  		UnweightedGraph::AddEdge(to, from);
  	}
};

class GraphColoring : public UndirectedUnweightedGraph {
  public:
  	explicit GraphColoring(int number_of_nodes) : UndirectedUnweightedGraph(number_of_nodes) {}

  	//return minimum number of colors to color the graph, -1 if impossible.
  	int MinimumColor() {
  		int nnodes = SZ(adj_);
  		vint dp(1 &lt;&lt; nnodes, INF);
  		vint used(1 &lt;&lt; nnodes, -1);
  		queue&lt;int&gt; q;
  		vint isindependent(1 &lt;&lt; nnodes,1);
  		FORN(mask,1 &lt;&lt; nnodes) {
  			FORN(j,nnodes) if (mask &amp; (1 &lt;&lt; j)) FORIT(k, adj_[j]) if (mask &amp; (1 &lt;&lt; (*k))) if (*k != j) isindependent[mask] = 0;
  		}
  		q.push(0);
  		dp[0] = 0;
  		while (!q.empty()) {
  			int mask = q.front();
  			q.pop();
  			if (mask == (1 &lt;&lt; nnodes)-1) {
  				colors = vint(nnodes);
  				int curnode = mask;
  				int cnt = dp[mask]-1;
  				while (used[curnode] != -1) {
  					FORN(j, nnodes) if (j &amp; used[curnode]) colors[j] = cnt;
  					--cnt;
  					curnode -= used[curnode];
  				}
  				return dp[mask];
  			}
  			for(int i = (1 &lt;&lt; nnodes)-1; i &gt;=  1; --i) if (isindependent[i] &amp;&amp; i + mask == (i | mask) &amp;&amp; dp[i | mask] &gt; dp[mask] + 1) {
  				dp[i | mask] = dp[mask] + 1;
  				used[i | mask] = i;
  				q.push(i | mask);
  			}
  		}
  		DEBUG(&quot;error&quot;);
  		return -100;
  	}
  	vint GetColors() {
  		MinimumColor();
  		return colors;
  	}
  private:
  	vint colors;
};

//O(4^N)
//GraphColoring gc(jumlah_node);
//ts.AddEdge(0,5);
//int jumlah_color_minimum = gc.MinimumColor();
//vint warna_lexicographically_minimum = gc.GetColors();</Snippet>		<Snippet Name="UndirectedStronglyConnectedComponents">class DisjointSet {
  public:
  	explicit DisjointSet(int n) {
  		whichset_ = vector&lt;int&gt;(n);
  		height_ = vector&lt;int&gt;(n, 1);
  		for (int i = 0; i &lt; n; ++i) whichset_[i] = i;
  	}

  	int Find(int node) {
  		if (whichset_[node] == node) return node;
  		return (whichset_[node] = Find(whichset_[node]));
  	}

  	void Merge(int first_node, int second_node) {
  		//cek siapa mo jadi bokapnya?
  		int h1 = height_[Find(first_node)];
  		int h2 = height_[Find(second_node)];
  		if (h1 &lt; h2) {
	  		whichset_[Find(first_node)] = Find(second_node);
	  		return;
	  	}
	  	whichset_[Find(second_node)] = Find(first_node);
	  	if (h2 &lt; h1) return;
	  	++height_[Find(second_node)];
  	}

  private:
  	vector&lt;int&gt; whichset_;
  	vector&lt;int&gt; height_;
};

//DisjointSet ds(jumlah_node);
//ds.Merge(0,1);
//ds.Find(1) //return 0 ato 1

int fp(int abc, int parent[]) {
  if (parent[abc] == abc) return abc;
  int def = fp(parent[abc],parent);
  parent[abc] = def;
  return def;
  }

class UndirectedStronglyConnectedComponents {
 public:
  UndirectedStronglyConnectedComponents(int n) {
    n_ = n;
    adj_ = new vint[n];
    id_ = new vint[n];
    next_id_ = 0;
  }
  
  ~UndirectedStronglyConnectedComponents() {
    delete[] adj_;
    delete[] id_;
  }
  
  void add_edge(int a, int b) {
    assert (a &gt;= 0 &amp;&amp; b &gt;= 0 &amp;&amp; a &lt; n_ &amp;&amp; b &lt; n_);
    adj_[a].PB(b);
    adj_[b].PB(a);
    id_[a].PB(next_id_);
    id_[b].PB(next_id_);
    ++next_id_;
  }
  
  stack&lt;int&gt; comps_;
  vector&lt;int&gt; visited_;
  DisjointSet* ds_;
  
  void Dfs(int node, int base, int from_id) {
    assert(visited_[node] == 0);
    visited_[node] = 2;
    comps_.push(node);
    
    FORN(i, SZ(adj_[node])) {
      int next = adj_[node][i];
      int idn = id_[node][i];
      if (idn == from_id) continue;
      
      if (!visited_[next]) {
        Dfs(next, base, idn);
        continue;
      }
      
      if (visited_[next] == 1) continue;
      
      // otherwise we found a cycle.
      while (ds_-&gt;Find(comps_.top()) != ds_-&gt;Find(next)) {
        ds_-&gt;Merge(comps_.top(), node);
        comps_.pop();
      }
      
      ds_-&gt;Merge(comps_.top(), node);
    }
    
    if (comps_.top() == node) comps_.pop();
    visited_[node] = 1;
  }
  
  // Outputs the group number of each node.
  vint solve() {
    while (!comps_.empty()) comps_.pop();
    visited_ = vint(n_, 0);
    ds_ = new DisjointSet(n_);
    
    for (int i = 0; i &lt; n_; ++i) {
      if (visited_[i]) continue;
      Dfs(i, i, -1);
    }
    
    vint ret(n_, 0);
    FORN(i, n_) ret[i] = ds_-&gt;Find(i);
    
    delete ds_;
    
    return ret;
  }
  
  int n_;  // no of nodes
  vint* adj_;
  vint* id_;
  int next_id_;
  
};</Snippet>		<Snippet Name="BridgeDetect">class BridgeDetect {
 public:
  BridgeDetect(int n) {
    n_ = n;
    adj_ = new vector&lt;int&gt;[n];
  }
  
  void AddBiEdge(int a, int b) {
    int i = SZ(from_);
    from_.PB(a);
    to_.PB(b);
    adj_[a].PB(i);
    adj_[b].PB(i);
  }
  
  // Return all pairs &lt;a, b&gt;, a &lt; b, such that edge a, b is bridge.
  vector&lt; pair&lt;int,int&gt; &gt; Solve() {
    int m = SZ(from_);
    is_tree_ = new int[m];
    for (int i = 0; i &lt; m; ++i) is_tree_[i] = 0;
    
    vis_ = new int[n_];
    for (int i = 0; i &lt; n_; ++i) vis_[i] = 0;
    val_ = new int[n_];
    
    sc_ = n_;
    
    low_ = new int[n_];
    hi_ = new int[n_];
    desc_ = new int[n_];
    par_ = new int[n_];
    for (int i = 0; i &lt; n_; ++i) if (!vis_[i]) {
      par_[i] = -1;
      Span(i);
    }
    while (!s_.empty()) {
      int node = s_.front();
      s_.pop();
      desc_[node] = 1;
      low_[node] = hi_[node] = val_[node];
      // iter amongst children and update low/hi/desc
      FORIT(it, adj_[node]) {
        if (is_tree_[*it]) {
          int to = GetTo(*it, node);
          if (par_[node] == to) continue;
          desc_[node] += desc_[to];
          MN(low_[node], low_[to]);
          MX(hi_[node], hi_[to]);
        }
      }
      
      FORIT(it, adj_[node]) {
        if (!is_tree_[*it]) {
          int to = GetTo(*it, node);
          MN(low_[node], val_[to]);
          MX(hi_[node], val_[to]);
        }
      }
    }
    
    vector&lt; pair&lt;int, int&gt; &gt; ret;
    FORN(i, SZ(from_)) {
      if (!is_tree_[i]) continue;
      int f = from_[i];
      int t = to_[i];
      if (val_[f] &gt; val_[t]) swap(f, t);
      if (low_[t] == val_[t] &amp;&amp; hi_[t] &lt; val_[t] + desc_[t]) {
        ret.PB(MP(min(f, t), max(f, t)));
      }
    }
    
    delete[] low_;
    delete[] hi_;
    delete[] desc_;
    delete[] val_;
    delete[] is_tree_;
    delete[] vis_;
    delete[] par_;
    
    return ret;
  }
  
 private:
 
  int GetTo(int index, int fr) {
    assert(from_[index] == fr || to_[index] == fr);
    if (from_[index] == fr) return to_[index]; else return from_[index];
  }
 
  void Span(int node) {
    vis_[node] = 1;
    FORIT(it, adj_[node]) {
      int k = GetTo(*it, node);
      if (!vis_[k]) {
        is_tree_[*it] = 1;
        par_[k] = node;
        Span(k);
      }
    }
    val_[node] = sc_;
    --sc_;
    s_.push(node);
  }
 
  int n_;
  vint from_;
  vint to_;
  vint* adj_;
  
  int* is_tree_;
  int* vis_;
  
  int* val_;
  queue&lt;int&gt; s_;
  
  int sc_;
  
  int* low_;
  int* hi_;
  int* desc_;
  
  int* par_;
  
};

// BridgeDetect bd(nodes);
// bd.AddBiEdge(from, to);  # bidirectional
// vector&lt; pair&lt;int, int&gt; &gt; bridges = bd.Solve();
// Note that edges are given as &lt;a, b&gt; where a &lt; b
// .Solve() is stateless</Snippet>		<Snippet Name="DirectedForestBuilder">class DirectedForestBuilder {
 public:
  DirectedForestBuilder(int nodes) {
    n_ = nodes;
    solved_ = false;
    adj_ = new vint[nodes];
    parent_ = new int[nodes];
  }
  
  ~DirectedForestBuilder() {
    delete[] adj_;
    delete[] parent_;
  }
  
  // Add an edge between and a and b. The edges must be added such that
  // between every pair of nodes, there exists AT MOST ONE simple path.
  void AddBiEdge(int a, int b) {
    assert(!solved_);
    adj_[a].PB(b);
    adj_[b].PB(a);
  }
  
  // Called after all AddBiEdge() has been done.
  void Solve() {
    assert(!solved_);
    solved_ = true;
    
    FORN(i, n_) parent_[i] = -1;
    FORN(i, n_) if (parent_[i] == -1) {
      // Make root
      MakeTreeDfs(i);
    }
  }
  
  // Called after Solve()
  int Parent(int node) {
    if (!solved_) Solve();
    return parent_[node];
  }
  
  void MakeTreeDfs(int node) {
    FORIT(it, adj_[node]) {
      if (*it == parent_[node]) continue;
      if (parent_[*it] != -1) continue;  // multi edge
      if (*it == node) continue;
      parent_[*it] = node;
      MakeTreeDfs(*it);
    }
  }
  
  bool solved_;
  vint* adj_;
  int* parent_;
  int n_;
};
// DirectedForestBuilder builder(nodes);
// builder.AddBiEdge(a, b);
// builder.Solve();
// p1 = builder.Parent(node);  # or -1 if it's root.</Snippet>		<Snippet Name="LCA">class LCA {
 public:
  LCA(int node) {
    n_ = node;
    modified_ = true;
    parent_ = new int[node];
    for (int i = 0; i &lt; node; ++i) {
      parent_[i] = -1;
    }
    depth_ = new int[node];
    int rmqsize = 1;
    int iter = 1;
    while (iter &lt; node) {
      iter *= 2;
      ++rmqsize;
    }
    rmq_ = new int*[node];
    FORN(i, n_) {
      rmq_[i] = new int[rmqsize + 1];
    }
    rmq_[0][0] = 1;
    rmq_size_ = rmqsize;
    child_ = new vector&lt;int&gt;[n_];
  }
  
  ~LCA() {
    delete[] parent_;
    delete[] depth_;
    FORN(i, n_) {
      delete[] rmq_[i];
    }
    delete[] rmq_;
    delete[] child_;
  }
  
  void AddEdge(int parent, int child) {
    assert(parent &gt;= 0 &amp;&amp; parent &lt; n_ &amp;&amp; child &gt;= 0 &amp;&amp; child &lt; n_);
    assert(parent != child);
    assert(parent_[child] == -1);
    parent_[child] = parent;
    modified_ = true;
  }
  
  // Returns the LCA of a and b, or -1 if they have different roots.
  int Solve(int a, int b) {
    assert(a &gt;= 0 &amp;&amp; a &lt; n_);
    assert(b &gt;= 0 &amp;&amp; b &lt; n_);
    
    if (modified_) {
      Compute();
    }
    modified_ = false;
    // make depth equal
    
    if (depth_[a] &gt; depth_[b]) return Solve(b, a);
    
    for (int i = rmq_size_; i &gt;= 0; --i)
      if (depth_[rmq_[b][i]] &gt;= depth_[a])
        b = rmq_[b][i];
    
    assert(depth_[a] == depth_[b]);
    for (int i = rmq_size_; i &gt;= 0; --i) {
      if (rmq_[a][i] != rmq_[b][i]) {
        a = rmq_[a][i];
        b = rmq_[b][i];
      }
    }
    
    if (a == b) return a;
    if (parent_[a] == parent_[b] &amp;&amp; parent_[a] != -1) return parent_[a];
    return -1;
  }

  void Compute() {
    FORN(i, n_) {
      depth_[i] = -1;
    }
    FORN(i, n_) child_[i].clear();
    FORN(i, n_) if (parent_[i] != -1) {
      child_[parent_[i]].PB(i);
    }
    FORN(i, n_) {
      if (depth_[i] == -1 &amp;&amp; parent_[i] == -1) {
        DfsDepth(i, 0);
      }
    }
    FORN(i, n_) {
      if (parent_[i] == -1) {
        rmq_[i][0] = i;
      } else {
        rmq_[i][0] = parent_[i];
      }
    }
    REP(i, 1, rmq_size_ + 1) {
      FORN(j, n_) {
        rmq_[j][i] = rmq_[rmq_[j][i-1]][i-1];
      }
    }
  }
  
  void DfsDepth(int node, int dep) {
    depth_[node] = dep;
    FORIT(it, child_[node]) {
      DfsDepth(*it, dep+1);
    }
  }
  
  bool modified_;
  int* parent_;
  vint* child_;
  int* depth_;
  int** rmq_;
  int n_;
  int rmq_size_;
};
// LCA lca(nodes);
// lca.AddEdge(parent, child);
// lca.Solve(a, b); // LCA of a and b, if present, or -1 if no ancestor.</Snippet>	</Category>
	<Category Name="MATH">
		<Category Name="MATRIX">
			<Category Name="DOUBLE">
				<Snippet Name="mmul">//MULTIPLY 2 MATRIX
//       XX
//XXXX * XX = XX
//XXXX   XX   XX
//       XX
//
//2r4c * 4c2r = 2r2c

vector&lt; vector&lt;double&gt; &gt; mmul(vector&lt; vector&lt;double&gt; &gt; abc,vector&lt; vector&lt;double&gt; &gt; def) {

	vector &lt;vector&lt;double&gt; &gt; ret;
	if (abc[0].size() != def.size()) printf(&quot;ukuran salah untuk perkalian. %d %d x %d %d\n&quot;,abc.size(),abc[0].size(),def.size(),def[0].size());
	FORN(i,SZ(abc)) {
		vector&lt;double&gt; tambah;
		FORN(j,SZ(def[0])) {
			double value = 0LL;
			FORN(k,SZ(def)) {
				value += (abc[i][k] * def[k][j]);
				}
			tambah.PB(value);
			}
		ret.PB(tambah);
		}
	return ret;
	}</Snippet>				<Snippet Name="mpow">

//CREATE an empty vector&lt;vector&lt;double&gt;&gt; yg ukurannya sama dengan abc, tapi isinya 0 smua
vector&lt; vector&lt;double&gt; &gt; mcreatecopy (vector&lt; vector&lt;double&gt; &gt; abc) {
	vector&lt; vector&lt;double&gt; &gt; ret = abc;
	FORN(i,SZ(abc)) FORN(j,SZ(abc[0])) ret[i][j] = 0;
	if (SZ(abc) == SZ(abc[0])) FORN(i,SZ(abc)) ret[i][i] = 1;
	return ret;
	}

//CREATE an emtpy vector&lt; vector&lt;double&gt; &gt; dengan ukuran A[depan][belakang]
vector&lt; vector&lt;double&gt; &gt; mcreatenew (double depan,double belakang) {
	vector&lt; vector&lt;double&gt; &gt;ret;
	FORN(i,depan) {
		vector&lt;double&gt; veint(belakang,0);
		ret.PB(veint);
		}
	//if (SZ(ret) == SZ(ret[0])) FORN(i,SZ(ret)) ret[i][i] = 1;
	return ret;
	}

//MULTIPLY 2 MATRIX
//       XX
//XXXX * XX = XX
//XXXX   XX   XX
//       XX
//
//2r4c * 4c2r = 2r2c

vector&lt; vector&lt;double&gt; &gt; mmul(vector&lt; vector&lt;double&gt; &gt; abc,vector&lt; vector&lt;double&gt; &gt; def) {

	vector &lt;vector&lt;double&gt; &gt; ret;
	if (abc[0].size() != def.size()) printf(&quot;ukuran salah untuk perkalian. %d %d x %d %d\n&quot;,abc.size(),abc[0].size(),def.size(),def[0].size());
	FORN(i,SZ(abc)) {
		vector&lt;double&gt; tambah;
		FORN(j,SZ(def[0])) {
			double value = 0LL;
			FORN(k,SZ(def)) {
				value += (abc[i][k] * def[k][j]);
				}
			tambah.PB(value);
			}
		ret.PB(tambah);
		}
	return ret;
	}

//PANGKATKAN, dalam O(log Pangkat)
//parameter : abc : matrixnya, pangkat : pangakt brp kali?, modulo : maw dimodulo brp hasilnya

vector&lt; vector&lt;double&gt; &gt; mpow( vector&lt; vector&lt;double&gt; &gt; abc,long long pangkat) {
	vector&lt; vector&lt;double&gt; &gt; ret = mcreatecopy(abc);
	while (pangkat &gt; 0LL) {
		if (pangkat % 2LL) {
			ret = mmul(ret,abc,modulo);
			}
		pangkat /= 2LL;
		abc = mmul(abc,abc,modulo);
		}
	return ret;
	}
</Snippet>			</Category>
			<Category Name="LL">
				<Snippet Name="MatrixPowerSolver">/*					MODIFIABLE					*/
ll iMatrixMultiply(ll multiplicant1, ll multiplicant2, ll ivalue = (ll)INF * (ll)INF) {
	//return MultiplyWithLimit(multiplicant1, multiplicant2, ivalue);
}

ll iMatrixAdd(ll operand1, ll operand2, ll ivalue = (ll)INF * (ll)INF) {
	//return min(operand1 + operand2, ivalue);
}
/*					END OF MODIFIABLE			*/

vector&lt; vector&lt;ll&gt; &gt; MatrixIdentity(int row_and_col) {
	vector&lt; vector&lt;ll&gt; &gt; ret = vector&lt; vector&lt;ll&gt; &gt;(row_and_col, vector&lt;ll&gt;(row_and_col, 0));
	FORN(i,row_and_col) ret[i][i] = 1LL;
	return ret;
}

vector&lt; vector&lt;ll&gt; &gt; MatrixMultiply(vector&lt; vector&lt;ll&gt; &gt; first_matrix, vector&lt; vector&lt;ll&gt; &gt; second_matrix, ll ivalue = (ll)INF * (ll)INF) {

	vector &lt;vector&lt;long long&gt; &gt; ret;
	if (first_matrix[0].size() != second_matrix.size()) printf(&quot;ukuran salah untuk perkalian. %d %d x %d %d\n&quot;,
			first_matrix.size(),first_matrix[0].size(),second_matrix.size(),second_matrix[0].size());
	FORN(i,SZ(first_matrix)) {
		vector&lt;long long&gt; ret_row_i;
		FORN(j,SZ(second_matrix[0])) {
			long long value = 0LL;
			FORN(k,SZ(second_matrix)) {
				value = iMatrixAdd(value, iMatrixMultiply(first_matrix[i][k], second_matrix[k][j], ivalue), ivalue);
				}
			ret_row_i.PB(value);
			}
		ret.PB(ret_row_i);
		}
	return ret;
	}
//vector&lt; vector&lt;ll&gt; &gt; matrix = MatrixMultiply(matrix1, matrix2, ivalue);

vector&lt; vector&lt;long long&gt; &gt; MatrixPower(vector&lt; vector&lt;long long&gt; &gt; matrix,long long pangkat,long long ivalue = (ll)INF * (ll)INF) {
	vector&lt; vector&lt;long long&gt; &gt; ret = MatrixIdentity(SZ(matrix));
	while (pangkat &gt; 0LL) {
		if (pangkat % 2LL) {
			ret = MatrixMultiply(ret, matrix, ivalue);
			}
		pangkat /= 2LL;
		matrix = MatrixMultiply(matrix, matrix, ivalue);
		}
	return ret;
	}
//vector&lt; vector&lt;ll&gt; &gt; matrix = MatrixPower(matrix1, pangkatnya, ivalue);

vector&lt; ll &gt; MatrixPowerSolver(vector&lt; vector&lt; ll &gt; &gt; matrix, ll pangkat, vector&lt;ll&gt; operand_vector, ll ivalue = (ll)INF * (ll)INF) {
	vector&lt; vector&lt; ll &gt; &gt; parsed_operand_vector(SZ(operand_vector), vector&lt;ll&gt;(1,0));
	FORN(i, SZ(operand_vector)) parsed_operand_vector[i][0] = operand_vector[i];
	vector&lt; vector&lt; ll &gt; &gt; unparsed_ret = MatrixMultiply(MatrixPower(matrix, pangkat, ivalue), parsed_operand_vector, ivalue);
	vector&lt; ll &gt; ret(SZ(unparsed_ret),0);
	FORN(i,SZ(unparsed_ret)) ret[i] = unparsed_ret[i][0];
	return ret;
}

//rubah modifiable
//vector&lt; vector&lt;ll&gt; &gt; matrix; //matrix[i][j] -&gt; kontribusi j buat i.
//vector&lt;ll&gt; init_vector; //vector awal
//vector&lt;ll&gt; hasil_akhir = MatrixPowerSolver(matrix, pangkatnya, init_vector, ivalue);</Snippet>				<Snippet Name="MatrixPowerSolverLimit">int IsMultiplyOverflow (ll multiplicant1,ll multiplicant2,ll overflow_limit) {
	if (multiplicant2 == 0LL) return overflow_limit &lt; 0LL;
	return multiplicant1 &gt; overflow_limit/multiplicant2;
	}
//IsMultiplyOver(3,-5,16) == TRUE

ll MultiplyWithLimit (ll multiplicant1, ll multiplicant2, ll overflow_limit) {
	if (multiplicant2 == 0LL) return 0LL;
	if (IsMultiplyOverflow(abs(multiplicant1), abs(multiplicant2), overflow_limit)) return (multiplicant1 / abs(multiplicant1)) * (multiplicant2 / abs(multiplicant2)) * overflow_limit;
	return multiplicant1 * multiplicant2;
}
//MultiplyWithLimit(3,-5,14) == -14

/*					MODIFIABLE					*/
ll iMatrixMultiplyLimit(ll multiplicant1, ll multiplicant2, ll ivalue = (ll)INF * (ll)INF) {
	return MultiplyWithLimit(multiplicant1, multiplicant2, ivalue);
}

ll iMatrixAddLimit(ll operand1, ll operand2, ll ivalue = (ll)INF * (ll)INF) {
	return min(operand1 + operand2, ivalue);
}
/*					END OF MODIFIABLE			*/

vector&lt; vector&lt;ll&gt; &gt; MatrixIdentity(int row_and_col) {
	vector&lt; vector&lt;ll&gt; &gt; ret = vector&lt; vector&lt;ll&gt; &gt;(row_and_col, vector&lt;ll&gt;(row_and_col, 0));
	FORN(i,row_and_col) ret[i][i] = 1LL;
	return ret;
}

vector&lt; vector&lt;ll&gt; &gt; MatrixMultiplyLimit(vector&lt; vector&lt;ll&gt; &gt; first_matrix, vector&lt; vector&lt;ll&gt; &gt; second_matrix, ll ivalue = (ll)INF * (ll)INF) {

	vector &lt;vector&lt;long long&gt; &gt; ret;
	if (first_matrix[0].size() != second_matrix.size()) printf(&quot;ukuran salah untuk perkalian. %d %d x %d %d\n&quot;,
			first_matrix.size(),first_matrix[0].size(),second_matrix.size(),second_matrix[0].size());
	FORN(i,SZ(first_matrix)) {
		vector&lt;long long&gt; ret_row_i;
		FORN(j,SZ(second_matrix[0])) {
			long long value = 0LL;
			FORN(k,SZ(second_matrix)) {
				value = iMatrixAddLimit(value, iMatrixMultiplyLimit(first_matrix[i][k], second_matrix[k][j], ivalue), ivalue);
				}
			ret_row_i.PB(value);
			}
		ret.PB(ret_row_i);
		}
	return ret;
	}
//vector&lt; vector&lt;ll&gt; &gt; matrix = MatrixMultiply(matrix1, matrix2, ivalue);

vector&lt; vector&lt;long long&gt; &gt; MatrixPowerLimit(vector&lt; vector&lt;long long&gt; &gt; matrix,long long pangkat,long long ivalue = (ll)INF * (ll)INF) {
	vector&lt; vector&lt;long long&gt; &gt; ret = MatrixIdentity(SZ(matrix));
	while (pangkat &gt; 0LL) {
		if (pangkat % 2LL) {
			ret = MatrixMultiplyLimit(ret, matrix, ivalue);
			}
		pangkat /= 2LL;
		matrix = MatrixMultiplyLimit(matrix, matrix, ivalue);
		}
	return ret;
	}
//vector&lt; vector&lt;ll&gt; &gt; matrix = MatrixPower(matrix1, pangkatnya, ivalue);

vector&lt; ll &gt; MatrixPowerSolverLimit(vector&lt; vector&lt; ll &gt; &gt; matrix, ll pangkat, vector&lt;ll&gt; operand_vector, ll ivalue = (ll)INF * (ll)INF) {
	vector&lt; vector&lt; ll &gt; &gt; parsed_operand_vector(SZ(operand_vector), vector&lt;ll&gt;(1,0));
	FORN(i, SZ(operand_vector)) parsed_operand_vector[i][0] = operand_vector[i];
	vector&lt; vector&lt; ll &gt; &gt; unparsed_ret = MatrixMultiplyLimit(MatrixPowerLimit(matrix, pangkat, ivalue), parsed_operand_vector, ivalue);
	vector&lt; ll &gt; ret(SZ(unparsed_ret),0);
	FORN(i,SZ(unparsed_ret)) ret[i] = unparsed_ret[i][0];
	return ret;
}

//rubah modifiable
//vector&lt; vector&lt;ll&gt; &gt; matrix; //matrix[i][j] -&gt; kontribusi j buat i.
//vector&lt;ll&gt; init_vector; //vector awal
//vector&lt;ll&gt; hasil_akhir = MatrixPowerSolverLimit(matrix, pangkatnya, init_vector, ivalue);</Snippet>				<Snippet Name="MatrixPowerSolverOptimized">/*					MODIFIABLE					*/
ll iMatrixMultiply(ll multiplicant1, ll multiplicant2, ll ivalue = (ll)INF * (ll)INF) {
  // this is tedious
  if (ivalue &lt;= 2000000000LL) return ((multiplicant1 % ivalue) * (multiplicant2 % ivalue)) % ivalue;
  
  ll midpoint = 1000000000LL;
  ll m1 = multiplicant1;
  ll m2 = multiplicant2;
  
  // find the last 13 digits
  ll m1a = (m1 / midpoint) % 10000;
  ll m1b = m1 % midpoint;
  
  ll m2a = (m2 / midpoint) % 10000;
  ll m2b = m2 % midpoint;
  
  ll back = m1b * m2b;  // x 1
  m1b %= 10000;
  m2b %= 10000;
  ll mid = m1a * m2b + m2a * m1b; // x midpoint
  mid += (back / midpoint) % 10000;
  back %= midpoint;
  mid %= 10000;
  return mid * midpoint + back;
}

ll iMatrixAdd(ll operand1, ll operand2, ll ivalue = (ll)INF * (ll)INF) {
  return (operand1 + operand2) % ivalue;
	//return min(operand1 + operand2, ivalue);
}
/*					END OF MODIFIABLE			*/

ll** MatrixIdentity(int row_and_col) {
  ll** ret = new ll*[row_and_col];
  FORN(i, row_and_col) ret[i] = new ll[row_and_col];
  FORN(i, row_and_col) FORN(j, row_and_col) ret[i][j] = i==j;
	return ret;
}

ll** MatrixFactory(int row, int col) {
  ll** ret = new ll*[row];
  FORN(i, row) ret[i] = new ll[col];
  FORN(i, row) FORN(j, col) ret[i][j] = 0;
  return ret;
}

void Destroy(ll** matrix, int row) {
  FORN(i, row) delete[] matrix[i];
  delete[] matrix;
}

ll** MatrixMultiply(
    ll** first_matrix,
    int n,
    int m,
    ll** second_matrix,
    int k,
    ll ivalue = (ll)INF * (ll)INF) {

	ll** ret = MatrixFactory(n, k);
  
	FORN(i, n) {
		FORN(j, k) {
			long long value = 0LL;
			FORN(k, m) {
				value = iMatrixAdd(value, iMatrixMultiply(first_matrix[i][k], second_matrix[k][j], ivalue), ivalue);
      }
			ret[i][j] = value;
    }
  }
	return ret;
}
//vector&lt; vector&lt;ll&gt; &gt; matrix = MatrixMultiply(matrix1, matrix2, ivalue);

ll** MatrixPower(
    ll** matrix,
    int n,
    long long pangkat,
    long long ivalue = (ll)INF * (ll)INF) {
	ll** ret = MatrixIdentity(n);
  ll** cpm = MatrixIdentity(n);
  FORN(i, n) FORN(j, n) cpm[i][j] = matrix[i][j];
	while (pangkat &gt; 0LL) {
		if (pangkat % 2LL) {
      ll** baru = MatrixMultiply(ret, n, n, cpm, n, ivalue);
      Destroy(ret, n);
      ret = baru;
    }
		pangkat /= 2LL;
		ll** baru = MatrixMultiply(cpm, n, n, cpm, n, ivalue);
    Destroy(cpm, n);
    cpm = baru;
  }
  Destroy(cpm, n);
	return ret;
}
//vector&lt; vector&lt;ll&gt; &gt; matrix = MatrixPower(matrix1, pangkatnya, ivalue);

ll last = 0LL;
ll** terakhir;

vector&lt; ll &gt; MatrixPowerSolver(vector&lt; vector&lt; ll &gt; &gt; matrix, ll pangkat, vector&lt;ll&gt; operand_vector, ll ivalue = (ll)INF * (ll)INF) {
	vector&lt; vector&lt; ll &gt; &gt; parsed_operand_vector(SZ(operand_vector), vector&lt;ll&gt;(1,0));
	FORN(i, SZ(operand_vector)) parsed_operand_vector[i][0] = operand_vector[i];
  
  int n = SZ(matrix);
  ll** matrix_raw = MatrixIdentity(n);
  FORN(i, n) FORN(j, n) matrix_raw[i][j] = matrix[i][j];
  ll** operand_raw = MatrixFactory(SZ(parsed_operand_vector), SZ(parsed_operand_vector[0]));
  FORN(i, SZ(parsed_operand_vector)) FORN(j, SZ(parsed_operand_vector[0])) operand_raw[i][j] = parsed_operand_vector[i][j];
  if (last) { Destroy(operand_raw, n), operand_raw = terakhir; }
  assert(pangkat &gt;= last);
	ll** unparsed_ret = MatrixMultiply(MatrixPower(matrix_raw, n, pangkat - last, ivalue), n, n, operand_raw, 1, ivalue);
  last = pangkat;
  terakhir = unparsed_ret;
	vector&lt; ll &gt; ret(n, 0);
	FORN(i, n) ret[i] = unparsed_ret[i][0];
  Destroy(operand_raw, n);
  Destroy(matrix_raw, n);
	return ret;
}

//rubah modifiable
//vector&lt; vector&lt;ll&gt; &gt; matrix; //matrix[i][j] -&gt; kontribusi j buat i.
//vector&lt;ll&gt; init_vector; //vector awal
//vector&lt;ll&gt; hasil_akhir = MatrixPowerSolver(matrix, pangkatnya, init_vector, ivalue);</Snippet>				<Snippet Name="MatrixPowerSolverMinimum">/*					MODIFIABLE					*/
ll iMatrixMultiply(ll multiplicant1, ll multiplicant2, ll ivalue = (ll)INF * (ll)INF) {
  return multiplicant1 + multiplicant2;
}

ll iMatrixAdd(ll operand1, ll operand2, ll ivalue = (ll)INF * (ll)INF) {

  return min(operand1, operand2);
}

ll** MatrixIdentity(int row_and_col, ll ivalue = (ll)INF * (ll)INF) {
  ll** ret = new ll*[row_and_col];
  FORN(i, row_and_col) ret[i] = new ll[row_and_col];
  FORN(i, row_and_col) FORN(j, row_and_col) ret[i][j] = ivalue;
  FORN(i, row_and_col) ret[i][i] = 0;
	return ret;
}
/*					END OF MODIFIABLE			*/

ll** MatrixFactory(int row, int col) {
  ll** ret = new ll*[row];
  FORN(i, row) ret[i] = new ll[col];
  FORN(i, row) FORN(j, col) ret[i][j] = 0;
  return ret;
}

void Destroy(ll** matrix, int row) {
  FORN(i, row) delete[] matrix[i];
  delete[] matrix;
}

ll** MatrixMultiply(
    ll** first_matrix,
    int n,
    int m,
    ll** second_matrix,
    int k,
    ll ivalue = (ll)INF * (ll)INF) {

	ll** ret = MatrixFactory(n, k);
  
	FORN(i, n) {
		FORN(j, k) {
			long long value = 0LL;
      if (m) {
        value = iMatrixMultiply(first_matrix[i][0], second_matrix[0][j], ivalue);
      }
			REP(k, 1, m) {
				value = iMatrixAdd(value, iMatrixMultiply(first_matrix[i][k], second_matrix[k][j], ivalue), ivalue);
      }
			ret[i][j] = value;
    }
  }
	return ret;
}
//vector&lt; vector&lt;ll&gt; &gt; matrix = MatrixMultiply(matrix1, matrix2, ivalue);

ll** MatrixPower(
    ll** matrix,
    int n,
    long long pangkat,
    long long ivalue = (ll)INF * (ll)INF) {
	ll** ret = MatrixIdentity(n, ivalue);
  ll** cpm = MatrixIdentity(n, ivalue);
  FORN(i, n) FORN(j, n) cpm[i][j] = matrix[i][j];
	while (pangkat &gt; 0LL) {
		if (pangkat % 2LL) {
      ll** baru = MatrixMultiply(ret, n, n, cpm, n, ivalue);

      Destroy(ret, n);
      ret = baru;
    }
		pangkat /= 2LL;
		ll** baru = MatrixMultiply(cpm, n, n, cpm, n, ivalue);
    Destroy(cpm, n);
    cpm = baru;
  }
  Destroy(cpm, n);

	return ret;
}
  //vector&lt; vector&lt;ll&gt; &gt; matrix = MatrixPower(matrix1, pangkatnya, ivalue);

  ll last = 0LL;
  ll** terakhir;

  vector&lt; ll &gt; MatrixPowerSolverMin(vector&lt; vector&lt; ll &gt; &gt; matrix, ll pangkat, vector&lt;ll&gt; operand_vector, ll ivalue = (ll)INF * (ll)INF) {
    vector&lt; vector&lt; ll &gt; &gt; parsed_operand_vector(SZ(operand_vector), vector&lt;ll&gt;(1,0));
    FORN(i, SZ(operand_vector)) parsed_operand_vector[i][0] = operand_vector[i];
  
  int n = SZ(matrix);
  ll** matrix_raw = MatrixIdentity(n, ivalue);
  FORN(i, n) FORN(j, n) matrix_raw[i][j] = matrix[i][j];
  ll** operand_raw = MatrixFactory(SZ(parsed_operand_vector), SZ(parsed_operand_vector[0]));
  FORN(i, SZ(parsed_operand_vector)) FORN(j, SZ(parsed_operand_vector[0])) operand_raw[i][j] = parsed_operand_vector[i][j];
  if (last) { Destroy(operand_raw, n), operand_raw = terakhir; }
  assert(pangkat &gt;= last);
	ll** unparsed_ret = MatrixMultiply(MatrixPower(matrix_raw, n, pangkat - last, ivalue), n, n, operand_raw, 1, ivalue);
  last = pangkat;
  terakhir = unparsed_ret;
	vector&lt; ll &gt; ret(n, 0);
	FORN(i, n) ret[i] = unparsed_ret[i][0];
  Destroy(operand_raw, n);
  Destroy(matrix_raw, n);
	return ret;
}

//rubah modifiable
//vector&lt; vector&lt;ll&gt; &gt; matrix; //matrix[i][j] -&gt; kontribusi j buat i.
//vector&lt;ll&gt; init_vector; //vector awal
//vector&lt;ll&gt; hasil_akhir = MatrixPowerSolverMin(matrix, pangkatnya, init_vector, ivalue);</Snippet>			</Category>
			<Snippet Name="minverse">//return pair&lt; pair&lt; L,U &gt;, P&gt;
//P : di index ke-i, ada si kolom yg di original tu kolom ke P[i]
//VERIFIED
#define ppmvi pair&lt; pair&lt; vector&lt; vector&lt; double &gt; &gt;, vector&lt; vector&lt;double&gt; &gt; &gt;, vint &gt;
ppmvi lupdecompose (vector&lt; vector&lt;double&gt; &gt; ori) {
	//P empty if singular

	int n = SZ(ori);
	vint permute(n,0);
	FORN(i,n) permute[i] = i;

	FORN(i,n) {
		//cari yang maximal
		int maxkoor = i;
		REP(j,i,n) if (fabs(ori[j][i]) &gt; fabs(ori[maxkoor][i])) maxkoor = j;
		if (fabs(ori[maxkoor][i]) &lt; EPS) {
			return MP( MP(vector&lt; vector&lt;db&gt; &gt;(), vector&lt; vector&lt;db&gt; &gt;()), vint());
			//singular
			}

		//tuker baris
		swap(permute[maxkoor],permute[i]);
		FORN(j,n) swap(ori[maxkoor][j],ori[i][j]);

		//bagi smua sama yg di atas si paling kiri
		REP(j,i+1,n) ori[j][i] /= ori[i][i];

		//sisa dikurang kalinya
		REP(j,i+1,n) REP(k,i+1,n) ori[j][k] -= ori[j][i] * ori[i][k];
		}

	vector&lt; vector&lt; db &gt; &gt; lower(n,vector&lt;db&gt;(n,0)),upper=lower;

	//bikin lower
	FORN(i,n) lower[i][i] = 1.0;
	FORN(i,n) FORN(j,i) lower[i][j] = ori[i][j];

	//bikin upper
	FORN(i,n) REP(j,i,n) upper[i][j] = ori[i][j];

	return MP(MP(lower,upper),permute);
	}

//VERIFIED
template &lt;class lups_&gt;
vector&lt;db&gt; lupsolve(vector&lt; vector&lt; db &gt; &gt; l, vector&lt; vector&lt; db &gt; &gt; u, vint p, vector&lt; lups_ &gt;  _b) {
	vector&lt; db &gt; b(SZ(_b),0);
	int n = SZ(l);
	FORN(i,n) b[i] = _b[p[i]];
	//cari Ux
	vint ux(n,0);
	FORN(i,n) {
		FORN(j,i) {
			b[i] -= l[i][j] * b[j];
			}
		}
	//cari x
	//Ux = b
	vector&lt; db &gt; ret(n,0);
	for (int i = n-1;i &gt;= 0;i--) {
		ret[i] = b[i];
		REP(j,i+1,n) ret[i] -= u[i][j] * ret[j];
		ret[i] /= u[i][i];
		}

	return ret;
	}

template &lt;class tipe&gt;
vector&lt; vector&lt; db &gt; &gt; minverse (vector&lt; vector&lt; tipe &gt; &gt; ori) {
	int r = SZ(ori),c = SZ(ori[0]);
	vector&lt; vector&lt;db&gt; &gt; joget(r,vector&lt;db&gt;(c,0));
	FORN(i,r) FORN(j,c) joget[i][j] = ori[i][j];

	vector&lt; vector&lt; db &gt; &gt; ret(r,vector&lt;db&gt;(c,0));

	ppmvi hasil = lupdecompose(ori);
	if (SZ(hasil.B) == 0) {
		//singular
		return vector&lt; vector&lt;db&gt; &gt;();
		}

	FORN(i,c) {
		vector&lt; db &gt; inp(r,0);
		inp[i] = 1;
		vector&lt; db &gt; ua = lupsolve(hasil.A.A,hasil.A.B,hasil.B,inp);
		FORN(j,r) ret[j][i] = ua[j];
		}
	return ret;
	}</Snippet>			<Snippet Name="lupdecompose">//return pair&lt; pair&lt; L,U &gt;, P&gt;
//P : di index ke-i, ada si kolom yg di original tu kolom ke P[i]
//VERIFIED
#define ppmvi pair&lt; pair&lt; vector&lt; vector&lt; double &gt; &gt;, vector&lt; vector&lt;double&gt; &gt; &gt;, vint &gt;
ppmvi lupdecompose (vector&lt; vector&lt;double&gt; &gt; ori) {
	//P empty if singular

	int n = SZ(ori);
	vint permute(n,0);
	FORN(i,n) permute[i] = i;

	FORN(i,n) {
		//cari yang maximal
		int maxkoor = i;
		REP(j,i,n) if (fabs(ori[j][i]) &gt; fabs(ori[maxkoor][i])) maxkoor = j;
		if (fabs(ori[maxkoor][i]) &lt; EPS) {
			return MP( MP(vector&lt; vector&lt;db&gt; &gt;(), vector&lt; vector&lt;db&gt; &gt;()), vint());
			//singular
			}

		//tuker baris
		swap(permute[maxkoor],permute[i]);
		FORN(j,n) swap(ori[maxkoor][j],ori[i][j]);

		//bagi smua sama yg di atas si paling kiri
		REP(j,i+1,n) ori[j][i] /= ori[i][i];

		//sisa dikurang kalinya
		REP(j,i+1,n) REP(k,i+1,n) ori[j][k] -= ori[j][i] * ori[i][k];
		}

	vector&lt; vector&lt; db &gt; &gt; lower(n,vector&lt;db&gt;(n,0)),upper=lower;

	//bikin lower
	FORN(i,n) lower[i][i] = 1.0;
	FORN(i,n) FORN(j,i) lower[i][j] = ori[i][j];

	//bikin upper
	FORN(i,n) REP(j,i,n) upper[i][j] = ori[i][j];

	return MP(MP(lower,upper),permute);
	}</Snippet>			<Snippet Name="lupsolve">//return pair&lt; pair&lt; L,U &gt;, P&gt;
//P : di index ke-i, ada si kolom yg di original tu kolom ke P[i]
//VERIFIED
#define ppmvi pair&lt; pair&lt; vector&lt; vector&lt; double &gt; &gt;, vector&lt; vector&lt;double&gt; &gt; &gt;, vint &gt;
ppmvi lupdecompose (vector&lt; vector&lt;double&gt; &gt; ori) {
	//P empty if singular

	int n = SZ(ori);
	vint permute(n,0);
	FORN(i,n) permute[i] = i;

	FORN(i,n) {
		//cari yang maximal
		int maxkoor = i;
		REP(j,i,n) if (fabs(ori[j][i]) &gt; fabs(ori[maxkoor][i])) maxkoor = j;
		if (fabs(ori[maxkoor][i]) &lt; EPS) {
			return MP( MP(vector&lt; vector&lt;db&gt; &gt;(), vector&lt; vector&lt;db&gt; &gt;()), vint());
			//singular
			}

		//tuker baris
		swap(permute[maxkoor],permute[i]);
		FORN(j,n) swap(ori[maxkoor][j],ori[i][j]);

		//bagi smua sama yg di atas si paling kiri
		REP(j,i+1,n) ori[j][i] /= ori[i][i];

		//sisa dikurang kalinya
		REP(j,i+1,n) REP(k,i+1,n) ori[j][k] -= ori[j][i] * ori[i][k];
		}

	vector&lt; vector&lt; db &gt; &gt; lower(n,vector&lt;db&gt;(n,0)),upper=lower;

	//bikin lower
	FORN(i,n) lower[i][i] = 1.0;
	FORN(i,n) FORN(j,i) lower[i][j] = ori[i][j];

	//bikin upper
	FORN(i,n) REP(j,i,n) upper[i][j] = ori[i][j];

	return MP(MP(lower,upper),permute);
	}

//VERIFIED
template &lt;class lups_&gt;
vector&lt;db&gt; lupsolve(vector&lt; vector&lt; db &gt; &gt; l, vector&lt; vector&lt; db &gt; &gt; u, vint p, vector&lt; lups_ &gt;  _b) {
	vector&lt; db &gt; b(SZ(_b),0);
	int n = SZ(l);
	FORN(i,n) b[i] = _b[p[i]];
	//cari Ux
	vint ux(n,0);
	FORN(i,n) {
		FORN(j,i) {
			b[i] -= l[i][j] * b[j];
			}
		}
	//cari x
	//Ux = b
	vector&lt; db &gt; ret(n,0);
	for (int i = n-1;i &gt;= 0;i--) {
		ret[i] = b[i];
		REP(j,i+1,n) ret[i] -= u[i][j] * ret[j];
		ret[i] /= u[i][i];
		}

	return ret;
	}</Snippet>		</Category>
		<Category Name="COMBINATORICS">
			<Category Name="DOUBLE">
				<Snippet Name="inverseFactorial">// calculates 1/(param!) in double
const int kInverseFactorialLimit = 200050;
double inverse_factorial_memo[kInverseFactorialLimit];
int inverse_factorial_init = 1;
double inverseFactorial(int param) {

  if (inverse_factorial_init) {
    inverse_factorial_init = 0;
    inverse_factorial_memo[0] = 1.0;
    for (int i = 1; i &lt; kInverseFactorialLimit; ++i) {
      inverse_factorial_memo[i] = inverse_factorial_memo[i-1] / (db)i;
    }
  }

  return inverse_factorial_memo[param];
}
// inverseFactorial(5) == 1.0 / 120.0</Snippet>				<Snippet Name="derangementProbability">// calculates the probability that a permutation amongst param no
// leaves no element in its correct position
const int kDerangementLimit = 200050;
db derangement_probability_memo[kDerangementLimit];
int derangement_probability_init = 1;
double derangementProbability(int param) {

  if (derangement_probability_init) {
    derangement_probability_init = 0;
    derangement_probability_memo[0] = 1.0;
    for (int i = 1; i &lt; kDerangementLimit; ++i) {
      derangement_probability_memo[i] =
          derangement_probability_memo[i-1] + ((i%2)?-1.0:1.0) *
          inverseFactorial(i);
    }
  }
  return derangement_probability_memo[param];
}
// derangementProbability(2) == 0.5</Snippet>			</Category>
			<Snippet Name="combination">ll dyn[1002][1002]; //a b jml dari a ambil b
int yesinitial = 1;
ll combination(ll people,ll need,ll modu = 1000000007LL * 1000000007LL) {
	if (yesinitial) {
		FORN(i,1002) FORN(j,1002) dyn[i][j] = -1LL;
		yesinitial = 0;
		}
	if (dyn[people][need] != -1LL) return dyn[people][need];
	if (need == 0) return 1LL;
	if (people == need) return 1LL;
	if (people &lt; need) return 0LL;
	dyn[people][need] = combination(people-1,need,modu) + combination(people-1,need-1,modu);
	dyn[people][need] %= modu;
	return dyn[people][need];
	}</Snippet>			<Snippet Name="FactorialWithLimit">int IsMultiplyOverflow (ll multiplicant1,ll multiplicant2,ll overflow_limit) {
	if (multiplicant2 == 0LL) return overflow_limit &lt; 0LL;
	return multiplicant1 &gt; overflow_limit/multiplicant2;
	}
//IsMultiplyOver(3,-5,16) == TRUE

ll Factorial (ll operand, ll upper_limit = (1LL &lt;&lt; 62LL)) {
	ll ret = 1LL;
	for (ll i = 1; i &lt;= operand; ++i) {
		if (IsMultiplyOverflow(ret, i, upper_limit)) return -1LL;
		ret *= i;
	}
	return ret;
}
//Factorial(5.300) == 240
//Factorial(5,100) == -1</Snippet>			<Snippet Name="XthPermutation">int IsMultiplyOverflow (ll multiplicant1,ll multiplicant2,ll overflow_limit) {
	if (multiplicant2 == 0LL) return overflow_limit &lt; 0LL;
	return multiplicant1 &gt; overflow_limit/multiplicant2;
	}
//IsMultiplyOver(3,-5,16) == TRUE

ll Factorial (ll operand, ll upper_limit = (1LL &lt;&lt; 62LL)) {
	ll ret = 1LL;
	for (ll i = 1; i &lt;= operand; ++i) {
		if (IsMultiplyOverflow(ret, i, upper_limit)) return -1LL;
		ret *= i;
	}
	return ret;
}
//Factorial(5.300) == 240
//Factorial(5,100) == -1

template &lt;class CDataType&gt;
vector&lt;CDataType&gt; Permute(vector&lt;CDataType&gt; input_vec, long long apply_number) {
	if (Factorial(SZ(input_vec), apply_number) != -1LL) apply_number %= Factorial(SZ(input_vec), apply_number);
	vector&lt;CDataType&gt; ret;
	int n = SZ(input_vec);
	for (int i = 0; i &lt; n; ++i) {
		//swap this element... with which element?
		ll f = Factorial(SZ(input_vec)-1, apply_number);
		if (f == -1LL) {
			ret.PB(input_vec[0]);
			input_vec.erase(input_vec.begin());
			continue;
		}
		for (int j = 1;;++j) if (apply_number &gt;= f) {
			apply_number -= f;
			continue;
		} else {
			ret.PB(input_vec[j-1]);
			input_vec.erase(input_vec.begin() + (j-1));
			break;
		}
	}
	return ret;
}
//vector&lt;sesuatu&gt; ret = Permute({1,2,3}, 2) == {3,1,2}
//vector&lt;sesuatu&gt; ret = Permute({1,2,3}, 18} == Permute({1,2,3}, 18 % (3!))</Snippet>			<Snippet Name="PermutationWithRepetitionCount">ll dyn[1002][1002]; //a b jml dari a ambil b
int yesinitial = 1;
ll combination(ll people,ll need) {
	if (yesinitial) {
		FORN(i,1002) FORN(j,1002) dyn[i][j] = -1LL;
		yesinitial = 0;
		}
	if (dyn[people][need] != -1LL) return dyn[people][need];
	if (need == 0) return 1LL;
	if (people == need) return 1LL;
	if (people &lt; need) return 0LL;
	dyn[people][need] = combination(people-1,need) + combination(people-1,need-1);
	return dyn[people][need];
	}

template &lt;class CDataType&gt;
ll PermutationWithRepetitionCount(vector&lt;CDataType&gt; occ_count) {
	ll n = 0;
	FORN(i,SZ(occ_count)) n += occ_count[i];
	ll ret = 1LL;
	FORN(i,SZ(occ_count)) {
		ret *= combination(n, occ_count[i]);
		n -= occ_count[i];
	}
	return ret;
}
//PermutationWithRepetitionCount({2,4,0,3}) == cara permutasi dengan 2 X, 4 Y, 0 Z, 3 A.
//O(SZ(vector))</Snippet>			<Snippet Name="FastCombination">//(number**exponent) % ivalue;
ll Power(ll number,ll exponent,ll ivalue) {
	ll ret = 1;
	ll multiplier = number;
	while (exponent &gt; 0LL) {
		if (exponent % 2LL) {
      ret = (ret * multiplier) % ivalue;
    }
		exponent /= 2LL;
		multiplier = (multiplier * multiplier) % ivalue;
  }
	return ret;
}

//works if modulo &gt;= 2
ll MultiplicativeInverse(ll number, ll ivalue) {
	return Power(number, ivalue - 2LL, ivalue);
}

ll FastCombination(ll from, ll pick, ll ivalue, bool reset = false) {
  static vector&lt;ll&gt; fact, rfact;
  if (reset) fact = rfact = vector&lt;ll&gt;(0);
  if (SZ(fact) == 0LL) {
    fact.PB(1LL);
    rfact.PB(1LL);
  }
  if (pick &gt; from) return 0LL;
  ll table_size = max(from, max(pick, from-pick));
  while (SZ(fact) &lt;= table_size) {
    fact.PB((fact.back() * (ll)SZ(fact)) % ivalue);
    rfact.PB(MultiplicativeInverse(fact.back(), ivalue));
  }
	ll jahja = (fact[from] * rfact[pick]) % ivalue;
  return (jahja * rfact[from-pick]) % ivalue;
}
// O(max(from, pick)).
// Assumes that ivalue will always be the same. To reset, use the
// reset flag.</Snippet>			<Snippet Name="Factorial">vector&lt;ll&gt; Factorial(ll number, ll ivalue) {
  vector&lt;ll&gt; factorial;
  factorial.PB(1LL);
  for (int i = 1; i &lt;= number; ++i) {
    factorial.PB((factorial.back() * (ll)i) % ivalue);
  }
  return factorial;
}
// vector&lt;ll&gt; fact = Factorial(4, 20);
// fact[3] == 6 % 20 == 6
// fact[4] == 24 % 20 == 4</Snippet>			<Snippet Name="InverseFactorial">//(number**exponent) % ivalue;
ll Power(ll number,ll exponent,ll ivalue) {
	ll ret = 1;
	ll multiplier = number;
	while (exponent &gt; 0LL) {
		if (exponent % 2LL) {
      ret = (ret * multiplier) % ivalue;
    }
		exponent /= 2LL;
		multiplier = (multiplier * multiplier) % ivalue;
  }
	return ret;
}

//works if modulo &gt;= 2
ll MultiplicativeInverse(ll number, ll ivalue) {
	return Power(number, ivalue - 2LL, ivalue);
}

vector&lt;ll&gt; Factorial(ll number, ll ivalue) {
  vector&lt;ll&gt; factorial;
  factorial.PB(1LL);
  for (int i = 1; i &lt;= number; ++i) {
    factorial.PB((factorial.back() * (ll)i) % ivalue);
  }
  return factorial;
}
// vector&lt;ll&gt; fact = Factorial(4, 20);
// fact[3] == 6 % 20 == 6
// fact[4] == 24 % 20 == 4

vector&lt;ll&gt; InverseFactorial(ll number, ll ivalue) {
  vector&lt;ll&gt; factorial = Factorial(number, ivalue);
  for (int i = 0; i &lt; SZ(factorial); ++i) {
    factorial[i] = MultiplicativeInverse(factorial[i], ivalue);
  }
  return factorial;
}
// vector&lt;ll&gt; inverse_fact = InverseFactorial(4, 7);
// assert(inverse_fact[i] * fact[i] === 1 mod 7);</Snippet>		</Category>
		<Category Name="DISCRETE">
			<Category Name="BINARY">
				<Snippet Name="get1s">template&lt;class a_type&gt; int get1s (a_type a) {
	int ans = 0;
	while (a &gt; (a_type)0) {
		if (a % (a_type)2) ans++;
		a /= (a_type)2;
		}
	return ans;
	}</Snippet>				<Snippet Name="CountLessThanOrEqualToLimit">class MemoizedNumberWithXOneBits {
  map&lt; pair&lt;int, ll&gt;, ll &gt; memo_;

 public:
  ll CountLessThanOrEqualToLimit(ll limit, int ones) {
    if (ones &lt; 0) return 0LL;
    if (limit == 0LL) {
      if (ones == 0LL) return 1LL;
      return 0LL;
    }
    pair&lt;int, ll&gt; key = MP(ones, limit);
    if (memo_.count(key)) return memo_[key];

    // largest mult of 2?
    ll mult = 1LL;
    while (mult * 2LL &lt;= limit) mult *= 2LL;

    ll res = CountLessThanOrEqualToLimit(limit - mult, ones-1);
    res += CountLessThanOrEqualToLimit(mult-1, ones);
    return memo_[key] = res;
  }
};</Snippet>			</Category>
			<Category Name="BASIC">
				<Snippet Name="MultiplicativeInverse">//(number**exponent) % ivalue;
ll Power(ll number,ll exponent,ll ivalue) {
	ll ret = 1;
	ll multiplier = number;
	while (exponent &gt; 0LL) {
		if (exponent % 2LL) {
      ret = (ret * multiplier) % ivalue;
    }
		exponent /= 2LL;
		multiplier = (multiplier * multiplier) % ivalue;
  }
	return ret;
}

//works if modulo &gt;= 2
ll MultiplicativeInverse(ll number, ll ivalue) {
	return Power(number, ivalue - 2LL, ivalue);
}</Snippet>				<Snippet Name="floor">int signum(ll num) {
  if (num &gt;&gt; 63LL) return -1;
  return num &gt; 0LL;
}

ll floor(ll numerator, ll denominator) {
  ll ret = numerator / denominator;
  if (signum(numerator) * signum(denominator) == -1LL) {
    if (numerator % denominator) --ret;
  }
  return ret;
}</Snippet>				<Snippet Name="signum">int signum(ll num) {
  if (num &gt;&gt; 63LL) return -1;
  return num &gt; 0LL;
}</Snippet>			</Category>
		</Category>
		<Category Name="LINEARPROGRAMMING">
			<Snippet Name="Gaussian">class Gaussian {
 public:
  Gaussian(int n_variables) : n_variables_(n_variables) {
    assert(n_variables &gt;= 0);
  }

  void AddEquation(vector&lt;double&gt; a, double b) {
    assert(SZ(a) == n_variables_);
    a_.PB(a);
    b_.PB(b);
  }

  vector&lt;double&gt; Solve(bool* is_infeasible, bool* is_multianswer) {
    *is_infeasible = false;
    *is_multianswer = false;

    int next_row = 0;
    FORN(i, n_variables_) {
      int nonzero_index = -1;
      REP(j, next_row, SZ(a_)) {
        if (abs(a_[j][i]) &lt; EPS) continue;
        if (nonzero_index == -1 ||
            abs(a_[j][nonzero_index]) + EPS &lt; abs(a_[j][i])) {
          nonzero_index = j;
        }
      }
      if (nonzero_index == -1) {
        // This variable is not good.
        *is_multianswer = true;
        continue;
      }

      a_[next_row].swap(a_[nonzero_index]);
      swap(a_[nonzero_index], b_[nonzero_index]);
      for (int j = next_row + 1; j &lt; SZ(a_); ++j) {
        db multiplier = a_[j][i] / a_[next_row][i];
        for (int k = i; k &lt; n_variables_; ++k) {
          a_[j][k] -= multiplier * a_[next_row][k];
        }
        b_[j] -= multiplier * b_[next_row];
      }

      ++next_row;

    }

    // check if any of the remaining rows cause inconsistency
    REP(i, next_row, SZ(a_)) {
      if (abs(b_[i]) &gt; EPS) {
        *is_infeasible = true;
        return vector&lt;double&gt;();
      }
    }

    vector&lt;db&gt; result(n_variables_, 0.0);

    // work bottom up now...
    for (int i = next_row - 1; i &gt;= 0; --i) {
      // find the leftmost non-zero
      int leftmost_nonzero = -1;
      for (int j = 0; j &lt; n_variables_; ++j) {
        if (abs(a_[i][j]) &gt;= EPS) {
          leftmost_nonzero = j;
          break;
        }
      }
      b_[i] /= a_[i][leftmost_nonzero];
      a_[i][leftmost_nonzero] /= a_[i][leftmost_nonzero];
      assert(leftmost_nonzero != -1);
      result[leftmost_nonzero] = b_[i];
      for (int j = i-1; j &gt;= 0; --j) {
        b_[j] -= a_[j][leftmost_nonzero] * b_[i];
        a_[j][leftmost_nonzero] = 0.0;
      }
    }

    return result;
  }

 private:
  int n_variables_;
  // Ax = b
  vector&lt; vector&lt;double&gt; &gt; a_;
  vector&lt;double&gt; b_;

  void Print() {
    FORN(i, SZ(a_)) {
      FORN(j, SZ(a_[i])) {
        printf(&quot;%.4lf &quot;, a_[i][j]);
      }
      printf(&quot;= %.4lf\n&quot;, b_[i]);
    }
  }
};

// Gaussian g(n_variables);

// a'x = b
// g.AddEquation(a, b)

// vector&lt;db&gt; x = g.Solve(is_infeasible, is_multianswer)
// O(n_variables^2 * n_equations)</Snippet>			<Snippet Name="XorEquations">class XorEquations {
 public:
  XorEquations(int number_of_coefficients)
      : n_(number_of_coefficients) {}
  
  // Modifiers indexed from 0.
  void AddModifier(vector&lt;int&gt; is_included) {
    assert(SZ(is_included) == n_);
    for (int i = 0; i &lt; SZ(is_included); ++i) {
      assert(is_included[i] == 0 || is_included[i] == 1);
    }
    modifiers_.PB(is_included);
  }
  
  // Returns an empty vector&lt;int&gt;() if impossible.
  vector&lt;int&gt; Solve(vector&lt;int&gt; target) {
    assert(SZ(target) == n_);
    
    vector&lt; vint &gt; mod = modifiers_;
    vector&lt; vint &gt; apply(SZ(mod), vint(SZ(mod), 0));
    vint chosentime(SZ(mod), -1);
    FORN(i, n_) apply[i][i] = 1;
    
    // Try to reduce mod
    FORN(i, n_) {
      // Find any '1' in this column
      int f = -1;
      FORN(j, SZ(mod)) if (mod[j][i] == 1 &amp;&amp; chosentime[j] == -1) {
        f = j;
        break;
      }
      
      if (f == -1) continue; // not found
      chosentime[f] = i;
      
      // Eliminate this '1' from all other rows
      FORN(j, SZ(mod)) if (j != f &amp;&amp; mod[j][i] == 1) {
        FORN(k, n_) mod[j][k] ^= mod[f][k];
        FORN(k, SZ(mod)) apply[j][k] ^= apply[f][k];
      }
    }
    
    vector&lt;int&gt; result(SZ(mod), 0);
    vector&lt;int&gt; state(n_, 0);
    FORN(i, n_) {
      if (state[i] == target[i]) continue;
      // Find a one here
      int f = -1;
      FORN(j, SZ(mod)) if (chosentime[j] == i) {
        f = j;
        break;
      }
      
      if (f == -1) {
        // Infeasible
        return vector&lt;int&gt;();
      }
      
      // Apply this one
      REP(j, i, n_) {
        if (j &lt; i) assert(mod[f][j] == 0);
        state[j] ^= mod[f][j];
      }
      
      FORN(j, SZ(mod)) result[j] ^= apply[f][j];
    }
    return result;
  }
  
 private:
  int n_;
  
  vector&lt; vint &gt; modifiers_;
};</Snippet>			<Snippet Name="LinearProgram">bool VectorDoubleLexicographicallySmaller(
    const vector&lt;db&gt;&amp; a, const vector&lt;db&gt;&amp; b) {
  FORN(i, SZ(a)) {
    if (a[i] + EPS &lt; b[i]) return 1;
    if (a[i] &gt; b[i] + EPS) return 0;
  }
  return 0;
}

bool ReducedVectorDoubleLexicographicallySmaller(
    vector&lt;db&gt; a, db multia, vector&lt;db&gt; b, db multib) {
  FORN(i, SZ(a)) a[i] /= multia;
  FORN(i, SZ(b)) b[i] /= multib;
  return VectorDoubleLexicographicallySmaller(a, b);
}

class LinearProgram {
 public:
  LinearProgram(int n_variables) : is_solved_(false),
                                   n_variables_(n_variables),
                                   is_x_non_negative_(false) {
    assert(n_variables &gt; 0);
  }

  void SetXNonNegative() {
    assert(is_x_non_negative_ == false);
    is_x_non_negative_ = true;
  }

  // maximize costs' * x
  void SetMaximizeCostFunction(vector&lt;double&gt; costs) {
    assert(SZ(costs) == n_variables_);
    assert(!is_solved_);
    // Negate all the costs, then minimize it
    for (size_t i = 0; i &lt; costs.size(); ++i) {
      costs[i] *= -1.0;
    }
    SetMinimizeCostFunction(costs);
  }

  // minimize costs' * x
  void SetMinimizeCostFunction(vector&lt;double&gt; costs) {
    assert(SZ(costs) == n_variables_);
    assert(!is_solved_);
    costs_ = costs;
  }

  // this must holds: a'x = b
  void AddEqualityConstraint(vector&lt;double&gt; a, double b) {
    assert(SZ(a) == n_variables_);
    assert(!is_solved_);
    equal_constraint_.push_back(make_pair(a, b));
  }

  // this must holds: a'x &lt;= b
  void AddLessThanOrEqualConstraint(vector&lt;double&gt; a, double b) {
    assert(SZ(a) == n_variables_);
    assert(!is_solved_);
    less_than_or_equal_constraint_.push_back(make_pair(a, b));
  }

  // this must holds: a'x &gt;= b
  void AddGreaterThanOrEqualConstraint(vector&lt;double&gt; a, double b) {
    assert(SZ(a) == n_variables_);
    assert(!is_solved_);
    // Negate both, then send to above method
    FORN(i, SZ(a)) a[i] *= -1.0;
    b *= -1.0;
    AddLessThanOrEqualConstraint(a, b);
  }

  // Returns vector&lt;double&gt; containing the elements of x that mades
  // up the optimal solution, or an empty vector if either of the
  // input flag is set.
  vector&lt;double&gt; Solve(bool* is_infeasible, bool* is_infinite) {
    *is_infinite = false;
    *is_infeasible = false;

    assert(SZ(costs_) != 0);
    assert(!is_solved_);

    is_solved_ = true;

    // First, we transform input into standard form
    // Which is easy! We just introduce slack variables
    FORN(i, SZ(less_than_or_equal_constraint_)) {
      // add a slack variable so that a &lt;= b becomes a + z = b
      costs_.PB(0.0);
      FORN(j, SZ(equal_constraint_)) equal_constraint_[j].A.PB(0.0);
      FORN(j, SZ(less_than_or_equal_constraint_)) {
        less_than_or_equal_constraint_[j].A.PB(0.0);
      }
      less_than_or_equal_constraint_[i].A.back() += 1.0;
      equal_constraint_.PB(less_than_or_equal_constraint_[i]);
    }

    // Next, we impose x&gt;=0 constraint to all variables
    vector&lt;int&gt; mapping; // We may permute it, we want to keep track
                          // of the correct order.
    FORN(i, SZ(costs_)) mapping.PB(i+1);

    if (!is_x_non_negative_) {
      FORN(i, n_variables_) {
        mapping.PB(-(i+1));
        costs_.PB(-costs_[i]);
        FORN(j, SZ(equal_constraint_)) {
          equal_constraint_[j].A.PB(equal_constraint_[j].A[i] * -1.0);
        }
      }
    }

    // Now, program is in standard form.
    // However, we want to make all bs positive
    FORN(i, SZ(equal_constraint_)) {
      if (equal_constraint_[i].B &lt; 0.0) {
        equal_constraint_[i].B *= -1.0;
        FORN(j, SZ(equal_constraint_[i].A)) {
          equal_constraint_[i].A[j] *= -1.0;
        }
      }
    }

    // Create a Tableau to look for the initial feasible solution
    vector&lt; vector&lt;double&gt; &gt; a;
    vector&lt;double&gt; b;
    FORN(i, SZ(equal_constraint_)) {
      b.PB(equal_constraint_[i].B);
      a.PB(equal_constraint_[i].A);
    }
    vector&lt; vector&lt;double&gt; &gt; tableau(
        SZ(a) + 1, vector&lt;double&gt;(SZ(costs_) + 1 + SZ(a)));

    // Fill the initial values of x
    FORN(i, SZ(a)) {
      tableau[i+1][0] = b[i];
      tableau[0][0] -= b[i];
    }

    // Fill the equation
    FORN(i, SZ(a)) FORN(j, SZ(a[i])) tableau[i+1][j+1] = a[i][j];

    // Fill the initial costs
    FORN(i, SZ(a[0])) {
      FORN(j, SZ(a)) {
        tableau[0][i+1] -= tableau[j+1][i+1];
      }
    }

    // We let the rest be identity
    FORN(i, SZ(a)) {
      tableau[i+1][SZ(a[0]) + 1 + i] = 1.0;
    }
    vector&lt;double&gt; bases;
    FORN(i, SZ(a)) {
      bases.PB(SZ(a[0]) + i);
    }

    bool is_infinite_feasibility;
    SolveTableau(&amp;tableau, &amp;bases, &amp;is_infinite_feasibility);
    assert(is_infinite_feasibility == false);

    // Check if the total cost not zero.
    if (abs(tableau[0][0]) &gt; EPS) {
      // infeasible
      *is_infeasible = true;
      return vector&lt;double&gt;();
    }

    // Marks which rows are meant to be discarded.
    vector&lt;bool&gt; redundant_rows(SZ(a), false);

    // Apply change of basis and/or discards redundant row.
    FORN(i, SZ(bases)) if (bases[i] &gt;= SZ(costs_)) {
      // artificial row
      // find the first non-zero row, then apply change of basis
      int nonzero_col_index = -1;
      FORN(j, SZ(tableau[0]) - 1) {
        if (abs(tableau[i+1][j+1]) &gt; EPS) {
          // Found
          nonzero_col_index = j;
          break;
        }
      }
      if (nonzero_col_index == -1 || nonzero_col_index &gt;= SZ(costs_)) {
        // this is a redundant information, we may discard it.
        redundant_rows[i] = true;
      } else {
        // apply change of basis
        bases[i] = nonzero_col_index;
        ApplyBasisChange(i, nonzero_col_index, &amp;tableau);
      }
    }

    // Remove all redundant rows
    for (int i = SZ(a) - 1; i &gt;= 0; --i) if (redundant_rows[i]) {
      a.erase(a.begin() + i);
      b.erase(b.begin() + i);
      bases.erase(bases.begin() + i);
      tableau.erase(tableau.begin() + i + 1);
    }

    // Finally, we create a new tableau
    vector&lt; vector&lt;double&gt; &gt; final_tableau(
        SZ(a) + 1, vector&lt;double&gt;(SZ(costs_) + 1));
    // First, copy from old tableau.
    FORN(i, SZ(a)+1) FORN(j, SZ(costs_)+1) {
      final_tableau[i][j] = tableau[i][j];
    }

    // Next, we rearrange the tableau so that the first m columns is
    // identity.
    FORN(i, SZ(costs_)) {
      int ok = 1;
      int one_pos = -1;
      FORN(j, SZ(a)) {
        if (abs(final_tableau[j+1][i+1] - 1.0) &lt; EPS) {
          // one
          if (one_pos != -1) {
            ok = 0;
            break;
          }
          one_pos = j;
        } else if (abs(final_tableau[j+1][i+1]) &lt; EPS) {
          // zero
          continue;
        } else {
          ok = 0;
          break;
        }
      }
      if (!ok) continue;
      if (one_pos == -1) continue;
      // put one_pos to its correct position, but we test if it's
      // already correct there.
      int already_correct = 1;
      FORN(j, SZ(a)) {
        if (j != one_pos) {
          if (abs(final_tableau[j+1][one_pos+1]) &gt;= EPS) {
            already_correct = 0;
            break;
          }
        } else if (abs(final_tableau[j+1][one_pos+1] - 1.0) &gt;= EPS) {
          already_correct = 0;
          break;
        }
      }
      if (already_correct) continue;
      swap(mapping[i], mapping[one_pos]);
      swap(costs_[i], costs_[one_pos]);
      FORN(j, SZ(a)+1) {
        swap(final_tableau[j][i+1], final_tableau[j][one_pos+1]);
      }
      FORN(j, SZ(bases)) {
        if (bases[j] == i) {
          bases[j] = one_pos;
        } else if (bases[j] == one_pos) {
          bases[j] = i;
        }
      }
      // repeat here.
      --i;
    }

    // Calculating the costs of the tableau.
    db total_cost_neg = 0.0;
    FORN(i, SZ(a)) {
      total_cost_neg -= costs_[bases[i]] * final_tableau[i+1][0];
    }

    final_tableau[0][0] = total_cost_neg;

    FORN(i, SZ(costs_)) {
      db total_cost_col = costs_[i];
      FORN(j, SZ(a)) {
        total_cost_col -= costs_[bases[j]] * final_tableau[j+1][i+1];
      }
      final_tableau[0][i+1] = total_cost_col;
    }

    SolveTableau(&amp;final_tableau, &amp;bases, is_infinite);

    if (*is_infinite) return vector&lt;double&gt;();

    // Constructing the returned vector.
    vector&lt;double&gt; return_value(n_variables_, 0.0);
    FORN(i, SZ(bases)) {
      int id = mapping[bases[i]];
      if (abs(id) &gt; n_variables_) {
        continue;
      }
      if (id &lt; 0) {
        // this is the part of x+ - x-, the - part
        return_value[-id - 1] -= final_tableau[i+1][0];
      } else {
        return_value[id - 1] += final_tableau[i+1][0];
      }
    }
    return return_value;
  }

 private:
  bool is_solved_;
  int n_variables_;
  bool is_x_non_negative_;

  // Input
  vector&lt;double&gt; costs_;
  vector&lt; pair&lt;vector&lt;double&gt;, double&gt; &gt; less_than_or_equal_constraint_;
  vector&lt; pair&lt;vector&lt;double&gt;, double&gt; &gt; equal_constraint_;

  void SolveTableau(vector&lt; vector&lt;double&gt; &gt;* tableau,
                    vector&lt;double&gt;* bases,
                    bool* is_infinite) {
    int neg_col = -1;
    REP(i, 1, SZ((*tableau)[0])) {
      if ((*tableau)[0][i] &lt; -EPS) {
        if (neg_col == -1 ||
            (*tableau)[0][i] + EPS &lt; (*tableau)[0][neg_col + 1]) {
          neg_col = i - 1;
        }
      }
    }

    if (neg_col == -1) {
      // all done.
      *is_infinite = false;
      return;
    }

    // Find the lexicographically smallest index that's minimal
    int mini_row = -1;
    double mini_row_value = 0.0;
    FORN(i, SZ((*tableau)) - 1) {
      if ((*tableau)[i+1][neg_col + 1] &gt; EPS) {
        double value = (*tableau)[i+1][0] / (*tableau)[i+1][neg_col + 1];
        if (mini_row == -1 || mini_row_value &gt; value + EPS ||
            (abs(mini_row_value - value) &lt;= EPS &amp;&amp;
                ReducedVectorDoubleLexicographicallySmaller(
                    (*tableau)[i+1],
                    (*tableau)[i+1][neg_col + 1],
                    (*tableau)[mini_row + 1],
                    (*tableau)[mini_row + 1][neg_col + 1]))) {
          mini_row = i;
          mini_row_value = value;
        }
      }
    }

    if (mini_row == -1) {
      // No limiting index found, hence an infinitely negative
      // constraint found.
      *is_infinite = true;
      return;
    }
    
    // Apply a change of basis between mini_row and neg_col
    (*bases)[mini_row] = neg_col;
    ApplyBasisChange(mini_row, neg_col, tableau);

    // Repeat
    SolveTableau(tableau, bases, is_infinite);
  }

  void ApplyBasisChange(int exiting_row, int entering_col,
                        vector&lt; vector&lt;double&gt; &gt;* tableau) {
    FORN(i, SZ(*tableau)) if (i != exiting_row + 1) {
      double value = (*tableau)[i][entering_col + 1] /
                     (*tableau)[exiting_row + 1][entering_col + 1];
      FORN(j, SZ((*tableau)[0])) {
        (*tableau)[i][j] -=
            value * (*tableau)[exiting_row + 1][j];
      }
    }

    // Turn the row into identity
    double dividend = (*tableau)[exiting_row + 1][entering_col + 1];
    FORN(i, SZ((*tableau)[0])) {
      (*tableau)[exiting_row + 1][i] /= dividend;
    }
  }

  void PrintTableau(const vector&lt; vector&lt;double&gt; &gt;&amp; tableau) {
    cout &lt;&lt; &quot;Tableau:\n&quot;;
    FORN(i, SZ(tableau)) {
      FORN(j, SZ(tableau[i])) {
        printf(&quot;%.5lf &quot;, tableau[i][j]);
      }
      cout &lt;&lt; endl;
    }
    cout &lt;&lt; &quot;EndOfTableau\n&quot;;
  }
};

// LinearProgram lp(number_of_variables);
// lp.SetXNonNegative(); // if X must never be negative

// coefficients to maximize/minimize
// lp.SetMaximizeCostFunction(vector&lt;db&gt;); OR lp.SetMinimizeCostFunction

// Ax = B
// lp.AddEqualityConstraint(vector&lt;db&gt; A, db B);
// Ax &lt;= B
// lp.AddLessThanOrEqualConstraint(A, B)
// Ax &gt;= B
// lp.AddGreaterThanOrEqualConstraint(A, B)

// x = lp.Solve(&amp;is_infeasible, &amp;is_infinity)</Snippet>		</Category>
		<Category Name="NUMBERTHEORY">
			<Category Name="PRIME">
				<Snippet Name="Sieve">//generate a true/false table containing abc elements. Element i is true if i is prime

vector&lt;int&gt; Sieve(int abc) {
	vector&lt;int&gt; sieveans;
	abc++;
	sieveans.reserve(abc);
	FORN(i,abc) sieveans.push_back(1);
	for (int i = 2;i * i &lt; abc;i = (i == 2)?3:(i + 2)) {
		for (int j = i + i;j &lt; abc;j += i) {
			sieveans[j] = 0;
			}
		}
	sieveans[0] = sieveans[1] = 0;
	return sieveans;
	}</Snippet>				<Snippet Name="GeneratePrime">vector&lt;int&gt; Sieve(int abc) {
	vector&lt;int&gt; sieveans;
	abc++;
	sieveans.reserve(abc);
	FORN(i,abc) sieveans.push_back(1);
	for (int i = 2;i * i &lt; abc;i = (i == 2)?3:(i + 2)) {
		for (int j = i + i;j &lt; abc;j += i) {
			sieveans[j] = 0;
			}
		}
	sieveans[0] = sieveans[1] = 0;
	return sieveans;
	}

//generate all prime number lower than or equal to abc;
vector&lt;int&gt; GeneratePrime(int abc) {
	vector&lt;int&gt; stable = Sieve(abc);
	vector&lt;int&gt; returnvalue;
	for (int i = 0;i &lt; stable.size();i++) {
		if (stable[i]) returnvalue.push_back(i);
		}
	return returnvalue;
	}</Snippet>				<Snippet Name="IsPrime">int IsPrime(ll number) {
  if (number &lt;= 1LL) return 0;
	for (ll i = 2LL;i * i &lt;= number;i = (i == 2LL ? 3LL : i + 2LL)) {
		if (number % i == 0LL) return 0;
		}
	return 1;
	}
//IsPrime(1) == 0</Snippet>			</Category>
			<Category Name="FACTORIZATION">
				<Snippet Name="GetDivisors">vector&lt; ll &gt; GetDivisors(long long number) {
	vector&lt;ll&gt; ret;
	for (ll i = 1; i &lt;= ceil(sqrt(number)); ++i) {
		if (number % i == 0) {
			ret.PB(i);
			ret.PB(number / i);
		}
	}
	sort(ALL(ret));
	ret.erase(unique(ALL(ret)), ret.end());
	return ret;
}
//vector&lt;ll&gt; divs = GetDivisors(6); {1,2,3,6} O(sqrt(N))</Snippet>				<Snippet Name="Factorize">vector&lt; pair&lt;ll,ll&gt; &gt; Factorize(ll number) {
  assert(number &gt;= 1LL);
  vector&lt; pair&lt;ll, ll&gt; &gt; ret;
  for (ll i = 2; i*i &lt;= number; i += (i==2)?1:2) {
    ll cnt = 0;
    while (number % i == 0LL) {
      number /= i;
      ++cnt;
    }
    if (cnt) ret.PB(MP(i, cnt));
  }
  if (number &gt; 1LL) {
    ret.PB(MP(number, 1LL));
  }
  return ret;
}</Snippet>				<Snippet Name="AmortizedFactorize">vector&lt;int&gt; Sieve(int abc) {
  vector&lt;int&gt; sieveans;
  abc++;
  sieveans.reserve(abc);
  FORN(i,abc) sieveans.push_back(1);
  for (int i = 2;i * i &lt; abc;i = (i == 2)?3:(i + 2)) {
    for (int j = i + i;j &lt; abc;j += i) {
      sieveans[j] = 0;
    }
  }
  sieveans[0] = sieveans[1] = 0;
  return sieveans;
}

//generate all prime number lower than or equal to abc;
vector&lt;int&gt; GeneratePrime(int abc) {
  vector&lt;int&gt; stable = Sieve(abc);
  vector&lt;int&gt; returnvalue;
  for (int i = 0;i &lt; (int)stable.size();i++) {
    if (stable[i]) returnvalue.push_back(i);
  }
  return returnvalue;
}

int kMaxPrimesGenerated = 1200000;
vector&lt; pair&lt;ll,ll&gt; &gt; AmortizedFactorize(ll number) {
  static vector&lt;int&gt; primes;
  if (SZ(primes) == 0) {
    primes = GeneratePrime(kMaxPrimesGenerated);
  }
  assert(number &gt;= 1LL);
  vector&lt; pair&lt;ll, ll&gt; &gt; ret;
  int done = 0;
  for (vector&lt;int&gt;::const_iterator it = primes.begin();
       it != primes.end(); ++it) {
    if (*it * *it &gt; number) {
      done = 1;
      break;
    }
    ll cnt = 0;
    while (number % *it == 0LL) {
      number /= *it;
      ++cnt;
    }
    if (cnt) ret.PB(MP(*it, cnt));
  }
  if (!done) {
    kMaxPrimesGenerated *= 2;
    primes = GeneratePrime(kMaxPrimesGenerated);
    return AmortizedFactorize(number);
  }
  if (number &gt; 1LL) {
    ret.PB(MP(number, 1LL));
  }
  return ret;
}</Snippet>			</Category>
			<Snippet Name="EulerTotientFunction">//Approx O(N log N)
vint EulerTotientFunction(int upper_limit) {

	//Sieve like
	++upper_limit;
	vint multiplier(upper_limit,-1);
	for (int i = 2; i &lt; upper_limit; ++i) {
		if (multiplier[i] != -1) continue;
		for (int j = i+i; j &lt; upper_limit; j += i) multiplier[j] = i;
	}

	//Calculate Euler Totient
	vint ret(upper_limit,0);
	ret[1] = 1;
	for (int i = 2; i &lt; upper_limit; ++i) {
		if (multiplier[i] == -1) {
			//prime
			ret[i] = i-1;
			continue;
		}
		int j = i / multiplier[i];
		int pangkat = 1;
		while ((j % multiplier[i]) == 0) {
			pangkat *= multiplier[i];
			j /= multiplier[i];
		}

		//sekarang udah coprime
		ret[i] = (multiplier[i]-1) * pangkat * ret[j];
	}
	return ret;
}

//vint a = EulerTotientFunction(4000000) //a[4,000,000] bisa, a[0] ga ada</Snippet>			<Snippet Name="Fibonacci">/*					MODIFIABLE					*/
ll iMatrixMultiply(ll multiplicant1, ll multiplicant2, ll ivalue = (ll)INF * (ll)INF) {
  return (multiplicant1 * multiplicant2) % ivalue;
	//return MultiplyWithLimit(multiplicant1, multiplicant2, ivalue);
}

ll iMatrixAdd(ll operand1, ll operand2, ll ivalue = (ll)INF * (ll)INF) {
  return (operand1 + operand2) % ivalue;
	//return min(operand1 + operand2, ivalue);
}
/*					END OF MODIFIABLE			*/

vector&lt; vector&lt;ll&gt; &gt; MatrixIdentity(int row_and_col) {
	vector&lt; vector&lt;ll&gt; &gt; ret = vector&lt; vector&lt;ll&gt; &gt;(row_and_col, vector&lt;ll&gt;(row_and_col, 0));
	FORN(i,row_and_col) ret[i][i] = 1LL;
	return ret;
}

vector&lt; vector&lt;ll&gt; &gt; MatrixMultiply(vector&lt; vector&lt;ll&gt; &gt; first_matrix, vector&lt; vector&lt;ll&gt; &gt; second_matrix, ll ivalue = (ll)INF * (ll)INF) {

	vector &lt;vector&lt;long long&gt; &gt; ret;
	if (first_matrix[0].size() != second_matrix.size()) printf(&quot;ukuran salah untuk perkalian. %d %d x %d %d\n&quot;,
			first_matrix.size(),first_matrix[0].size(),second_matrix.size(),second_matrix[0].size());
	FORN(i,SZ(first_matrix)) {
		vector&lt;long long&gt; ret_row_i;
		FORN(j,SZ(second_matrix[0])) {
			long long value = 0LL;
			FORN(k,SZ(second_matrix)) {
				value = iMatrixAdd(value, iMatrixMultiply(first_matrix[i][k], second_matrix[k][j], ivalue), ivalue);
				}
			ret_row_i.PB(value);
			}
		ret.PB(ret_row_i);
		}
	return ret;
	}
//vector&lt; vector&lt;ll&gt; &gt; matrix = MatrixMultiply(matrix1, matrix2, ivalue);

vector&lt; vector&lt;long long&gt; &gt; MatrixPower(vector&lt; vector&lt;long long&gt; &gt; matrix,long long pangkat,long long ivalue = (ll)INF * (ll)INF) {
	vector&lt; vector&lt;long long&gt; &gt; ret = MatrixIdentity(SZ(matrix));
	while (pangkat &gt; 0LL) {
		if (pangkat % 2LL) {
			ret = MatrixMultiply(ret, matrix, ivalue);
			}
		pangkat /= 2LL;
		matrix = MatrixMultiply(matrix, matrix, ivalue);
		}
	return ret;
	}
//vector&lt; vector&lt;ll&gt; &gt; matrix = MatrixPower(matrix1, pangkatnya, ivalue);

vector&lt; ll &gt; MatrixPowerSolver(vector&lt; vector&lt; ll &gt; &gt; matrix, ll pangkat, vector&lt;ll&gt; operand_vector, ll ivalue = (ll)INF * (ll)INF) {
	vector&lt; vector&lt; ll &gt; &gt; parsed_operand_vector(SZ(operand_vector), vector&lt;ll&gt;(1,0));
	FORN(i, SZ(operand_vector)) parsed_operand_vector[i][0] = operand_vector[i];
	vector&lt; vector&lt; ll &gt; &gt; unparsed_ret = MatrixMultiply(MatrixPower(matrix, pangkat, ivalue), parsed_operand_vector, ivalue);
	vector&lt; ll &gt; ret(SZ(unparsed_ret),0);
	FORN(i,SZ(unparsed_ret)) ret[i] = unparsed_ret[i][0];
	return ret;
}

//rubah modifiable
//vector&lt; vector&lt;ll&gt; &gt; matrix; //matrix[i][j] -&gt; kontribusi j buat i.
//vector&lt;ll&gt; init_vector; //vector awal
//vector&lt;ll&gt; hasil_akhir = MatrixPowerSolver(matrix, pangkatnya, init_vector, ivalue);

ll Fibonacci(ll x, ll ivalue = (ll)INF * (ll)INF) {
  if (x == 0) return 0 % ivalue;
  if (x == 1) return 1 % ivalue;
  if (x == 2) return 1 % ivalue;

  vector&lt; vector&lt; ll &gt; &gt; matrix(2, vector&lt;ll&gt;(2));
  // 0 tu fibo[x-1]
  // 1 tu fibo[x]

  matrix[0][0] = 0LL;
  matrix[0][1] = 1LL;
  matrix[1][0] = 1LL;
  matrix[1][1] = 1LL;

  vector&lt;ll&gt; init(2);
  init[0] = 0;
  init[1] = 1;

  vector&lt;ll&gt; hasil = MatrixPowerSolver(matrix, x-1, init, ivalue);
  return hasil[1];
}
// 0-indexed :
// 0 1 1 2 3 5 8 ...</Snippet>			<Snippet Name="GreatestCommonDivisor">ll GreatestCommonDivisor(ll abc,ll def) {
  if (abc &lt; 0LL || def &lt; 0LL) return GreatestCommonDivisor(abs(abc), abs(def));
	if (abc &lt; def) return GreatestCommonDivisor(def,abc);
	if (!def) return abc;
	return GreatestCommonDivisor(def,abc % def);
}</Snippet>			<Snippet Name="lcm">ll gcd(ll abc,ll def) {
	if (abc &lt; def) return gcd(def,abc);
	if (!def) return abc;
	return gcd(def,abc % def);
	}

ll lcm(ll abc,ll def) {
	return (abc * def / gcd(abc,def));
	}</Snippet>			<Snippet Name="MultiplicativeInverseEuclid">// returns a pair&lt;x,y&gt; where ax + by = gcd(a, b)
// both |x| and |y| &lt;= max(a, b)
pair&lt;long long, long long&gt; ExtendedEuclid(long long a, long long b) {
  ll original_a = a, original_b = b;
  a = abs(a); b = abs(b);
  int swapped = 0;
  if (a &lt; b) {
    swap(a, b);
    swapped = 1;
  }
  if (b == 0LL) {
  	if (swapped) return MP(0LL, 1LL);
  	return MP(1LL, 0LL);
  }

  ll s0 = 1LL, s1 = 0LL, t0 = 0LL, t1 = 1LL;
  ll r0 = a, r1 = b;

  while (true) {
    ll q = r0 / r1;
    ll r2 = r0 % r1;
    if (r2 == 0LL) {
      // stop, return the last value
      if (original_a &lt; 0LL) {
        if (swapped) t1 *= -1LL; else s1 *= -1LL;
      }
      if (original_b &lt; 0LL) {
        if (swapped) s1 *= -1LL; else t1 *= -1LL;
      }
      if (swapped) return MP(t1, s1); else return MP(s1, t1);
    }
    // advance
    ll s2 = s0 - q * s1;
    ll t2 = t0 - q * t1;
    s0 = s1; s1 = s2;
    t0 = t1; t1 = t2;
    r0 = r1; r1 = r2;
  }
}
// ExtendedEuclid(-15, 25) == MP(2, 1)

// retrieves X such that (number*x) % field = 1. field must be
// relatively prime to number
// both parameters positive
ll MultiplicativeInverseEuclid(ll number, ll field) {
  pair&lt;ll, ll&gt; euclid = ExtendedEuclid(number%field, field);
  return (euclid.first + field) % field;
}
// MultiplicativeInverseEuclid(5, 17) == 7 ((5*7=35)%17=1)</Snippet>			<Snippet Name="ExtendedEuclid">// returns a pair&lt;x,y&gt; where ax + by = gcd(a, b)
// both |x| and |y| &lt;= max(a, b)
pair&lt;long long, long long&gt; ExtendedEuclid(long long a, long long b) {
  ll original_a = a, original_b = b;
  a = abs(a); b = abs(b);
  int swapped = 0;
  if (a &lt; b) {
    swap(a, b);
    swapped = 1;
  }
  if (b == 0LL) return MP(1LL, 0LL);

  ll s0 = 1LL, s1 = 0LL, t0 = 0LL, t1 = 1LL;
  ll r0 = a, r1 = b;

  while (true) {
    ll q = r0 / r1;
    ll r2 = r0 % r1;
    if (r2 == 0LL) {
      // stop, return the last value
      if (original_a &lt; 0LL) {
        if (swapped) t1 *= -1LL; else s1 *= -1LL;
      }
      if (original_b &lt; 0LL) {
        if (swapped) s1 *= -1LL; else t1 *= -1LL;
      }
      if (swapped) return MP(t1, s1); else return MP(s1, t1);
    }
    // advance
    ll s2 = s0 - q * s1;
    ll t2 = t0 - q * t1;
    s0 = s1; s1 = s2;
    t0 = t1; t1 = t2;
    r0 = r1; r1 = r2;
  }
}
// ExtendedEuclid(-15, 25) == MP(2, 1)</Snippet>			<Snippet Name="GreatestCommonDivisorVector">ll GreatestCommonDivisor(ll abc,ll def) {
  if (abc &lt; 0LL || def &lt; 0LL) return GreatestCommonDivisor(abs(abc), abs(def));
	if (abc &lt; def) return GreatestCommonDivisor(def,abc);
	if (!def) return abc;
	return GreatestCommonDivisor(def,abc % def);
}

template &lt;class CData&gt;
ll GreatestCommonDivisorVector(vector&lt;CData&gt; numbers) {
  ll num = abs(numbers[0]);
  for (int i = 1; i &lt; SZ(numbers); ++i) {
    if (num == 1LL) return num;
    num = GreatestCommonDivisor(num, (ll)numbers[i]);
  }
  return num;
}</Snippet>			<Snippet Name="ChineseRemainderTheorem">ll gcd(ll abc,ll def) {
	if (abc &lt; def) return gcd(def,abc);
	if (!def) return abc;
	return gcd(def,abc % def);
	}

ll lcm(ll abc,ll def) {
	return (abc * def / gcd(abc,def));
	}

// returns a pair&lt;x,y&gt; where ax + by = gcd(a, b)
// both |x| and |y| &lt;= max(a, b)
pair&lt;long long, long long&gt; ExtendedEuclid(long long a, long long b) {
  ll original_a = a, original_b = b;
  a = abs(a); b = abs(b);
  int swapped = 0;
  if (a &lt; b) {
    swap(a, b);
    swapped = 1;
  }
  if (b == 0LL) return MP(1LL, 0LL);

  ll s0 = 1LL, s1 = 0LL, t0 = 0LL, t1 = 1LL;
  ll r0 = a, r1 = b;

  while (true) {
    ll q = r0 / r1;
    ll r2 = r0 % r1;
    if (r2 == 0LL) {
      // stop, return the last value
      if (original_a &lt; 0LL) {
        if (swapped) t1 *= -1LL; else s1 *= -1LL;
      }
      if (original_b &lt; 0LL) {
        if (swapped) s1 *= -1LL; else t1 *= -1LL;
      }
      if (swapped) return MP(t1, s1); else return MP(s1, t1);
    }
    // advance
    ll s2 = s0 - q * s1;
    ll t2 = t0 - q * t1;
    s0 = s1; s1 = s2;
    t0 = t1; t1 = t2;
    r0 = r1; r1 = r2;
  }
}
// ExtendedEuclid(-15, 25) == MP(2, 1)

// Find integer X &lt; lcm_{modulo}
// such that for every i, X % modulo[i] = remainders[i]
// modulo positive pairwise distinct

// If no such integer exists, return -1
ll ChineseRemainderTheorem(const vector&lt;ll&gt;&amp; remainders, const vector&lt;ll&gt;&amp; modulo) {
  
  FORN(i, SZ(remainders)) assert(modulo[i] &gt; 0);
  FORN(i, SZ(remainders)) assert(remainders[i] &lt; modulo[i]);
  
  ll modu = 1LL;
  FORIT(it, modulo) modu = lcm(modu, *it);
  
  // check existence
  FORN(i, SZ(remainders)) REP(j, i+1, SZ(remainders)) {
    ll g = gcd(modulo[i], modulo[j]);
    if (remainders[i] % g != remainders[j] % g) return -1LL;
  }
  
  ll res = 0LL;
  FORN(i, SZ(remainders)) {
    ll g = gcd(modulo[i], modu / modulo[i]);
    pair&lt;ll, ll&gt; ee = ExtendedEuclid(modulo[i] / g, modu / (modulo[i] / g));
    assert(ee.A * modulo[i] / g + ee.B * modu / (modulo[i] / g) == 1LL);
    
    ee.B %= modu;
    while (ee.B &lt; 0LL) ee.B += modu;
    
    ll addum = remainders[i] * ((ee.B * (modu / (modulo[i] / g))) % modu);
    addum %= modu;
    res += addum;
    res %= modu;
  }
  
  // check
  FORN(i, SZ(remainders)) assert(res % modulo[i] == remainders[i]);
  return res;
}
// vector&lt;ll&gt; remainders = {3, 5, 7}
// vector&lt;ll&gt; moduli = {4, 6, 11}
// x = ChineseRemainderTheorem(remainders, moduli)
// assert(x % 4 == 3, x % 6 == 5, x % 11 == 7)
// 0 &lt;= x &lt; lcm{4, 6, 11}
// or, if x=-1, means no such x exists</Snippet>		</Category>
		<Category Name="BASIC">
			<Category Name="POWER">
				<Snippet Name="ptable">vector&lt; ll &gt; ptable(ll angka,ll maxpangkat,ll modu = -1LL) {
	vector&lt; ll &gt; retp;
	retp.PB(1LL);
	if (modu == -1LL)
	FORN(i,maxpangkat) retp.PB(retp[SZ(retp)-1] * angka);
	if (modu != -1LL)
	FORN(i,maxpangkat) retp.PB((retp[SZ(retp)-1] * angka) % modu);
	return retp;
	}

/*
vector&lt; ll &gt; p10 = ptable(10,18);
*/</Snippet>				<Snippet Name="P2">ll P2(ll abc) {
  static int p2_global_init = 0;
  static ll p2[63];
  if (!p2_global_init) {
    p2_global_init = 1;
    p2[0] = 1LL;
    REP(i,1,63) p2[i] = p2[i-1] * 2LL;
  }
  return p2[abc];
}</Snippet>				<Snippet Name="P3">ll P3(ll abc) {
  static int p3_global_init = 0;
  static ll p3[40];
  if (!p3_global_init) {
    p3_global_init = 1;
    p3[0] = 1LL;
    REP(i,1,40) p3[i] = p3[i-1] * 3LL;
  }
  return p3[abc];
}</Snippet>				<Snippet Name="P10">ll P10(ll abc) {
  static int p10_global_init = 0;
  static ll p10[20];
  if (!p10_global_init) {
    p10_global_init = 1;
    p10[0] = 1LL;
    REP(i,1,19) p10[i] = p10[i-1] * 10LL;
  }
  return p10[abc];
}
</Snippet>				<Snippet Name="Power">//(number**exponent) % ivalue;
ll Power(ll number,ll exponent,ll ivalue) {
	ll ret = 1;
	ll multiplier = number;
	while (exponent &gt; 0LL) {
		if (exponent % 2LL) {
      ret = (ret * multiplier) % ivalue;
    }
		exponent /= 2LL;
		multiplier = (multiplier * multiplier) % ivalue;
  }
	return ret;
}</Snippet>			</Category>
			<Snippet Name="IsMultiplyOverflow">int IsMultiplyOverflow (ll multiplicant1,ll multiplicant2,ll overflow_limit) {
	if (multiplicant2 == 0LL) return overflow_limit &lt; 0LL;
	return multiplicant1 &gt; overflow_limit/multiplicant2;
	}
//IsMultiplyOver(3,-5,16) == TRUE</Snippet>			<Snippet Name="MultiplyWithLimit">
int IsMultiplyOverflow (ll multiplicant1,ll multiplicant2,ll overflow_limit) {
	if (multiplicant2 == 0LL) return overflow_limit &lt; 0LL;
	return multiplicant1 &gt; overflow_limit/multiplicant2;
	}
//IsMultiplyOver(3,-5,16) == TRUE

ll MultiplyWithLimit (ll multiplicant1, ll multiplicant2, ll overflow_limit) {
	if (multiplicant2 == 0LL) return 0LL;
	if (IsMultiplyOverflow(abs(multiplicant1), abs(multiplicant2), overflow_limit)) return (multiplicant1 / abs(multiplicant1)) * (multiplicant2 / abs(multiplicant2)) * overflow_limit;
	return multiplicant1 * multiplicant2;
}
//MultiplyWithLimit(3,-5,14) == -14</Snippet>			<Snippet Name="GetDigits">vector&lt;ll&gt; GetDigits(ll number) {
  if (number == 0LL) return vector&lt;ll&gt;(0);
  vector&lt;ll&gt; ret;
  while (number) {
    ret.PB(number%10LL);
    number /= 10LL;
  }
  reverse(ALL(ret));
  return ret;
}
//GetDigits(123) = {1,2,3}</Snippet>			<Snippet Name="LargeMultiplyModulo">ll MultRec(ll a, ll b, ll modu) {
  if (a == 0LL) return 0LL;
  if (a % 2LL == 0LL) return (2LL * MultRec(a/2, b, modu)) % modu;
  return (b + MultRec(a-1, b, modu)) % modu;
}

ll Mult(ll a, ll b, ll modu) {
  a %= modu;
  b %= modu;
  ll v = MultRec(abs(a), abs(b), modu);
  if (a &lt; 0LL) v *= -1LL;
  if (b &lt; 0LL) v *= -1LL;
  while (v &lt; 0LL) v += modu;
  return v;
}</Snippet>		</Category>
		<Category Name="FRACTION">
			<Snippet Name="FractionToDecimal">template&lt;class cType&gt;
pair&lt;string,string&gt; FractionToDecimal( pair&lt;cType, cType&gt; fraction) {
  fraction.A %= fraction.B;
  vint sudah(fraction.B,0);
  string jalan;
  vint memo_jalan;
  while (!sudah[fraction.A]) {
    sudah[fraction.A] = 1;
    memo_jalan.PB(fraction.A);
    fraction.A *= 10LL;
    jalan.PB('0' + (fraction.A / fraction.B));
    fraction.A %= fraction.B;
  }
  for (int i = SZ(jalan)-1; i &gt;= 0; --i) {
    if (memo_jalan[i] == fraction.A) {
      //okay dari sini sampe belakang adalah itunya
      return MP(jalan.substr(0, i), jalan.substr(i, INF));
    }
  }
}
//depan, repeat
//FractionToDecimal(MP(1,6)) == {&quot;1&quot;,&quot;6&quot;}
//FractionToDecimal(MP(1,8)) == {&quot;125&quot;,&quot;0&quot;}</Snippet>			<Snippet Name="FractionMultiply">ll GreatestCommonDivisor(ll abc,ll def) {
	if (abc &lt; def) return GreatestCommonDivisor(def,abc);
	if (!def) return abc;
	return GreatestCommonDivisor(def,abc % def);
	}

pair&lt;ll, ll&gt; FractionMultiply(pair&lt;ll, ll&gt; fraction1, pair&lt;ll, ll&gt; fraction2) {
  pair&lt;ll, ll&gt; ret = MP(fraction1.A * fraction2.A, fraction1.B * fraction2.B);
  ll divisor = GreatestCommonDivisor(ret.A, ret.B);
  ret = MP(ret.A / divisor, ret.B / divisor);
  return ret;
}
</Snippet>		</Category>
		<Category Name="POLYNOM">
			<Snippet Name="ModularInterpolation[LAGRANGE]">//(number**exponent) % ivalue;
ll Power(ll number,ll exponent,ll ivalue) {
	ll ret = 1;
	ll multiplier = number;
	while (exponent &gt; 0LL) {
		if (exponent % 2LL) {
      ret = (ret * multiplier) % ivalue;
    }
		exponent /= 2LL;
		multiplier = (multiplier * multiplier) % ivalue;
  }
	return ret;
}

//works if modulo &gt;= 2
ll MultiplicativeInverse(ll number, ll ivalue) {
	return Power(number, ivalue - 2LL, ivalue);
}

class ModularInterpolation {
 public:
  ModularInterpolation(const long long&amp; modu) : modu_(modu), x_(0), y_(0) {}
  
  void AddCoef(long long x, long long y) {
    x %= modu_;
    if (x &lt; 0LL) x += modu_;
    x_.push_back(x);
    
    y %= modu_;
    if (y &lt; 0LL) y += modu_;
    y_.push_back(y);
  }
  
  long long Interpolate(long long x) {
    x %= modu_;
    if (x &lt; 0LL) x += modu_;
    
    for (int i = 0; i &lt; SZ(x_); ++i) if (x_[i] == x) return y_[i];
    
    // The very standard Lagrange
    long long value = 0LL;
    for (int i = 0; i &lt; SZ(x_); ++i) {
      long long addum = y_[i];
      for (int j = 0; j &lt; SZ(x_); ++j) if (j != i) {
        long long delta1 = (x - x_[j] + modu_) % modu_;
        long long delta2 = (x_[i] - x_[j] + modu_) % modu_;
        addum = (addum * delta1) % modu_;
        addum = (addum * MultiplicativeInverse(delta2, modu_)) % modu_;
      }
      value += addum;
      value %= modu_;
    }
    
    return value;
  }
        
  const long long modu_;
  vector&lt;long long&gt; x_;
  vector&lt;long long&gt; y_;
};</Snippet>			<Snippet Name="FFT">const double PI  = 3.141592653589793238462;

// all complex are (real, imaginary)

pair&lt;db, db&gt; ComplexMultiply(const pair&lt;db, db&gt; complex_a, const pair&lt;db, db&gt; complex_b) {
  return MP(complex_a.A * complex_b.A - complex_a.B * complex_b.B, complex_a.A * complex_b.B + complex_a.B * complex_b.A);
}

pair&lt;db, db&gt; ComplexAdd(const pair&lt;db, db&gt; complex_a, const pair&lt;db, db&gt; complex_b) {
  return MP(complex_a.A + complex_b.A, complex_a.B + complex_b.B);
}

vector&lt; pair&lt;db, db&gt; &gt; IterativeDFT(const vector&lt; pair&lt;db, db&gt; &gt;&amp; seq, int direction) {
  assert(!(SZ(seq) &amp; (SZ(seq)-1)));
  pair&lt;db, db&gt;* placeholder = new pair&lt;db, db&gt;[SZ(seq)];
  pair&lt;db, db&gt;* tmp = new pair&lt;db, db&gt;[SZ(seq)];
  int n = SZ(seq);
  int bits = 0;
  int tmp_n = n;
  while (tmp_n &gt; 1) {
    ++bits;
    tmp_n /= 2;
  }

  FORN(i, n) {
    // reverse bit
    int res = 0;
    int tmp_i = i;
    FORN(j, bits) {
      if (tmp_i%2) {
        res += (1 &lt;&lt; (bits-j-1));
      }
      tmp_i /= 2;
    }
    placeholder[i] = seq[res];
  }

  // perform computation
  for (int comp_size = 2; comp_size &lt;= n; comp_size *= 2) {
    for (int j = 0; j &lt; n; j += comp_size) {
      int n_mem = comp_size/2;
      double w_mult_exp_i = 2.0 * PI / (db)comp_size;
      if (!direction) w_mult_exp_i *= -1.0;
      pair&lt;db, db&gt; w_mult = MP(cos(w_mult_exp_i), sin(w_mult_exp_i));
      pair&lt;db, db&gt; w = MP(1.0, 0.0);
      for (int k = 0; k &lt; comp_size; ++k) {
        int idx = k % (n_mem);
        tmp[k] = ComplexAdd(placeholder[j+idx], ComplexMultiply(w, placeholder[j+n_mem+idx]));
        w = ComplexMultiply(w, w_mult);
      }
      for (int k = 0; k &lt; comp_size; ++k) {
        placeholder[j+k] = tmp[k];
      }
    }
  }

  // copy result
  vector&lt; pair&lt;db, db&gt; &gt; result;
  for (int i = 0; i &lt; n; ++i) {
    result.PB(placeholder[i]);
  }

  delete[] placeholder;
  delete[] tmp;
  return result;
}

vector&lt;double&gt; FFT(vector&lt;double&gt; a, vector&lt;double&gt; b) {
  // Computes the product of the two vectors in O(N log N).
  // FFT(N, M) results in a vector&lt;ll&gt; containing N+M-1 elements.
  if (SZ(a) == 0) a.PB(0);
  if (SZ(b) == 0) b.PB(0);
  int n_final_elements = SZ(a) + SZ(b) - 1;
  // pad them
  int actual_size = 1;
  while (actual_size &lt; max(SZ(a), SZ(b))) {
    actual_size *= 2;
  }
  actual_size *= 2;
  while (SZ(a) &lt; actual_size) a.PB(0);
  while (SZ(b) &lt; actual_size) b.PB(0);

  vector&lt; pair&lt; db, db &gt; &gt; dft_input_a, dft_input_b;
  FORN(i, actual_size) {
    dft_input_a.PB(MP(a[i], 0.0));
    dft_input_b.PB(MP(b[i], 0.0));
  }

  dft_input_a = IterativeDFT(dft_input_a, 1);
  dft_input_b = IterativeDFT(dft_input_b, 1);
  FORN(i, actual_size) dft_input_a[i] = ComplexMultiply(dft_input_a[i], dft_input_b[i]);
  dft_input_a = IterativeDFT(dft_input_a, 0);

  // strip the imaginary part
  vector&lt;db&gt; res;
  FORN(i, n_final_elements) {
    res.PB(dft_input_a[i].A / (db)actual_size);
  }
  return res;
}
// FFT({1, 2, 3}, {4, 5})
// coefficienrs of 3+2x+x^2 + 4+5x (given in rev order).

// WARNING: Very memory expensive -- with 1 million instance it took 256 MB.</Snippet>		</Category>
		<Category Name="INTERVAL">
			<Snippet Name="IntervalOverlap">int IntervalOverlap(int a1, int b1, int a2, int b2) {
  if (a1 &lt;= a2 &amp;&amp; b1 &gt; a2) return 1;
  if (a2 &lt;= a1 &amp;&amp; b2 &gt; a1) return 1;
  return 0;
}</Snippet>		</Category>
	</Category>
	<Category Name="DATASTRUCTURE">
		<Category Name="BINARYTREE">
			<Category Name="BST">
				<Snippet Name="RedBlackTree">template &lt;class CValue&gt;
class RedBlackTree {
 public:
  RedBlackTree() {root_ = new Node();}
  ~RedBlackTree() {delete root_;}
  void Insert(const CValue in_value);
  CValue FindKth(int k) const;
  int size();

 private:
  struct Node;
  Node* root_;
  void LeftRotate(Node* x);
  void RightRotate(Node* x);
  void InsertFixup(Node* z);
  CValue FindKth(int k, Node* z) const;
};

template &lt;class CValue&gt;
struct RedBlackTree&lt;CValue&gt;::Node {
  Node(CValue value) {
    value_ = value;
    parent_ = 0;
    left_ = new Node();
    right_ = new Node();
    nil_ = 0;
    ncount_ = 1;
    red_ = 1;
  }
  Node() {
    left_ = right_ = parent_ = 0;
    nil_ = 1;
    red_ = 0;
    ncount_ = 0;
  }
  ~Node() {
    if (left_) delete left_;
    if (right_) delete right_;
  }
  Node* left_;
  Node* right_;
  Node* parent_;
  CValue value_;
  int ncount_;
  bool nil_;
  bool red_;
};

template &lt;class CValue&gt;
void RedBlackTree&lt;CValue&gt;::LeftRotate(Node* x) {
  Node* y = x-&gt;right_;
  x-&gt;right_ = y-&gt;left_;
  (y-&gt;left_)-&gt;parent_ = x;
  y-&gt;parent_ = x-&gt;parent_;
  if (x-&gt;parent_ == 0) {
    root_ = y;
  } else {
    if (x == (x-&gt;parent_)-&gt;left_) {
      (x-&gt;parent_)-&gt;left_ = y;
    } else {
      (x-&gt;parent_)-&gt;right_ = y;
    }
  }
  y-&gt;left_ = x;
  x-&gt;parent_ = y;
  x-&gt;ncount_ = 1 + (x-&gt;left_)-&gt;ncount_ + (x-&gt;right_)-&gt;ncount_;
  y-&gt;ncount_ = 1 + (y-&gt;left_)-&gt;ncount_ + (y-&gt;right_)-&gt;ncount_;
}

template &lt;class CValue&gt;
void RedBlackTree&lt;CValue&gt;::RightRotate(Node* x) {
  Node* y = x-&gt;left_;
  x-&gt;left_ = y-&gt;right_;
  (y-&gt;right_)-&gt;parent_ = x;
  y-&gt;parent_ = x-&gt;parent_;
  if (x-&gt;parent_ == 0) {
    root_ = y;
  } else {
    if (x == (x-&gt;parent_)-&gt;right_) {
      (x-&gt;parent_)-&gt;right_ = y;
    } else {
      (x-&gt;parent_)-&gt;left_ = y;
    }
  }
  y-&gt;right_ = x;
  x-&gt;parent_ = y;
  x-&gt;ncount_ = 1 + (x-&gt;left_)-&gt;ncount_ + (x-&gt;right_)-&gt;ncount_;
  y-&gt;ncount_ = 1 + (y-&gt;left_)-&gt;ncount_ + (y-&gt;right_)-&gt;ncount_;
}

template &lt;class CValue&gt;
void RedBlackTree&lt;CValue&gt;::InsertFixup(Node* z) {
  while (z-&gt;parent_ &amp;&amp; (z-&gt;parent_)-&gt;parent_ &amp;&amp; (z-&gt;parent_)-&gt;red_) {
    if (z-&gt;parent_ == ((z-&gt;parent_)-&gt;parent_)-&gt;left_) {
      Node* y = ((z-&gt;parent_)-&gt;parent_)-&gt;right_;
      if (y-&gt;red_) {
        (z-&gt;parent_)-&gt;red_ = 0;
        (y-&gt;red_) = 0;
        ((z-&gt;parent_)-&gt;parent_)-&gt;red_ = 1;
        z = (z-&gt;parent_)-&gt;parent_;
      } else {
        if (z == (z-&gt;parent_)-&gt;right_) {
          z = (z-&gt;parent_);
          LeftRotate(z);
        }
        (z-&gt;parent_)-&gt;red_ = 0;
        ((z-&gt;parent_)-&gt;parent_)-&gt;red_ = 1;
        RightRotate((z-&gt;parent_)-&gt;parent_);
      }
    } else {
      Node* y = ((z-&gt;parent_)-&gt;parent_)-&gt;left_;
      if (y-&gt;red_) {
        (z-&gt;parent_)-&gt;red_ = 0;
        (y-&gt;red_) = 0;
        ((z-&gt;parent_)-&gt;parent_)-&gt;red_ = 1;
        z = (z-&gt;parent_)-&gt;parent_;
      } else {
        if (z == (z-&gt;parent_)-&gt;left_) {
          z = (z-&gt;parent_);
          RightRotate(z);
        }
        (z-&gt;parent_)-&gt;red_ = 0;
        ((z-&gt;parent_)-&gt;parent_)-&gt;red_ = 1;
        LeftRotate((z-&gt;parent_)-&gt;parent_);
      }
    }
  }
root_-&gt;red_ = 0;
}

template &lt;class CValue&gt;
void RedBlackTree&lt;CValue&gt;::Insert(const CValue in_value) {
  Node* z = new Node(in_value);
  Node* y = 0;
  Node* x = root_;
  while (!x-&gt;nil_) {
    //delete y;
    y = x;
    if (z-&gt;value_ &lt; x-&gt;value_) {
      x = x-&gt;left_;
    } else {
      x = x-&gt;right_;
    }
  }
  if (y) z-&gt;parent_ = y;
  if (y == 0) {
    root_ = z;
  } else {
    if (z-&gt;value_ &lt; y-&gt;value_) {
      y-&gt;left_ = z;
    } else {
      y-&gt;right_ = z;
    }
  }
  //maju sampe root!
  Node* tmpz = z;
  while (tmpz) {
    tmpz-&gt;ncount_ = 1 + (tmpz-&gt;left_)-&gt;ncount_ + (tmpz-&gt;right_)-&gt;ncount_;
    tmpz = tmpz-&gt;parent_;
  }
  InsertFixup(z);
}

//0 based
template &lt;class CValue&gt;
CValue RedBlackTree&lt;CValue&gt;::FindKth(int k) const { return FindKth(k, root_); }

template &lt;class CValue&gt;
CValue RedBlackTree&lt;CValue&gt;::FindKth(int k, Node* z) const {
  if ((z-&gt;left_)-&gt;ncount_ == k) return z-&gt;value_;
  if ((z-&gt;left_)-&gt;ncount_ &gt; k) return FindKth(k, z-&gt;left_);
  return FindKth(k - ((z-&gt;left_)-&gt;ncount_) - 1, z-&gt;right_);
}

template &lt;class CValue&gt;
int RedBlackTree&lt;CValue&gt;::size() {
  if (root_ == 0) return 0;
  return root_-&gt;ncount_;
}

//RedBlackTree&lt; value_type &gt; rbt; //valuetype harus bisa di &lt;
//rbt.Insert(5);
//rbt.FindKth(0); //0 the smallest
//rbt.FindKth(rbt.size() - 1); //the largest</Snippet>				<Snippet Name="AVLTree">template&lt;class C&gt;
class AVLTree {
 private:
  struct AVLTreeNode {
    C value;
    AVLTreeNode* parent;
    AVLTreeNode* left;
    AVLTreeNode* right;
    int size;
    int height;
  };

 public:
  AVLTree(): root_(nullptr) {
  }
  ~AVLTree() {
    CleanRec(root_);
  }

  void Insert(const C&amp; value) {
    // Insert value to the tree.
    if (root_ == nullptr) {
      root_ = new AVLTreeNode {value, nullptr, nullptr, nullptr, 1, 1};
      return;
    }
    AVLTreeNode* candidate = Find(value, root_, nullptr, /* force_generate = */ true);

    // Rebalance and repair size attribute of all parent nodes.
    RepairRebalance(candidate);
  }

  int Size() {
    if (root_ == nullptr) {
      return 0;
    } else {
      return root_-&gt;size;
    }
  }

  void Remove(const C&amp; value) {
    // Removes value from the tree.
    AVLTreeNode* node = Find(value, root_, nullptr, /* force_generate = */ false);
    assert(node != nullptr);  // otherwise not found
    AVLTreeNode* replacement = nullptr;
    if (node-&gt;left == nullptr &amp;&amp; node-&gt;right == nullptr) {
      replacement = node;
    } else if (node-&gt;left == nullptr) {
      replacement = KthSmallestRec(0, node-&gt;right);
    } else {
      replacement = KthSmallestRec(node-&gt;left-&gt;size - 1, node-&gt;left);
    }

    swap(node-&gt;value, replacement-&gt;value);

    // Remove replacement node.
    AVLTreeNode* parent_child = nullptr;
    if (replacement-&gt;left || replacement-&gt;right) {
      assert(!(replacement-&gt;left &amp;&amp; replacement-&gt;right));
      if (replacement-&gt;left) {
        parent_child = replacement-&gt;left;
      } else {
        parent_child = replacement-&gt;right;
      }
    }
    if (replacement-&gt;parent == nullptr) {
      assert(node == replacement);
      delete node;
      root_ = nullptr;
      return;
    }
    if (replacement-&gt;parent-&gt;left == replacement) {
      replacement-&gt;parent-&gt;left = parent_child;
    } else {
      assert(replacement-&gt;parent-&gt;right == replacement);
      replacement-&gt;parent-&gt;right = parent_child;
    }
    if (parent_child) {
      parent_child-&gt;parent = replacement-&gt;parent;
    }

    // Dealloc the node.
    AVLTreeNode* parent = replacement-&gt;parent;
    delete replacement;

    // Repair starting at the replacement node's parent.
    RepairRebalance(parent);
  }

  C KthSmallest(int rank) {
    // Find the k-th smallest value in the tree. 0-indexed: 0 is the smallest value
    assert(rank &lt; Size() &amp;&amp; rank &gt;= 0);
    assert(root_);
    return KthSmallestRec(rank, root_)-&gt;value;
  }

  int CountLess(const C&amp; value) {
    // Inverse of KthValue -- given a node, check the number of nodes whose value is less than it.
    return CountLessRec(value, root_);
  }

  bool Exists(const C&amp; value) {
    return Find(value, root_, nullptr, /* force_generate = */ false) != nullptr;
  }

 private:
  void SwapLeftChild(AVLTreeNode* parent) {
    assert(parent);
    AVLTreeNode* left = parent-&gt;left;
    assert(left);
    AVLTreeNode* leftright = left-&gt;right;

    parent-&gt;left = leftright;
    if (leftright != nullptr) {
      leftright-&gt;parent = parent;
    }
    left-&gt;right = parent;
    left-&gt;parent = parent-&gt;parent;
    if (parent-&gt;parent) {
      if (parent-&gt;parent-&gt;left == parent) {
        parent-&gt;parent-&gt;left = left;
      } else {
        assert(parent-&gt;parent-&gt;right == parent);
        parent-&gt;parent-&gt;right = left;
      }
    }
    if (left-&gt;parent == nullptr) {
      root_ = left;
    }
    parent-&gt;parent = left;

    Repair(parent);
    Repair(left);
  }

  void SwapRightChild(AVLTreeNode* parent) {
    assert(parent);
    AVLTreeNode* right = parent-&gt;right;
    assert(right);
    AVLTreeNode* rightleft = right-&gt;left;

    parent-&gt;right = rightleft;
    if (rightleft != nullptr) {
      rightleft-&gt;parent = parent;
    }
    right-&gt;left= parent;
    right-&gt;parent = parent-&gt;parent;
    if (parent-&gt;parent) {
      if (parent-&gt;parent-&gt;left == parent) {
        parent-&gt;parent-&gt;left = right;
      } else {
        assert(parent-&gt;parent-&gt;right == parent);
        parent-&gt;parent-&gt;right = right;
      }
    }
    if (right-&gt;parent == nullptr) {
      root_ = right;
    }
    parent-&gt;parent = right;

    Repair(parent);
    Repair(right);
  }

  void Repair(AVLTreeNode* node) {
    node-&gt;size = NodeSize(node-&gt;left) + NodeSize(node-&gt;right) + 1;
    node-&gt;height = 1 + max(NodeHeight(node-&gt;left), NodeHeight(node-&gt;right));
  }

  void RepairRebalance(AVLTreeNode* node) {
    // First rebalance
    if (NodeHeight(node-&gt;left) &gt;= NodeHeight(node-&gt;right) + 2) {
      assert(node-&gt;left);
      if (NodeHeight(node-&gt;left-&gt;right) &gt; NodeHeight(node-&gt;left-&gt;left)) {
        // left right
        SwapRightChild(node-&gt;left);
        SwapLeftChild(node);
      } else {
        // left left
        SwapLeftChild(node);
      }
    } else if (NodeHeight(node-&gt;right) &gt;= NodeHeight(node-&gt;left) + 2) {
      assert(node-&gt;right);
      if (NodeHeight(node-&gt;right-&gt;left) &gt; NodeHeight(node-&gt;right-&gt;right)) {
        // right left
        SwapLeftChild(node-&gt;right);
        SwapRightChild(node);
      } else {
        // right right
        SwapRightChild(node);
      }
    }

    // Next, repair
    Repair(node);
    if (node-&gt;parent) {
      RepairRebalance(node-&gt;parent);
    }
  }

  void CleanRec(AVLTreeNode* node) {
    if (node != nullptr) {
      CleanRec(node-&gt;left);
      CleanRec(node-&gt;right);
      delete node;
    }
  };

  AVLTreeNode* root_;

  AVLTreeNode* KthSmallestRec(int rank, AVLTreeNode* node) {
    assert(node);
    assert(rank &gt;= 0 &amp;&amp; rank &lt; node-&gt;size);
    if (rank == NodeSize(node-&gt;left)) {
      return node;
    } else {
      if (rank &lt; NodeSize(node-&gt;left)) {
        return KthSmallestRec(rank, node-&gt;left);
      } else {
        return KthSmallestRec(rank - NodeSize(node-&gt;left) - 1, node-&gt;right);
      }
    }
  }

  int CountLessRec(const C&amp; value, AVLTreeNode* node) {
    if (node == nullptr) return 0;
    if (node-&gt;value &gt;= value) {
      return CountLessRec(value, node-&gt;left);
    } else {
      return NodeSize(node-&gt;left) + 1 + CountLessRec(value, node-&gt;right);
    }
  }

  int NodeSize(AVLTreeNode* node) {
    if (node == nullptr) return 0; else return node-&gt;size;
  }
  int NodeHeight(AVLTreeNode* node) {
    if (node == nullptr) return 0; else return node-&gt;height;
  }

  AVLTreeNode* Find(const C&amp; value, AVLTreeNode* node, AVLTreeNode* parent, bool force_generate) {
    if (node == nullptr) {
      if (force_generate) {
        // do something
        AVLTreeNode* new_node = new AVLTreeNode {value, parent, nullptr, nullptr, 1, 1};
        assert(parent != nullptr);
        if (parent-&gt;value &gt; value) {
          assert(parent-&gt;left == nullptr);
          parent-&gt;left = new_node;
        } else {
          assert(parent-&gt;right == nullptr);
          parent-&gt;right = new_node;
        }
        return new_node;
      } else {
        return node;
      }
    } else if (node-&gt;value == value &amp;&amp; !force_generate) {
      return node;
    } else {
      if (value &lt; node-&gt;value) {
        return Find(value, node-&gt;left, node, force_generate);
      } else {
        return Find(value, node-&gt;right, node, force_generate);
      }
    }
  }
};

/*
AVLTree&lt;long long&gt; tree;
tree.Insert(100);
tree.Size();  // 1
tree.CountLess(2);
tree.KthSmallest(0);  // smallest number
tree.KthSmallest(tree.Size() - 1);  // largest number
tree.Exists(100);  // true
tree.Remove(100);
*/

</Snippet>			</Category>
			<Snippet Name="superset">template &lt;class _chilow, class _cdata&gt;
struct superset{

	_chilow low,high;
//#################MODIFIABLE##################
	_cdata returnvalue;
	bool leaf;
	bool emptyleaf;
	_chilow data;
//#################ENDOFMODIFIABLE#################

	superset&lt;_chilow,_cdata&gt;* left;
	superset&lt;_chilow,_cdata&gt;* right;

	superset(_chilow _low, _chilow _high) {
		low = _low;
		high = _high;
		left = right = 0;
		returnvalue = 0;
		leaf = 1;
		emptyleaf = 1;
		}

	~superset() {
		if (left != 0) delete left;
		if (right != 0) delete right;
	}

	void put (_chilow loc, _cdata _val) {

		if (leaf) {
			if (!emptyleaf &amp;&amp; data == loc) {
				returnvalue += _val;
				return;
			}
			if (emptyleaf) {
				emptyleaf = 0;
				data = loc;
				returnvalue += _val;
				return;
			}
		}
		_chilow mid = low + ((high-low+1)/2) - 1;
		if (left == 0) {
			left = (new superset&lt;_chilow,_cdata&gt;(low, mid));
			}
		if (right == 0) {
			right = (new superset&lt;_chilow,_cdata&gt;(mid + 1,high));
			}
		if (loc &lt;= mid &amp;&amp; loc &gt;= low) {
			(*left).put(loc,_val);
			}
		if (loc &gt;= mid+1 &amp;&amp; loc &lt;= high) {
			(*right).put(loc,_val);
			}
		if (leaf &amp;&amp; !emptyleaf) {
			if (data &lt;= mid &amp;&amp; data &gt;= low) {
				(*left).put(data,returnvalue);
			}
			if (data &gt;= mid+1 &amp;&amp; data &lt;= high) {
				(*right).put(data,returnvalue);
			}

		}
		leaf = 0;
		returnvalue += _val;
	}

	_cdata retrieve(_chilow _low, _chilow _high) {
		if (low &gt;= _low &amp;&amp; high &lt;= _high) {
			return returnvalue;
			}
		if (returnvalue == 0) return 0;
		if (leaf) {
			if (emptyleaf) return 0;
			if (data &gt;= _low &amp;&amp; data &lt;= _high) return returnvalue;
			return 0;
		}
		_cdata ret = 0;
		if (right &amp;&amp; _high &gt;= (*right).low) ret += (*right).retrieve(_low,_high);
		if (left &amp;&amp; _low &lt;= (*left).high) ret += (*left).retrieve(_low,_high);
		return ret;
		}
};

//superset&lt;int&gt; set(low,high)
//st.put(where, diff)
//st.retrieve(from,to)</Snippet>			<Category Name="SEGMENTTREE">
				<Snippet Name="CompleteSegmentTreeOr">class CompleteSegmentTreeOr {
 public:
  // 0..n-1, initially 0
  CompleteSegmentTreeOr(int n) {
    int real_n = 1;
    while (real_n &lt; n) {
      real_n *= 2;
    }
    lb_ = new int[2 * real_n + 1];
    ub_ = new int[2 * real_n + 1];
    value_ = new int[2 * real_n + 1];
    or_value_ = new int[2 * real_n + 1];
    for (int i = 0; i &lt; 2 * real_n + 1; ++i) lb_[i] = ub_[i] = value_[i] = or_value_[i] = 0LL;
    for (int i = 0; i &lt; real_n; ++i) {
      lb_[real_n + i] = i;
      ub_[real_n + i] = i;
    }
    for (int i = real_n - 1; i &gt;= 1; --i) {
      lb_[i] = lb_[i * 2];
      ub_[i] = ub_[i * 2 + 1];
    }
  }

  ~CompleteSegmentTreeOr() {
    delete[] lb_;
    delete[] ub_;
    delete[] value_;
    delete[] or_value_;
  }

  // Uniformly add this number to the values in range
  void Put(int low, int hi, int delta, int node = 1) {
    if (lb_[node] &gt;= low &amp;&amp; ub_[node] &lt;= hi) {
      value_[node] |= delta;
      or_value_[node] |= delta;
      return;
    }

    if (lb_[node] &gt; hi || ub_[node] &lt; low) return;

    Put(low, hi, delta, node * 2);
    Put(low, hi, delta, node * 2 + 1);

    or_value_[node] = or_value_[node * 2] | or_value_[node * 2 + 1] | value_[node];
    return;
  }

  int GetOr(int low, int hi, int node = 1) {
    if (lb_[node] &gt;= low &amp;&amp; ub_[node] &lt;= hi) {
      return or_value_[node];
    }
    if (lb_[node] &gt; hi || ub_[node] &lt; low) return 0;

    return GetOr(low, hi, node * 2LL) | GetOr(low, hi, node * 2LL + 1);
  }

 private:
  int* lb_;
  int* ub_;
  int* value_;
  int* or_value_;
};</Snippet>				<Snippet Name="MaximumSetValuesSegmentTree">class MaximumSetValuesSegmentTree {
 public:
  // 0..n-1, initially 0
  MaximumSetValuesSegmentTree(int n) {
    int real_n = 1;
    while (real_n &lt; n) {
      real_n *= 2;
    }
    lb_ = new int[2 * real_n + 1];
    ub_ = new int[2 * real_n + 1];
    value_ = new ll[2 * real_n + 1];
    max_value_ = new ll[2 * real_n + 1];
    correct_ = new int[2 * real_n + 1];
    for (int i = 0; i &lt; real_n; ++i) {
      lb_[real_n + i] = i;
      ub_[real_n + i] = i;
      value_[real_n + i] = 0;
      correct_[real_n + i] = 1;
      max_value_[real_n + i] = 0;
    }
    for (int i = real_n - 1; i &gt;= 1; --i) {
      lb_[i] = lb_[i * 2];
      ub_[i] = ub_[i * 2 + 1];
      value_[i] = 0;
      correct_[i] = 1;
      max_value_[i] = 0;
    }
  }

  ~MaximumSetValuesSegmentTree() {
    delete[] lb_;
    delete[] ub_;
    delete[] value_;
    delete[] max_value_;
    delete[] correct_;
  }

  // Set this number to the values in range
  void Set(int low, int hi, long long new_value, int node = 1) {
    if (lb_[node] &gt;= low &amp;&amp; ub_[node] &lt;= hi) {
      value_[node] = new_value;
      max_value_[node] = new_value;
      correct_[node] = 1;
      return;
    }

    if (lb_[node] &gt; hi || ub_[node] &lt; low) return;

    if (correct_[node]) {
      // splice
      FORN(i, 2) {
        value_[node * 2 + i] = value_[node];
        max_value_[node * 2 + i] = max_value_[node];
        correct_[node * 2 + i] = 1;
      }
      correct_[node] = 0;
    }
    Set(low, hi, new_value, node * 2);
    Set(low, hi, new_value, node * 2 + 1);

    max_value_[node] = max(max_value_[node * 2], max_value_[node * 2 + 1]);
    return;
  }

  long long GetMax(int low, int hi, int node = 1) {
    if (lb_[node] &gt;= low &amp;&amp; ub_[node] &lt;= hi) {
      return max_value_[node];
    }

    assert(!(lb_[node] &gt; hi || ub_[node] &lt; low));

    if (correct_[node]) {
      return max_value_[node];
    }

    long long return_value;
    if (ub_[node * 2LL] &gt;= low) {
      return_value = GetMax(low, hi, node * 2LL);
      if (lb_[node * 2LL + 1] &lt;= hi) {
        return_value = max(return_value,
                           GetMax(low, hi, node * 2LL + 1));
      }
    } else {
      return_value = GetMax(low, hi, node * 2LL + 1LL);
    }
    return return_value;
  }

 private:
  int* lb_;
  int* ub_;
  ll* value_;
  ll* max_value_;
  int* correct_;
};

// MaximumSetValuesSegmentTree tree(n);
// tree.Set(2, 5, 107LL);
// tree.GetMax(3, 4);  // return something</Snippet>				<Snippet Name="MaximumSetValuesAsStairSegmentTree">class MaximumSetValuesAsStairSegmentTree {
 public:
  MaximumSetValuesAsStairSegmentTree(int n) {
    int real_n = 1;
    while (real_n &lt; n) {
      real_n *= 2;
    }
    lb_ = new int[2 * real_n + 1];
    ub_ = new int[2 * real_n + 1];
    value_ = new ll[2 * real_n + 1];
    correct_ = new int[2 * real_n + 1];
    sum_ = new ll[2 * real_n + 1];
    inc_ = new ll[2 * real_n + 1];
    for (int i = 0; i &lt; real_n; ++i) {
      lb_[real_n + i] = i;
      ub_[real_n + i] = i;
      value_[real_n + i] = 0;
      correct_[real_n + i] = 1;
      sum_[real_n + i] = 0LL;
      inc_[real_n + i] = 0LL;
    }
    for (int i = real_n - 1; i &gt;= 1; --i) {
      lb_[i] = lb_[i * 2];
      ub_[i] = ub_[i * 2 + 1];
      value_[i] = 0;
      correct_[i] = 1;
      sum_[i] = 0LL;
      inc_[i] = 0LL;
    }
  }

  ~MaximumSetValuesAsStairSegmentTree() {
    delete[] lb_;
    delete[] ub_;
    delete[] value_;
    delete[] correct_;
    delete[] sum_;
    delete[] inc_;
  }

  // Set this number to the values in range
  void Set(int low, int hi, long long new_value, long long inc, int node = 1) {
    if (lb_[node] &gt;= low &amp;&amp; ub_[node] &lt;= hi) {
      value_[node] = new_value + (ll)(lb_[node] - low) * inc;
      inc_[node] = inc;
      correct_[node] = 1;
      ll n = ub_[node] - lb_[node] + 1LL;
      sum_[node] = (ll)(n * (n-1LL)) / 2LL * inc_[node] + value_[node] * n;
      return;
    }

    if (lb_[node] &gt; hi || ub_[node] &lt; low) return;

    if (correct_[node]) {
      // splice
      value_[node * 2] = value_[node];
      value_[node * 2 + 1] = value_[node] + (ll)(lb_[node * 2 + 1] - lb_[node]) * inc_[node];
      FORN(i, 2) {
        correct_[node * 2 + i] = 1;
        inc_[node * 2 + i] = inc_[node];
        ll n = ub_[node * 2 + i] - lb_[node * 2 + i] + 1LL;

        sum_[node * 2 + i] = (ll)(n * (n-1LL)) / 2LL * inc_[node * 2 + i] + value_[node * 2 + i] * n;
      }
      correct_[node] = 0;
    }
    Set(low, hi, new_value, inc, node * 2);
    Set(low, hi, new_value, inc, node * 2 + 1);
    sum_[node] = sum_[node * 2] + sum_[node * 2 + 1];
    return;
  }

  long long GetSum(int low, int hi, int node = 1) {
    if (lb_[node] &gt;= low &amp;&amp; ub_[node] &lt;= hi) {
      return sum_[node];
    }
    if (low &gt; ub_[node] || hi &lt; lb_[node]) {
      return 0LL;
    }
    if (correct_[node]) {
      low = max(low, lb_[node]);
      hi = min(hi, ub_[node]);
      ll n = (hi-low+1);
      ll init = value_[node] + (ll)(low - lb_[node]) * inc_[node];
      return n * (n-1LL) / 2LL * inc_[node] + init * n;
    }
    return GetSum(low, hi, node*2+1) + GetSum(low, hi, node*2);
  }

 private:
  int* lb_;
  int* ub_;
  ll* value_;
  ll* inc_;
  ll* sum_;
  int* correct_;
};

// MaximumSetValuesAsStairSegmentTree tree(n);
// tree.Set(2, 5, 107LL);
// tree.GetSum(3, 4);  // return something</Snippet>				<Snippet Name="CompleteMaxSegmentTree">class CompleteMaxSegmentTree {
 public:
  // 0..n-1, initially 0
  CompleteMaxSegmentTree(int n) {
    int real_n = 1;
    while (real_n &lt; n) {
      real_n *= 2;
    }
    lb_ = new int[2 * real_n + 1];
    ub_ = new int[2 * real_n + 1];
    value_ = new ll[2 * real_n + 1];
    max_value_ = new ll[2 * real_n + 1];
    for (int i = 0; i &lt; real_n; ++i) {
      lb_[real_n + i] = i;
      ub_[real_n + i] = i;
      value_[real_n + i] = max_value_[real_n + i] = 0LL;
    }
    for (int i = real_n - 1; i &gt;= 1; --i) {
      lb_[i] = lb_[i * 2];
      ub_[i] = ub_[i * 2 + 1];
      value_[i] = max_value_[i] = 0LL;
    }
  }
  ~CompleteMaxSegmentTree() {
    delete[] lb_;
    delete[] ub_;
    delete[] value_;
    delete[] max_value_;
  }

  // Uniformly add this number to the values in range
  void Add(int low, int hi, long long delta, int node = 1) {
    if (lb_[node] &gt;= low &amp;&amp; ub_[node] &lt;= hi) {
      value_[node] += delta;
      max_value_[node] += delta;
      return;
    }

    if (lb_[node] &gt; hi || ub_[node] &lt; low) return;

    Add(low, hi, delta, node * 2);
    Add(low, hi, delta, node * 2 + 1);

    max_value_[node] = max(max_value_[node * 2],
                           max_value_[node * 2 + 1]) + value_[node];
    return;
  }

  long long GetMax(int low, int hi, int node = 1) {
    if (lb_[node] &gt;= low &amp;&amp; ub_[node] &lt;= hi) {
      return max_value_[node];
    }

    long long return_value;
    if (ub_[node * 2LL] &gt;= low) {
      return_value = GetMax(low, hi, node * 2LL);
      if (lb_[node * 2LL + 1] &lt;= hi) {
        return_value = max(return_value,
                           GetMax(low, hi, node * 2LL + 1));
      }
    } else {
      return_value = GetMax(low, hi, node * 2LL + 1LL);
    }
    return return_value + value_[node];
  }

 private:
  int* lb_;
  int* ub_;
  ll* value_;
  ll* max_value_;
};

// CompleteMaxSegmentTree tree(n);  // all zeroes
// tree.Add(2, 5, +107LL);  // uniformly add 107 to 2..5
// tree.GetMax(3, 4);  // return max value among 3..4</Snippet>				<Snippet Name="StaticValueBetweenTree">class StaticValueBetweenTree {
 public:
  // Segment tree that can answer queries: find all value whose indexes between
  // a..b that is between c..d (i.e., all dots inside a box)
  StaticValueBetweenTree(const vector&lt;ll&gt;&amp; data) {
    int nodes = 1;
    while (nodes &lt; SZ(data)) {
      nodes *= 2;
    }
    lb_ = new ll[nodes * 2 + 2];
    ub_ = new ll[nodes * 2 + 2];
    values_ = new ll*[nodes * 2 + 2];
    nodes_ = nodes * 2 + 2;
    for (int i = 0; i &lt; nodes*2+2; ++i) {
      values_[i] = NULL;
    }
    _BuildTree(1, 0, SZ(data)-1, data);
  }
  ~StaticValueBetweenTree() {
    for (int i = 0; i &lt; nodes_; ++i) {
      delete[] values_[i];
    }
    delete[] values_;
    delete[] lb_;
    delete[] ub_;
  }
  int Count(int index_lb, int index_ub, ll value_lb, ll value_ub, int node_id=1) {
    if (lb_[node_id] &gt; index_ub || ub_[node_id] &lt; index_lb) {
      return 0;
    }
    if (lb_[node_id] &gt;= index_lb &amp;&amp; ub_[node_id] &lt;= index_ub) {
      return lower_bound(values_[node_id], values_[node_id] + ub_[node_id] - lb_[node_id] + 1, value_ub) -
             lower_bound(values_[node_id], values_[node_id] + ub_[node_id] - lb_[node_id] + 1, value_lb);
    }
    return Count(index_lb, index_ub, value_lb, value_ub, node_id*2) +
           Count(index_lb, index_ub, value_lb, value_ub, node_id*2+1);
  }

  ll** values_;
  ll* lb_;
  ll* ub_;
  ll nodes_;
 private:
  void _BuildTree(int node_id, int lb, int ub, const vector&lt;ll&gt;&amp; data) {
    assert(node_id &lt; nodes_);
    assert(node_id &gt; 0);
    assert(lb &gt;= 0);
    assert(ub &lt; SZ(data));
    assert(lb &lt;= ub);
    values_[node_id] = new ll[ub-lb+1];
    for (int i = lb; i &lt;= ub; ++i) {
      values_[node_id][i-lb] = data[i];
    }
    sort(values_[node_id], values_[node_id]+ub-lb+1);
    lb_[node_id] = lb;
    ub_[node_id] = ub;
    if (lb != ub) {
      int mid = (lb+ub)/2;
      _BuildTree(node_id*2, lb, mid, data);
      _BuildTree(node_id*2+1, mid+1, ub, data);
    }
  }
};

/*
vector&lt;ll&gt; data;
StaticValueBetweenTree tree(data);
int cnt = tree.Count(index_begin, index_end, value_lb, value_ub);
*/</Snippet>			</Category>
			<Snippet Name="FenwickTree">//ONE indexed
struct FenwickTree {
	int n_;
	int* bit_;
	FenwickTree (int n) {
		n_ = n;
    bit_ = new int[n_ + 10];
		FORN(i, n_) bit_[i+1] = 0;
  }
  
  ~FenwickTree () {
    delete[] bit_;
  }
  
	void add (int pos, int val) {
		while (pos &lt;= n_) {
			bit_[pos] += val;
			pos += (pos &amp; -pos);
    }
  }
  
	int sum(int ending) {
		if (ending &gt; n_) ending = n_;
		int retval = 0;
		while (ending &gt;= 1) {
			retval += bit_[ending];
			ending -= (ending &amp; -ending);
    }
		return retval;
  }
};</Snippet>			<Snippet Name="EnumerativeIntervalTree">class EnumerativeIntervalTree {
  // Interval tree that enumerates all intervals that intersect [a, b], including
  // end points.
 private:
  struct EnumerativeIntervalTreeNode_ {
    EnumerativeIntervalTreeNode_* left_child;
    EnumerativeIntervalTreeNode_* right_child;
    EnumerativeIntervalTreeNode_* parent;
    ll lb;
    ll ub;
    ll mid;
    multiset&lt; pair&lt;ll, ll&gt; &gt; segments;  // 
    multiset&lt; pair&lt;ll, ll&gt; &gt; segments_reversed;  // segments sorted as (end, begin)
    EnumerativeIntervalTreeNode_(ll lbx, ll ubx, EnumerativeIntervalTreeNode_* parentx) {
      assert(lbx &lt;= ubx);
      lb = lbx;
      ub = ubx;
      parent = parentx;
      mid = (lb+ub)/2LL;
      left_child = 0;
      right_child = 0;
    }
    ~EnumerativeIntervalTreeNode_() {
      delete left_child;
      delete right_child;
    }
  };
  EnumerativeIntervalTreeNode_* root_;

  void DoAdd(ll lb, ll ub, EnumerativeIntervalTreeNode_* node) {
    assert(node);
    assert(lb &gt;= node-&gt;lb &amp;&amp; ub &lt;= node-&gt;ub);
    assert(lb &lt;= ub);
    if (node-&gt;mid &gt;= lb &amp;&amp; node-&gt;mid &lt;= ub) {
      // intersects
      node-&gt;segments.insert(MP(lb, ub));
      node-&gt;segments_reversed.insert(MP(ub, lb));
      return;
    }
    if (ub &lt; node-&gt;mid) {
      if (!node-&gt;left_child) {
        node-&gt;left_child = new EnumerativeIntervalTreeNode_(node-&gt;lb, node-&gt;mid - 1LL, node);
      }
      DoAdd(lb, ub, node-&gt;left_child);
    } else {
      assert(lb &gt; node-&gt;mid);
      if (!node-&gt;right_child) {
        node-&gt;right_child = new EnumerativeIntervalTreeNode_(node-&gt;mid + 1LL, node-&gt;ub, node);
      }
      DoAdd(lb, ub, node-&gt;right_child);
    }
  }

  void DoRemove(ll lb, ll ub, EnumerativeIntervalTreeNode_* node) {
    assert(node);
    assert(lb &gt;= node-&gt;lb &amp;&amp; ub &lt;= node-&gt;ub);
    assert(lb &lt;= ub);
    if (node-&gt;mid &gt;= lb &amp;&amp; node-&gt;mid &lt;= ub) {
      assert(node-&gt;segments.count(MP(lb, ub)));
      node-&gt;segments.erase(node-&gt;segments.find(MP(lb, ub)));
      node-&gt;segments_reversed.erase(node-&gt;segments_reversed.find(MP(ub, lb)));
    } else if (ub &lt; node-&gt;mid) {
      assert(node-&gt;left_child);
      DoRemove(lb, ub, node-&gt;left_child);
    } else {
      assert(lb &gt; node-&gt;mid);
      assert(node-&gt;right_child);
      DoRemove(lb, ub, node-&gt;right_child);
    }

    if (!SZ(node-&gt;segments) &amp;&amp; !node-&gt;left_child &amp;&amp; !node-&gt;right_child &amp;&amp; node-&gt;parent) {
      // erase this node
      if (node-&gt;parent-&gt;left_child == node) {
        node-&gt;parent-&gt;left_child = 0;
      }
      if (node-&gt;parent-&gt;right_child == node) {
        node-&gt;parent-&gt;right_child = 0;
      }
      delete node;
    }
  }

  vector&lt; pair&lt;ll, ll&gt; &gt; enumerate_answer_;
  void DoEnumerate(ll lb, ll ub, EnumerativeIntervalTreeNode_* node) {
    assert(node);
    if (node-&gt;lb &gt; ub || node-&gt;ub &lt; lb) return;
    if (node-&gt;mid &gt;= lb &amp;&amp; node-&gt;mid &lt;= ub) {
      // add everyone
      FORIT(it, node-&gt;segments) enumerate_answer_.PB(*it);
    } else {
      if (lb &gt; node-&gt;mid) {
        // add those whose end points are to the right of lb
        for (multiset&lt; pair&lt;ll, ll&gt; &gt;::reverse_iterator it = node-&gt;segments_reversed.rbegin();
             it != node-&gt;segments_reversed.rend();
             ++it) {
          if (it-&gt;A &lt; lb) break;
          enumerate_answer_.PB(MP(it-&gt;B, it-&gt;A));
        }
      } else {
        assert(ub &lt; node-&gt;mid);
        // add those whose begin points are to the left of ub
        FORIT(it, node-&gt;segments) {
          if (it-&gt;A &gt; ub) break;
          enumerate_answer_.PB(*it);
        }
      }
    }
    if (node-&gt;left_child) DoEnumerate(lb, ub, node-&gt;left_child);
    if (node-&gt;right_child) DoEnumerate(lb, ub, node-&gt;right_child);
  }

 public:
  EnumerativeIntervalTree(ll lb, ll ub) {
    root_ = new EnumerativeIntervalTreeNode_(lb, ub, /* parent = */ 0);
  }
  ~EnumerativeIntervalTree() {
    delete root_;
  }
 public:
  void Add(ll lb, ll ub) {
    DoAdd(lb, ub, root_);
  }
  void Remove(ll lb, ll ub) {
    // removes ONE of this interval. Must be present.
    DoRemove(lb, ub, root_);
  }
  vector&lt; pair&lt;ll, ll&gt; &gt; Enumerate(ll lb, ll ub) {
    enumerate_answer_.clear();
    DoEnumerate(lb, ub, root_);
    sort(ALL(enumerate_answer_));
    return enumerate_answer_;
  }

};

// EnumerativeIntervalTree tree(lb, ub);
// tree.Add(lb, ub);  // log n
// tree.Remove(lb, ub);  // log n
// vector&lt; pair&lt;ll, ll&gt; &gt; segments = tree.Enumerate(lb, ub);  // log n + k log k, k = SZ(ret);</Snippet>			<Snippet Name="FenwickRangeTree">//zero indexed
class FenwickRangeTree {
 public:
  int n_;
  ll* addum_;
  ll* base_;
  FenwickRangeTree(int n) {
    n_ = n + 1;
    addum_ = new ll[n_ + 10];
    base_ = new ll[n_ + 10];
    FORN(i, n_) addum_[i+1] = base_[i+1] = 0;
  }
  
  ~FenwickRangeTree() {
    delete[] addum_;
    delete[] base_;
  }

 private:
  void DoAdd_(int pos, ll val) {
    ++pos;
    for (int i = pos; i &lt;= n_; i += (i&amp;-i)) {
      addum_[i] += val;
      base_[i] += -(ll)(pos - (i-(i&amp;-i)) - 1) * val;
    }
  }

  ll DoSum_(int pos) {
    ll res = 0LL;
    ++pos;

    for (int i = pos; i &gt; 0; i -= (i&amp;-i)) {
      res += (ll)(pos - (i - (i&amp;-i))) * addum_[i];
      res += base_[i];
    }
    return res;
  }

 public:
  void AddRange(int lb, int ub, ll val) {
    if (lb &gt; ub) return;
    DoAdd_(lb, val);
    DoAdd_(ub+1, -val);
    Sum(lb, ub);
  }
  void Add(int pos, ll val) {
    AddRange(pos, pos, val);
  }
  ll Sum(int lb, int ub) {
    if (lb &gt; ub) return 0LL;
    return DoSum_(ub) - DoSum_(lb-1);
  }
  ll Get(int pos) {
    return Sum(pos, pos);
  }
};
// FenwickRangeTree tree(n);
// tree.Add(5, +103);
// tree.AddRange(1, 8, -273);
// tree.Get(4);  // value at position 4
// tree.Sum(2, 7);  // sum of values</Snippet>			<Snippet Name="FenwickTree">template&lt;class C&gt;
class FenwickTree {
 public:
  FenwickTree (int n) {
    n_ = n;
    bit_ = new C[n_ + 10];
    FORN(i, n_) bit_[i+1] = 0;
  }
  
  ~FenwickTree () {
    delete[] bit_;
  }
  
  void Add(int pos, C val) {
    pos += 1;
    while (pos &lt;= n_) {
      bit_[pos] += val;
      pos += (pos &amp; -pos);
    }
  }
  
  C Sum(int ending) {
    ending += 1;
    if (ending &gt; n_) ending = n_;
    C retval = 0;
    while (ending &gt;= 1) {
      retval += bit_[ending];
      ending -= (ending &amp; -ending);
    }
    return retval;
  }

  C Range(int beg, int en) {
    return Sum(en) - Sum(beg-1);
  }

 private:
  int n_;
  C* bit_;
};</Snippet>		</Category>
		<Category Name="BIGNUM">
			<Snippet Name="BigInt">int IsMultiplyOverflow (long long multiplicant1, long long multiplicant2, long long overflow_limit) {
	if (multiplicant2 == 0LL) return overflow_limit &lt; 0LL;
	return multiplicant1 &gt; overflow_limit/multiplicant2;
}

// Mutable
class BigInt {
 public:
  // Empty initializer initializes value to 0
  BigInt() : digits_(1, 0), is_non_negative_(1) {}

  BigInt(long long initial_value) {
    if (initial_value &lt; 0LL) {
      is_non_negative_ = 0;
      initial_value *= -1LL;
    } else {
      is_non_negative_ = 1;
    }
    if (initial_value == 0) {
      digits_.push_back(0);
    }
    while (initial_value) {
      digits_.push_back(initial_value % (long long)kDigitSize);
      initial_value /= (long long)kDigitSize;
    }
  }

  BigInt(const string&amp; initial_value) {
    ParseFromString(initial_value);
  }

  void ParseFromString(string initial_value) {
    *this = 0;
    this-&gt;is_non_negative_ = 1;
    int negative = 0;
    if (initial_value[0] == '-') {
      negative = 1;
      initial_value = initial_value.substr(1, initial_value.size());
    }
    assert(initial_value.size() &gt; 0);
    for (int i = 0; i &lt; (int)initial_value.size(); ++i) {
      assert(initial_value[i] &gt;= '0' &amp;&amp; initial_value[i] &lt;= '9');
      long long value = initial_value[i] - '0';
      *this *= 10;
      *this += value;
    }
    if (negative) {
      this-&gt;is_non_negative_ = 0;
    }
    this-&gt;Normalize();
  }

  BigInt(const BigInt&amp; that) {
    this-&gt;is_non_negative_ = that.is_non_negative_;
    this-&gt;digits_ = that.digits_;
  }

  ~BigInt() {}

  // Copy Assignment
  BigInt&amp; operator=(const BigInt&amp; that) {
    this-&gt;is_non_negative_ = that.is_non_negative_;
    this-&gt;digits_ = that.digits_;
    return *this;
  }

  int Size() const {
    return (int)digits_.size();
  }

  long long ToLongLong() const {
    long long ret = 0LL;
    for (int i = Size()-1; i &gt;= 0; --i) {
      assert (!IsMultiplyOverflow(ret, kDigitSize, 9223372036854775807));
      ret *= (long long)kDigitSize;
      ret += (long long)digits_[i];
    }
    if (!is_non_negative_) ret *= -1LL;
    return ret;
  }

  // A devastatingly slow N^3 print method.
  string ToString(int base = 10) const {
    assert(base &gt;= 2);
    static string alphabet = &quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;
    assert(base &lt;= (int)alphabet.size());
    BigInt this_copy = *this;
    if (this_copy == 0) return &quot;0&quot;;
    vector&lt;char&gt; ret;
    int negative = 0;
    if (this_copy.is_non_negative_ == 0) {
      negative = 1;
      this_copy = this_copy.Absolute();
    }
    while (this_copy &gt; 0) {
      ret.push_back(alphabet[(this_copy % base).ToLongLong()]);
      this_copy /= base;
    }
    reverse(ret.begin(), ret.end());
    string ret_value = &quot;&quot;;
    for (size_t i = 0; i &lt; ret.size(); ++i) {
      ret_value += ret[i];
    }
    if (negative) ret_value = &quot;-&quot; + ret_value;
    return ret_value;
  }

  bool operator==(const BigInt&amp; that) const {
    return this-&gt;is_non_negative_ == that.is_non_negative_ &amp;&amp;
           this-&gt;digits_ == that.digits_;
  }

  bool operator!=(const BigInt&amp; that) const {
    return !this-&gt;operator==(that);
  }

  BigInt Absolute() const {
    BigInt copy_of_this(*this);
    copy_of_this.is_non_negative_ = 1;
    return copy_of_this;
  }

  BigInt AntiAbsolute() const {
    BigInt copy_of_this(*this);
    if (*this == 0LL) return copy_of_this;
    copy_of_this.is_non_negative_ = 0;
    return copy_of_this;
  }

  BigInt operator-() const {
    BigInt copy_of_this(*this);
    copy_of_this.is_non_negative_ ^= 1;
    copy_of_this.Normalize();
    return copy_of_this;
  }

  bool operator&lt;(const BigInt&amp; that) const {
    if (!this-&gt;is_non_negative_) {
      if (that.is_non_negative_) {
        return true;
      } else {
        return that &lt; this-&gt;Absolute();
      }
    } else {
      if (!that.is_non_negative_) {
        return false;
      }
      if (this-&gt;Size() != that.Size()) {
        return this-&gt;Size() &lt; that.Size();
      }
      for (int i = this-&gt;Size() - 1; i &gt;= 0; --i) {
        if (this-&gt;digits_[i] &lt; that.digits_[i]) return true;
        if (this-&gt;digits_[i] &gt; that.digits_[i]) return false;
      }
      return false;
    }
  }

  bool operator&gt;(const BigInt&amp; that) const {
    return that &lt; *this;
  }

  bool operator&lt;=(const BigInt&amp; that) const {
    return *this == that || *this &lt; that;
  }

  bool operator&gt;=(const BigInt&amp; that) const {
    return *this == that || *this &gt; that;
  }

  BigInt operator+(const BigInt&amp; that) const {
    // TODO(irvan): this' performance
    if (this-&gt;is_non_negative_ != that.is_non_negative_) {
      if (this-&gt;is_non_negative_) return *this - that.Absolute();
      else return that - this-&gt;Absolute();
    }
    BigInt ret = 0LL;
    ret.is_non_negative_ = this-&gt;is_non_negative_;
    ret.digits_.clear();
    int carry = 0;
    for (int i = 0; carry || (i &lt; max(this-&gt;Size(), that.Size())); ++i) {
      int left = 0;
      if (this-&gt;Size() &gt; i) left = this-&gt;digits_[i];
      int right = 0;
      if (that.Size() &gt; i) right = that.digits_[i];
      int sum = left + right + carry;
      ret.digits_.push_back(sum % kDigitSize);
      carry = sum / kDigitSize;
    }
    ret.Normalize();
    return ret;
  }

  BigInt operator-(const BigInt&amp; that) const {
    // TODO(irvan): this' performance can be enhanced.
    if (this-&gt;is_non_negative_ != that.is_non_negative_) {
      BigInt copy_of_that(that);
      copy_of_that.is_non_negative_ ^= 1;
      return *this + copy_of_that;
    }
    if (!this-&gt;is_non_negative_) {
      // -a - (-b) = b - a
      return that.Absolute() - this-&gt;Absolute();
    }
    if (that &gt; *this) {
      BigInt ret = that - *this;
      return ret.AntiAbsolute();
    }
    assert(this-&gt;Size() &gt;= that.Size());
    int borrow = 0;
    BigInt ret;
    ret.digits_.clear();
    for (int i = 0; i &lt; this-&gt;Size(); ++i) {
      int left = this-&gt;digits_[i];
      int right = 0;
      if (that.Size() &gt; i) right = that.digits_[i];
      int sum = left - right - borrow;
      borrow = 0;
      while (sum &lt; 0) {
        ++borrow;
        sum += kDigitSize;
      }
      ret.digits_.push_back(sum);
    }
    assert(borrow == 0);
    ret.Normalize();
    return ret;
  }

  BigInt&amp; operator+=(const BigInt&amp; that) {
    return operator=(*this + that);
  }

  BigInt&amp; operator-=(const BigInt&amp; that) {
    return operator=(*this - that);
  }

  BigInt&amp; operator++() {  // prefix ++
    return this-&gt;operator+=(1);
  }

  BigInt operator++(int) {  // postfix ++
    BigInt ret(*this);
    ++(*this);
    return ret;
  }

  BigInt&amp; operator--() {  // prefix --
    return this-&gt;operator-=(1);
  }

  BigInt operator--(int) {  // postfix --
    BigInt ret(*this);
    --(*this);
    return ret;
  }

  BigInt operator&lt;&lt;(const BigInt&amp; that) const {
    assert(this-&gt;is_non_negative_);
    // We does not support &lt;&lt; by a huge number, because it requires a
    // huge amount of memory.
    long long amount = that.ToLongLong();
    assert(amount &gt;= 0LL);
    long long shift_digit = amount / kDigitSizeLog;
    vector&lt;int&gt; shifted_digits(shift_digit, 0);
    BigInt ret(*this);
    ret.digits_.insert(ret.digits_.begin(), shifted_digits.begin(), shifted_digits.end());
    ret.Normalize();
    return ret.SlowMultiplication(1 &lt;&lt; (amount % kDigitSizeLog));
  }

  BigInt&amp; operator&lt;&lt;=(const BigInt&amp; that) {
    return this-&gt;operator=(*this &lt;&lt; that);
  }

  BigInt operator&gt;&gt;(const BigInt&amp; that) const {
    assert(this-&gt;is_non_negative_);
    // We does not support &gt;&gt; by a huge number, because it requires a
    // huge amount of memory.
    long long amount = that.ToLongLong();
    assert(amount &gt;= 0LL);
    long long shift_digit = amount / kDigitSizeLog;
    if (this-&gt;Size() &lt;= shift_digit) return 0;
    BigInt this_copy(*this);
    this_copy.digits_.erase(this_copy.digits_.begin(), this_copy.digits_.begin() + shift_digit);
    long long remain = amount % kDigitSizeLog;
    int carry = 0;
    for (int i = this_copy.Size() - 1; i &gt;= 0; --i) {
      this_copy.digits_[i] += (carry &lt;&lt; kDigitSizeLog);
      carry = this_copy.digits_[i] % (1 &lt;&lt; remain);
      this_copy.digits_[i] &gt;&gt;= remain;
    }
    this_copy.Normalize();
    return this_copy;
  }

  BigInt&amp; operator&gt;&gt;=(const BigInt&amp; that) {
    return this-&gt;operator=(*this &gt;&gt; that);
  }

  BigInt SlowMultiplication(const BigInt&amp; that) const {
    if (that.Size() &lt; this-&gt;Size()) {
      return that.SlowMultiplication(*this);
    }
    // usual
    BigInt ret;
    ret.digits_ = vector&lt;int&gt;(this-&gt;Size() + that.Size());
    ret.is_non_negative_ = !(this-&gt;is_non_negative_ ^ that.is_non_negative_);
    for (int i = 0; i &lt; this-&gt;Size(); ++i) {
      int carry = 0;
      int inner_carry = 0;
      for (int j = 0; j &lt; that.Size(); ++j) {
        int mult = this-&gt;digits_[i] * that.digits_[j] + carry;
        ret.digits_[i+j] += mult % kDigitSize;
        carry = mult / kDigitSize;
        ret.digits_[i+j] += inner_carry;
        inner_carry = ret.digits_[i+j] / kDigitSize;
        ret.digits_[i+j] %= kDigitSize;
      }
      ret.digits_[i + that.Size()] += carry + inner_carry;
      int position = i + that.Size();
      while (ret.digits_[position] &gt;= kDigitSize) {
        ret.digits_[position + 1] += ret.digits_[position] / kDigitSize;
        ret.digits_[position] %= kDigitSize;
        ++position;
      }
    }
    ret.Normalize();
    return ret;
  }

  // Approximately N^1.6 (karatsuba)
  BigInt operator*(const BigInt&amp; that) const {
    if (that.Size() &lt; this-&gt;Size()) {
      return that * *this;
    }
    if (this-&gt;Size() &lt;= 125 ||
        this-&gt;Size() * that.Size() &lt;= (int)floor(pow(that.Size(), 1.6)) / 16) {
      return this-&gt;SlowMultiplication(that);
    } else {
      // Karatsuba algorithm
      int digitviding_line = (that.Size() + 1) / 2;
      BigInt xlarge, xsmall;
      BigInt ylarge, ysmall;
      xlarge.digits_.clear();
      xlarge.is_non_negative_ = true;
      xsmall.digits_.clear();
      xsmall.is_non_negative_ = true;
      ylarge.digits_.clear();
      ylarge.is_non_negative_ = true;
      ysmall.digits_.clear();
      ysmall.is_non_negative_ = true;

      for (int i = 0; i &lt; digitviding_line; ++i) {
        int xsmallbit = 0;
        int xlargebit = 0;
        int ysmallbit = 0;
        int ylargebit = 0;
        if (this-&gt;Size() &gt; i) xsmallbit = this-&gt;digits_[i];
        if (this-&gt;Size() &gt; i + digitviding_line) xlargebit = this-&gt;digits_[i + digitviding_line];
        if (that.Size() &gt; i) ysmallbit = that.digits_[i];
        if (that.Size() &gt; i + digitviding_line) ylargebit = that.digits_[i + digitviding_line];
        xsmall.digits_.push_back(xsmallbit);
        xlarge.digits_.push_back(xlargebit);
        ysmall.digits_.push_back(ysmallbit);
        ylarge.digits_.push_back(ylargebit);
      }
      xsmall.Normalize();
      xlarge.Normalize();
      ysmall.Normalize();
      ylarge.Normalize();
      BigInt biggest = xlarge * ylarge;
      BigInt smallest = xsmall * ysmall;
      BigInt avg = ((xsmall + xlarge) * (ysmall + ylarge)) - biggest - smallest;
      biggest &lt;&lt;= (long long) digitviding_line * 2 * kDigitSizeLog;
      avg &lt;&lt;= (long long) digitviding_line * kDigitSizeLog;
      BigInt result = biggest + avg + smallest;
      result.is_non_negative_ = !(this-&gt;is_non_negative_ ^ that.is_non_negative_);
      result.Normalize();
      return result;
    }
  }

  BigInt&amp; operator*=(const BigInt&amp; that) {
    return this-&gt;operator=(*this * that);
  }

  // medium constant * N^2. Yes, it pains my heart but oh well.
  BigInt operator/(const BigInt&amp; that) const {
    int max_add = 0;
    BigInt that_copy(that.Absolute());
    BigInt this_copy(this-&gt;Absolute());
    while (that_copy &lt;= this_copy) {
      ++max_add;
      that_copy &lt;&lt;= 1;
    }
    if (max_add == 0) {
      return 0;
    }
    BigInt ret;
    ret.digits_ = vector&lt;int&gt;(1 + max_add / kDigitSizeLog);
    ret.is_non_negative_ = !(this-&gt;is_non_negative_ ^ that.is_non_negative_);
    for (int i = max_add - 1; i &gt;= 0; --i) {
      that_copy &gt;&gt;= 1;
      if (this_copy &gt;= that_copy) {
        // this digit is 1
        int digit_position = i / kDigitSizeLog;
        int digit_offset = i % kDigitSizeLog;
        ret.digits_[digit_position] += (1 &lt;&lt; digit_offset);
        this_copy -= that_copy;
      }
    }
    ret.Normalize();
    return ret;
  }

  BigInt operator%(const BigInt&amp; that) const {
    // only supports positive numbers now
    assert(that.is_non_negative_);
    assert(this-&gt;is_non_negative_);
    assert(that != 0);
    return *this - ((*this / that) * that);
  }

  BigInt&amp; operator/=(const BigInt&amp; that) {
    return this-&gt;operator=(*this / that);
  }

  BigInt&amp; operator%=(const BigInt&amp; that) {
    return this-&gt;operator=(*this % that);
  }

  friend ostream&amp; operator&lt;&lt;(ostream&amp; out, BigInt&amp; obj) {
    out &lt;&lt; obj.ToString();
    return out;
  }

  friend istream&amp; operator&gt;&gt;(istream&amp; in, BigInt&amp; obj) {
    string rep;
    in &gt;&gt; rep;
    obj.ParseFromString(rep);
    return in;
  }

 private:
  void Normalize() {
    while (this-&gt;Size() &gt; 1 &amp;&amp; digits_.back() == 0) {
      digits_.pop_back();
    }
    if (this-&gt;Size() == 1 &amp;&amp; this-&gt;digits_[0] == 0) {
      is_non_negative_ = 1;
    }
  }
  // for performance, kDigitSize^2 should fit in an integer.
  // must be a multiple of 2
  static const int kDigitSize = (1 &lt;&lt; 15);
  static const int kDigitSizeLog = 15;
  vector&lt;int&gt; digits_;
  int is_non_negative_;
};</Snippet>			<Snippet Name="FactorizedNumber">//(number**exponent) % ivalue;
ll Power(ll number,ll exponent,ll ivalue) {
  ll ret = 1;
  ll multiplier = number;
  while (exponent &gt; 0LL) {
    if (exponent % 2LL) {
      ret = (ret * multiplier) % ivalue;
    }
    exponent /= 2LL;
    multiplier = (multiplier * multiplier) % ivalue;
  }
  return ret;
}

vector&lt;int&gt; Sieve(int abc) {
  vector&lt;int&gt; sieveans;
  abc++;
  sieveans.reserve(abc);
  FORN(i,abc) sieveans.push_back(1);
  for (int i = 2;i * i &lt; abc;i = (i == 2)?3:(i + 2)) {
    for (int j = i + i;j &lt; abc;j += i) {
      sieveans[j] = 0;
    }
  }
  sieveans[0] = sieveans[1] = 0;
  return sieveans;
}

//generate all prime number lower than or equal to abc;
vector&lt;int&gt; GeneratePrime(int abc) {
  vector&lt;int&gt; stable = Sieve(abc);
  vector&lt;int&gt; returnvalue;
  for (int i = 0;i &lt; (int)stable.size();i++) {
    if (stable[i]) returnvalue.push_back(i);
  }
  return returnvalue;
}

int kMaxPrimesGenerated = 1200000;
vector&lt; pair&lt;ll,ll&gt; &gt; AmortizedFactorize(ll number) {
  static vector&lt;int&gt; primes;
  if (SZ(primes) == 0) {
    primes = GeneratePrime(kMaxPrimesGenerated);
  }
  assert(number &gt;= 1LL);
  vector&lt; pair&lt;ll, ll&gt; &gt; ret;
  int done = 0;
  for (vector&lt;int&gt;::const_iterator it = primes.begin();
       it != primes.end(); ++it) {
    if (*it * *it &gt; number) {
      done = 1;
      break;
    }
    ll cnt = 0;
    while (number % *it == 0LL) {
      number /= *it;
      ++cnt;
    }
    if (cnt) ret.PB(MP(*it, cnt));
  }
  if (!done) {
    kMaxPrimesGenerated *= 2;
    primes = GeneratePrime(kMaxPrimesGenerated);
    return AmortizedFactorize(number);
  }
  if (number &gt; 1LL) {
    ret.PB(MP(number, 1LL));
  }
  return ret;
}

class FactorizedNumber {
 public:
  FactorizedNumber(ll number, ll exponent) {
    Construct_(number, exponent);
  }

  FactorizedNumber(ll number) {
    Construct_(number, 1LL);
  }

  FactorizedNumber(const FactorizedNumber&amp; other) {
    this-&gt;factors_ = other.factors_;
  }

  FactorizedNumber&amp; operator=(const FactorizedNumber&amp; other) {
    this-&gt;factors_ = other.factors_;
    return *this;
  }

  // similar to multiply, but do this to self destructively. Faster. Return self
  FactorizedNumber&amp; DestructiveMultiply(const FactorizedNumber&amp; other) {
    for (map&lt;ll, ll&gt;::const_iterator it = other.factors_.begin();
         it != other.factors_.end();
         ++it) {
      factors_[it-&gt;A] += it-&gt;B;
    }
    return *this;
  }

  FactorizedNumber Multiply(const FactorizedNumber&amp; other) const {
    FactorizedNumber res(*this);
    return res.DestructiveMultiply(other);
  }

  // similar to divide, but do this to self destructively. Faster. Return self.
  FactorizedNumber&amp; DestructiveDivide(const FactorizedNumber&amp; other) {
    assert(IsMultiplyOf(other));
    for (map&lt;ll, ll&gt;::const_iterator it = other.factors_.begin();
         it != other.factors_.end();
         ++it) {
      factors_[it-&gt;A] -= it-&gt;B;
    }
    return *this;
  }

  FactorizedNumber Divide(const FactorizedNumber&amp; other) const {
    FactorizedNumber res(*this);
    return res.DestructiveDivide(other);
  }

  bool IsMultiplyOf(const FactorizedNumber&amp; other) const {
    for (map&lt;ll, ll&gt;::const_iterator it = other.factors_.begin();
         it != other.factors_.end();
         ++it) {
      if (!factors_.count(it-&gt;A) || factors_.find(it-&gt;A)-&gt;B &lt; it-&gt;B) {
        return false;
      }
    }
    return true;
  }

  // Converts this to int modulo modu.
  ll ToLongLong(ll modu = 1000000007LL * 1000000007LL) const {
    ll value = 1LL;
    for (map&lt;ll, ll&gt;::const_iterator it = factors_.begin();
         it != factors_.end();
         ++it) {
      value *= Power(it-&gt;A, it-&gt;B, modu);
      value %= modu;
    }
    return value;
  }

  string ToString() const {
    stringstream s;
    s &lt;&lt; &quot;[&quot;;
    int init = 1;
    for (map&lt;ll, ll&gt;::const_iterator it = factors_.begin();
         it != factors_.end();
         ++it) {
      if (!init) s &lt;&lt; &quot; * &quot;;
      init = 0;
      s &lt;&lt; &quot;(&quot; &lt;&lt; (it-&gt;A) &lt;&lt; &quot;^&quot; &lt;&lt; (it-&gt;B) &lt;&lt; &quot;)&quot;;
    }
    s &lt;&lt; &quot;]&quot;;
    return s.str();
  }

  vector&lt; pair&lt;ll, ll&gt; &gt; ToPrimeFactors() const {
    vector&lt; pair&lt;ll, ll&gt; &gt; res;
    for (map&lt;ll, ll&gt;::const_iterator it = factors_.begin();
        it != factors_.end();
        ++it) {
      if (it-&gt;B != 0LL) {
        res.push_back(*it);
      }
    }
    return res;
  }

 private:
  void Construct_(ll number, ll exponent) {
    vector&lt; pair&lt;ll, ll&gt; &gt; factors = AmortizedFactorize(number);
    for (vector&lt; pair&lt;ll, ll&gt; &gt;::const_iterator it = factors.begin();
         it != factors.end();
         ++it) {
      factors_[it-&gt;A] = it-&gt;B * exponent;
    }
  }
 
  map&lt;ll, ll&gt; factors_;
};</Snippet>		</Category>
		<Category Name="RARE">
			<Snippet Name="Date">class Date {
 public:
  Date(int day, int month, int year) {
    day_ = day;
    month_ = month;
    year_= year;
  }
  int day() const {return day_;} //1 sampai biasa
  int month() const {return month_;} //january is 0
  int year() const {return year_;}

  bool operator &lt;(const Date&amp; operand) const {
    if (year() &lt; operand.year()) return true;
    if (year() &gt; operand.year()) return false;
    if (month() &lt; operand.month()) return true;
    if (month() &gt; operand.month()) return false;
    if (day() &lt; operand.day()) return true;
    return false;
  }

  bool operator &gt;(const Date&amp; operand) const { return operand &lt; *this; }
  bool operator ==(const Date&amp; operand) const {
    return (!(operand &lt; *this) &amp;&amp; !(operand &gt; *this));
  }

  int Advance() {
    day_ += 1;
    if (day_ &gt; DayCount(month(), year())) {
      day_ = 1;
      month_ += 1;
      if (month_ &gt;= 12) {
        month_ = 0;
        year_ += 1;
      }
    }
  }

 private:
  bool IsLeapYear(int year) {
    if (year % 400 == 0) return true;
    if (year % 100 == 0) return false;
    if (year % 4 == 0) return true;
    return false;
  }
  int DayCount(int month, int year) {
    switch (month) {
      case 0 :
      case 2 :
      case 4 :
      case 6 :
      case 7 :
      case 9 :
      case 11 :
        return 31;
      case 1 :
        if (IsLeapYear(year)) return 29;
        return 28;
      default :
        return 30;
    }
  }
  int day_;
  int month_;
  int year_;
};
//Date d(1,0,1990) //1 january 1990
//d.Advance(); //maju 1 hari
//d ==,&lt;,&gt; date //bisa
//.day(), .month(), .year() //selectors</Snippet>		</Category>
		<Snippet Name="DisjointSet">class DisjointSet {
  public:
  	explicit DisjointSet(int n) {
  		whichset_ = vector&lt;int&gt;(n);
  		height_ = vector&lt;int&gt;(n, 1);
  		for (int i = 0; i &lt; n; ++i) whichset_[i] = i;
  	}

  	int Find(int node) {
  		if (whichset_[node] == node) return node;
  		return (whichset_[node] = Find(whichset_[node]));
  	}

  	void Merge(int first_node, int second_node) {
  		//cek siapa mo jadi bokapnya?
  		int h1 = height_[Find(first_node)];
  		int h2 = height_[Find(second_node)];
  		if (h1 &lt; h2) {
	  		whichset_[Find(first_node)] = Find(second_node);
	  		return;
	  	}
	  	whichset_[Find(second_node)] = Find(first_node);
	  	if (h2 &lt; h1) return;
	  	++height_[Find(second_node)];
  	}

  private:
  	vector&lt;int&gt; whichset_;
  	vector&lt;int&gt; height_;
};

//DisjointSet ds(jumlah_node);
//ds.Merge(0,1);
//ds.Find(1) //return 0 ato 1</Snippet>		<Snippet Name="BinomialHeap">template&lt;class cDataType&gt;
class BinomialHeap {
 public:
  BinomialHeap() : tree_list_() {}
  ~BinomialHeap();

  cDataType MinElement() const;
  void Push(cDataType value);
  void Pop();
  void Merge(BinomialHeap* merged_heap);
  int Empty() { return tree_list_.empty(); }

 private:
  struct BinomialHeapNode {
    BinomialHeapNode(cDataType value) {
      size_ = 1;
      value_ = value;
    }
    void ClearAll() {
      FORIT(i,children_) {
        (*i)-&gt;ClearAll();
        delete (*i);
      }
    }
    list&lt; BinomialHeapNode* &gt; children_;
    int size_;
    cDataType value_;
  };
  list&lt;BinomialHeapNode* &gt; tree_list_;

  void FixList();

  class SizeCmp;

};

template&lt;class cDataType&gt;
class BinomialHeap&lt;cDataType&gt;::SizeCmp {
 public:
  bool operator() (const BinomialHeapNode* binom_heap1,
                   const BinomialHeapNode* binom_heap2) const {
    return binom_heap1-&gt;size_ &lt; binom_heap2-&gt;size_;
  }
};

template&lt;class cDataType&gt;
BinomialHeap&lt;cDataType&gt;::~BinomialHeap() {
  FORIT(i,tree_list_) {
    (*i)-&gt;ClearAll();
    delete *i;
  }
}

template&lt;class cDataType&gt;
cDataType BinomialHeap&lt;cDataType&gt;::MinElement() const {
  cDataType ret = tree_list_.front()-&gt;value_;
  FORIT(i,tree_list_) MN(ret, (*i)-&gt;value_);
  return ret;
}

template&lt;class cDataType&gt;
void BinomialHeap&lt;cDataType&gt;::Push(cDataType value) {
  tree_list_.push_front(new BinomialHeapNode(value));
  FixList();
}

template&lt;class cDataType&gt;
void BinomialHeap&lt;cDataType&gt;::Pop() {
  cDataType popped_value = MinElement();
  FORIT(i,tree_list_) if ((*i)-&gt;value_ == popped_value) {
    BinomialHeapNode* popped_node = (*i);
    tree_list_.erase(i);
    list&lt;BinomialHeapNode*&gt; inserted_list;
    FORIT(i,popped_node-&gt;children_) inserted_list.PB(*i);
    delete popped_node;
    tree_list_.merge(inserted_list, SizeCmp());
    FixList();
    break;
  }
}

template&lt;class cDataType&gt;
void BinomialHeap&lt;cDataType&gt;::Merge(BinomialHeap* merged_heap) {
  tree_list_.merge(*merged_heap, SizeCmp());
  FixList();
}

template&lt;class cDataType&gt;
void BinomialHeap&lt;cDataType&gt;::FixList() {
  for (typeof(tree_list_.begin()) i = tree_list_.begin(); i != tree_list_.end();) {
    typeof(tree_list_.begin()) inext = i, itwicenext = i;
    advance(inext, 1);
    if (inext != tree_list_.end()) {
      if ((*i)-&gt;size_ == (*inext)-&gt;size_) {
        //both needs to be merged
        advance(itwicenext, 2);
        if (itwicenext != tree_list_.end() &amp;&amp; (*itwicenext)-&gt;size_ == (*i)-&gt;size_) {
          //three in a row
          ++i;
          continue;
        }
        //merge-and-erase
        if ((*i)-&gt;value_ &lt; (*inext)-&gt;value_)  swap((*i), *inext);
        //first point to second, so just add it as a child
        (*inext)-&gt;size_ += 1;
        (*inext)-&gt;children_.PB(*i);
        tree_list_.erase(i);
        i = inext;
        continue;
      }
    }
    ++i;
  }
}</Snippet>		<Snippet Name="MemoizedPriorityQueue">template &lt;class cKeyType, class cDataType, class cCompareFunction = greater&lt; pair&lt; cDataType, cKeyType &gt; &gt; &gt;
class MemoizedPriorityQueue {
  public:
  	//constructor
  	MemoizedPriorityQueue() {}
  	int Empty() {
  		ValidifyTop();
  		return pq_.empty();
  	}
  	pair&lt; cKeyType, cDataType &gt; Top() {
  		ValidifyTop();
  		return MP( pq_.top().B, pq_.top().A);
  	}
  	void Pop() {
  		ValidifyTop();
  		pq_.pop();
  	}
  	void Push(cKeyType new_key, cDataType new_data) {
  		if (!value_map_.count(new_key) || cCompareFunction()(MP(value_map_[new_key], new_key), MP(new_data, new_key))) {
  			value_map_[new_key] = new_data;
  			pq_.push(MP(new_data, new_key));
  		}
  	}

  private:

  	priority_queue&lt; pair&lt; cDataType, cKeyType &gt;, vector&lt; pair&lt; cDataType, cKeyType &gt; &gt;, cCompareFunction &gt; pq_;
	map&lt; cKeyType, cDataType &gt; value_map_;

	void ValidifyTop() {
		while (!pq_.empty() &amp;&amp; value_map_[pq_.top().B] != pq_.top().A) pq_.pop();
	}
};

/*
DO NOT USE FOR TIGHT CONSTRAINTS : USE ARRAYS INSTEAD OF MAP
MemoizedPriorityQueue&lt; key, data &gt; mpq; //by default minimum, kalo mau max :
MemoizedPriorityQueue&lt; key, data, less&lt; MP(data, key) &gt; &gt; mpqmax;
mpq.Push(&quot;key&quot;, 4);
key = mpq.Top().A;
data = mpq.Top().B;
mpq.Pop();
assert(mpq.Empty() == 1);
*/</Snippet>		<Snippet Name="HashMap">template &lt;class CType&gt;
class HashCode {
 public:
  //return between 1 and 1,000,000,000
  virtual ~HashCode() {}
  virtual int hash(const CType&amp; object) = 0;
};

// example implementation
class HashCodeVectorInteger : public HashCode&lt; vector&lt;int&gt; &gt; {
 public:
  virtual ~HashCodeVectorInteger() {}
  virtual int hash(const vector&lt;int&gt;&amp; object) {
    long long ret = 0;
    for (int i = 0; i &lt; SZ(object); ++i) {
      ret *= 1000000007LL;
      ret += (long long)object[i];
      #include &lt;climits&gt;
      ret += abs((long long)INT_MIN);
      ret %= 1000000000LL;
    }
    return ret;
  }
};

// not MULTIHASHMAP
template &lt;class CKey, class CValue, class CHasher &gt;
class HashMap {
 public:

  HashMap(int init_size = 16, double load_factor = 0.5) :
      load_factor_(load_factor), n_(0), rep_(init_size), hasher_() {}

  // analogous with map
  CValue&amp; operator[] (const CKey&amp; key) {
    CValue* found = this-&gt;find(key);
    if (found == NULL) {
      insert(key, CValue());
      found = this-&gt;find(key);
    }
    return *found;
  }

  // analogous with map
  void erase(const CKey&amp; key) {
    int code = hasher_.hash(key) % SZ(rep_);
    FORIT(it, rep_[code]) {
      if (it-&gt;A == key) {
        // found
        rep_[code].erase(it);
        --n_;
        return;
      }
    }
    // not found
    assert(false);
    return;
  }

  // analogous with map
  void insert(const CKey&amp; key, const CValue&amp; value) {
    if ((double)(n_ + 1) / (double)SZ(rep_) &gt;= load_factor_) {
      // time to resize
      vector&lt; list&lt; pair&lt;CKey, CValue&gt; &gt; &gt; old = rep_;
      int old_size = SZ(rep_);
      rep_ = vector&lt; list&lt; pair&lt;CKey, CValue&gt; &gt; &gt;(old_size * 2);
      n_ = 0;
      FORN(i, old_size) FORIT(it, old[i]) insert(it-&gt;A, it-&gt;B);
    }

    int code = hasher_.hash(key) % SZ(rep_);
    rep_[code].push_back(MP(key, value));
    ++n_;
    return;
  }

  int size() const {
    return n_;
  }

  // retrieves all
  vector&lt; pair&lt;CKey, CValue&gt;* &gt; all() {
    vector&lt; pair&lt;CKey, CValue&gt;* &gt; ret;
    FORN(i, SZ(rep_)) FORIT(it, rep_[i]) ret.PB(&amp;(*it));
    return ret;
  }

  int count(CKey key) {
    return (this-&gt;find(key) != NULL);
  }

 private:

  CValue* find(const CKey&amp; key) {
    int code = hasher_.hash(key) % SZ(rep_);
    FORIT(it, rep_[code]) {
      if (it-&gt;A == key) {
        return &amp;(it-&gt;B);
      }
    }
    return NULL;
  }

  double load_factor_;
  int n_;
  vector&lt; list&lt; pair&lt;CKey, CValue&gt; &gt; &gt; rep_;
  CHasher hasher_;
};

// HashMap&lt; vint, int, HashCodeVectorInteger &gt; m;
// m[{1,2}] = 5;
// m.erase({1,2});
// m.insert({1,2}, 5);
// m.size()
// m.count({1,2})</Snippet>		<Category Name="BASIC">
			<Snippet Name="IdManager">class IdManager {
 public:
  IdManager() {}
  int get(int x) {
    add(x);
    return ids_[x];
  }
  
  void add(int x) {
    if (ids_.count(x)) return;
    int next_id = SZ(ids_);
    ids_[x] = next_id;
  }
  
  int size() {
    return SZ(ids_);
  }
  
  map&lt;int, int&gt; ids_;
};</Snippet>			<Snippet Name="Static2DArraySum">template&lt;class T&gt;
class Static2DArraySum {
 public:
  Static2DArraySum(T arr[][kDimension], int rows, int cols) :
      _rows(rows),
      _cols(cols) {
    _t = new T*[rows];
    for (int i = 0; i &lt; rows; ++i) {
      _t[i] = new T[cols];
    }
    for (int i = 0; i &lt; rows; ++i) for (int j = 0; j &lt; cols; ++j) {
      _t[i][j] = arr[i][j];
      if (i) _t[i][j] += _t[i-1][j];
      if (j) _t[i][j] += _t[i][j-1];
      if (i &amp;&amp; j) _t[i][j] -= _t[i-1][j-1];
    }
  }
  ~Static2DArraySum() {
    for (int i = 0; i &lt; _rows; ++i) {
      delete[] _t[i];
    }
    delete[] _t;
  }
  T Sum(int minrow, int mincol, int maxrow, int maxcol) {
    T result = _t[maxrow][maxcol];
    if (minrow) result -= _t[minrow-1][maxcol];
    if (mincol) result -= _t[maxrow][mincol-1];
    if (minrow &amp;&amp; mincol) result += _t[minrow-1][mincol-1];
    return result;
  }
 private:
  int _rows, _cols;
  T** _t;
};</Snippet>		</Category>
		<Category Name="INTERVAL">
			<Snippet Name="SeparateOverlappingIntervals">// CompleteMaxSegmentTree tree(n);  // all zeroes
// tree.Add(2, 5, +107LL);  // uniformly add 107 to 2..5
// tree.GetMax(3, 4);  // return max value among 3..4

class EnumerativeIntervalTree {
  // Interval tree that enumerates all intervals that intersect [a, b], including
  // end points.
 private:
  struct EnumerativeIntervalTreeNode_ {
    EnumerativeIntervalTreeNode_* left_child;
    EnumerativeIntervalTreeNode_* right_child;
    EnumerativeIntervalTreeNode_* parent;
    ll lb;
    ll ub;
    ll mid;
    multiset&lt; pair&lt;ll, ll&gt; &gt; segments;  // 
    multiset&lt; pair&lt;ll, ll&gt; &gt; segments_reversed;  // segments sorted as (end, begin)
    EnumerativeIntervalTreeNode_(ll lbx, ll ubx, EnumerativeIntervalTreeNode_* parentx) {
      assert(lbx &lt;= ubx);
      lb = lbx;
      ub = ubx;
      parent = parentx;
      mid = (lb+ub)/2LL;
      left_child = 0;
      right_child = 0;
    }
    ~EnumerativeIntervalTreeNode_() {
      delete left_child;
      delete right_child;
    }
  };
  EnumerativeIntervalTreeNode_* root_;

  void DoAdd(ll lb, ll ub, EnumerativeIntervalTreeNode_* node) {
    assert(node);
    assert(lb &gt;= node-&gt;lb &amp;&amp; ub &lt;= node-&gt;ub);
    assert(lb &lt;= ub);
    if (node-&gt;mid &gt;= lb &amp;&amp; node-&gt;mid &lt;= ub) {
      // intersects
      node-&gt;segments.insert(MP(lb, ub));
      node-&gt;segments_reversed.insert(MP(ub, lb));
      return;
    }
    if (ub &lt; node-&gt;mid) {
      if (!node-&gt;left_child) {
        node-&gt;left_child = new EnumerativeIntervalTreeNode_(node-&gt;lb, node-&gt;mid - 1LL, node);
      }
      DoAdd(lb, ub, node-&gt;left_child);
    } else {
      assert(lb &gt; node-&gt;mid);
      if (!node-&gt;right_child) {
        node-&gt;right_child = new EnumerativeIntervalTreeNode_(node-&gt;mid + 1LL, node-&gt;ub, node);
      }
      DoAdd(lb, ub, node-&gt;right_child);
    }
  }

  void DoRemove(ll lb, ll ub, EnumerativeIntervalTreeNode_* node) {
    assert(node);
    assert(lb &gt;= node-&gt;lb &amp;&amp; ub &lt;= node-&gt;ub);
    assert(lb &lt;= ub);
    if (node-&gt;mid &gt;= lb &amp;&amp; node-&gt;mid &lt;= ub) {
      assert(node-&gt;segments.count(MP(lb, ub)));
      node-&gt;segments.erase(node-&gt;segments.find(MP(lb, ub)));
      node-&gt;segments_reversed.erase(node-&gt;segments_reversed.find(MP(ub, lb)));
    } else if (ub &lt; node-&gt;mid) {
      assert(node-&gt;left_child);
      DoRemove(lb, ub, node-&gt;left_child);
    } else {
      assert(lb &gt; node-&gt;mid);
      assert(node-&gt;right_child);
      DoRemove(lb, ub, node-&gt;right_child);
    }

    if (!SZ(node-&gt;segments) &amp;&amp; !node-&gt;left_child &amp;&amp; !node-&gt;right_child &amp;&amp; node-&gt;parent) {
      // erase this node
      if (node-&gt;parent-&gt;left_child == node) {
        node-&gt;parent-&gt;left_child = 0;
      }
      if (node-&gt;parent-&gt;right_child == node) {
        node-&gt;parent-&gt;right_child = 0;
      }
      delete node;
    }
  }

  vector&lt; pair&lt;ll, ll&gt; &gt; enumerate_answer_;
  void DoEnumerate(ll lb, ll ub, EnumerativeIntervalTreeNode_* node) {
    assert(node);
    if (node-&gt;lb &gt; ub || node-&gt;ub &lt; lb) return;
    if (node-&gt;mid &gt;= lb &amp;&amp; node-&gt;mid &lt;= ub) {
      // add everyone
      FORIT(it, node-&gt;segments) enumerate_answer_.PB(*it);
    } else {
      if (lb &gt; node-&gt;mid) {
        // add those whose end points are to the right of lb
        for (multiset&lt; pair&lt;ll, ll&gt; &gt;::reverse_iterator it = node-&gt;segments_reversed.rbegin();
             it != node-&gt;segments_reversed.rend();
             ++it) {
          if (it-&gt;A &lt; lb) break;
          enumerate_answer_.PB(MP(it-&gt;B, it-&gt;A));
        }
      } else {
        assert(ub &lt; node-&gt;mid);
        // add those whose begin points are to the left of ub
        FORIT(it, node-&gt;segments) {
          if (it-&gt;A &gt; ub) break;
          enumerate_answer_.PB(*it);
        }
      }
    }
    if (node-&gt;left_child) DoEnumerate(lb, ub, node-&gt;left_child);
    if (node-&gt;right_child) DoEnumerate(lb, ub, node-&gt;right_child);
  }

 public:
  EnumerativeIntervalTree(ll lb, ll ub) {
    root_ = new EnumerativeIntervalTreeNode_(lb, ub, /* parent = */ 0);
  }
  ~EnumerativeIntervalTree() {
    delete root_;
  }
 public:
  void Add(ll lb, ll ub) {
    DoAdd(lb, ub, root_);
  }
  void Remove(ll lb, ll ub) {
    // removes ONE of this interval. Must be present.
    DoRemove(lb, ub, root_);
  }
  vector&lt; pair&lt;ll, ll&gt; &gt; Enumerate(ll lb, ll ub) {
    enumerate_answer_.clear();
    DoEnumerate(lb, ub, root_);
    sort(ALL(enumerate_answer_));
    return enumerate_answer_;
  }

};

// EnumerativeIntervalTree tree(lb, ub);
// tree.Add(lb, ub);  // log n
// tree.Remove(lb, ub);  // log n
// vector&lt; pair&lt;ll, ll&gt; &gt; segments = tree.Enumerate(lb, ub);  // log n + k log k, k = SZ(ret);

class UntangleOverlappingSegments {
  // for each segment inputted, returns the segments subset of the given
  // segment = given segment - part of segments that intersect other previously
  // given segments.
  // amortized n log n
 public:
  UntangleOverlappingSegments(ll lb, ll ub): tree_(lb, ub) {}
  vector&lt; pair&lt;ll, ll&gt; &gt; Dissect(ll lb, ll ub) {
    vector&lt;pair&lt;ll, ll&gt; &gt; overlappers = tree_.Enumerate(lb, ub);
    vector&lt;pair&lt;ll, ll&gt; &gt; res;
    ll cur_lb = lb;
    FORIT(it, overlappers) {
      tree_.Remove(it-&gt;A, it-&gt;B);
      // if stretches to the left...
      if (it-&gt;A &lt; lb) {
        assert(it-&gt;B &gt;= lb);
        tree_.Add(it-&gt;A, lb);
      }
      // if stretches to the right...
      if (it-&gt;B &gt; ub) {
        assert(it-&gt;A &lt;= ub);
        tree_.Add(ub, it-&gt;B);
      }
      if (cur_lb &lt; it-&gt;A) {
        // this part creates a new segment
        res.PB(MP(cur_lb, it-&gt;A));
      }
      cur_lb = it-&gt;B;
    }
    if (cur_lb &lt; ub) {
      res.PB(MP(cur_lb, ub));
    }
    tree_.Add(lb, ub);
    return res;
  }
 private:
  EnumerativeIntervalTree tree_;
};
// UntangleOverlappingSegments engine(lb, ub);
// vector&lt; pair&lt;ll, ll&gt; &gt; new_segments = engine.Dissect(lb, ub);  // the new parts of the segment</Snippet>			<Snippet Name="IntervalInclusiveQueryBatchOffline">template&lt;class C&gt;
class FenwickTree {
 public:
  FenwickTree (int n) {
    n_ = n;
    bit_ = new C[n_ + 10];
    FORN(i, n_) bit_[i+1] = 0;
  }
  
  ~FenwickTree () {
    delete[] bit_;
  }
  
  void Add(int pos, C val) {
    pos += 1;
    while (pos &lt;= n_) {
      bit_[pos] += val;
      pos += (pos &amp; -pos);
    }
  }
  
  C Sum(int ending) {
    ending += 1;
    if (ending &gt; n_) ending = n_;
    C retval = 0;
    while (ending &gt;= 1) {
      retval += bit_[ending];
      ending -= (ending &amp; -ending);
    }
    return retval;
  }

  C Range(int beg, int en) {
    return Sum(en) - Sum(beg-1);
  }

 private:
  int n_;
  C* bit_;
};

vector&lt;int&gt; BatchOfflineIntervalQueries(vector&lt; pair&lt;int, int&gt; &gt; intervals, vector&lt; pair&lt;int, int&gt; &gt; queries) {
  // for each interval, ask how many queries are inclusively included.
  // Assume that the range of the intervals are O(N).

  // First normalize the intervals
  int smallest = INF;
  int largest = -INF;
  int ni = SZ(intervals);
  int nq = SZ(queries);
  for (int i = 0; i &lt; ni; ++i) {
    assert(intervals[i].A &lt;= intervals[i].B);
    MX(largest, intervals[i].B);
    MN(smallest, intervals[i].A);
  }
  for (int i = 0; i &lt; nq; ++i) {
    assert(queries[i].A &lt;= queries[i].B);
    MX(largest, queries[i].B);
    MN(smallest, queries[i].A);
  }
  // normalize by substracting smallest
  for (int i = 0; i &lt; ni; ++i) {
    intervals[i].A -= smallest;
    intervals[i].B -= smallest;
  }
  for (int i = 0; i &lt; nq; ++i) {
    queries[i].A -= smallest;
    queries[i].B -= smallest;
  }
  largest -= smallest;
  sort(ALL(intervals));
  reverse(ALL(intervals));
  // Create the BIT
  FenwickTree&lt;int&gt; tree(largest+1);
  vector&lt; pair&lt;int, int&gt; &gt; sorted_queries;
  FORN(i, nq) sorted_queries.PB(MP(queries[i].A, i));
  sort(ALL(sorted_queries));
  reverse(ALL(sorted_queries));
  int interval_it = 0;
  int queries_it = 0;
  vector&lt;int&gt; answers(nq);
  for (int i = largest; i &gt;= 0; --i) {
    // insert the new nodes
    while (interval_it &lt; SZ(intervals) &amp;&amp; intervals[interval_it].A == i) {
      tree.Add(intervals[interval_it].B, 1);
      ++interval_it;
    }
    // answer the queries
    while (queries_it &lt; SZ(sorted_queries)) {
      int idx = sorted_queries[queries_it].B;
      if (queries[idx].A != i) break;
      answers[idx] = tree.Range(queries[idx].A, queries[idx].B);
      ++queries_it;
    }
  }
  return answers;
}

// BatchOfflineIntervalQueries([(1, 4), (2, 7)], [(1, 5), (2, 6)])
// list of daftar interval, list of daftar query
// return vector&lt;int&gt; of answers nya.
// n log n</Snippet>		</Category>
	</Category>
	<Category Name="DEBUG">
		<Snippet Name="DEBUGV">#define DEBUGV(x) \
		{ \
		cout &lt;&lt; '&gt;' &lt;&lt; #x &lt;&lt; ':'; \
		FORN(i,SZ((x))) cout &lt;&lt; ' ' &lt;&lt; x[i]; \
		cout &lt;&lt; '\n'; }</Snippet>		<Snippet Name="DEBUGVV">#define DEBUGVV(x) \
		{ \
		cout &lt;&lt; '&gt;' &lt;&lt; #x &lt;&lt; ':' &lt;&lt; '\n'; \
		FORN(i,SZ((x))) {\
			printf(&quot;%3d:&quot;,i); \
			FORN(j,SZ(x[i])) cout &lt;&lt; ' ' &lt;&lt; x[i][j]; \
			cout &lt;&lt; '\n';}}</Snippet>		<Snippet Name="DEBUGVVI">#define DEBUGVVI(x) \
		{ \
		cout &lt;&lt; '&gt;' &lt;&lt; #x &lt;&lt; ':' &lt;&lt; '\n'; \
		int maxnumberofelement=0;\
		FORN(i,SZ(x)) MX(maxnumberofelement,SZ(x[i]));\
		cout &lt;&lt; &quot;        &quot;;\
		FORN(i,maxnumberofelement) printf(&quot; %7d&quot;,i);\
		cout &lt;&lt; endl;\
		FORN(i,SZ((x))) {\
			printf(&quot;%7d:&quot;,i); \
			FORN(j,SZ(x[i])) printf(&quot; %7d&quot;,x[i][j]); \
			cout &lt;&lt; '\n';}}</Snippet>		<Snippet Name="DEBUGVS">#define DEBUGVS(x) \
		{ \
		cout &lt;&lt; '&gt;' &lt;&lt; #x &lt;&lt; ':' &lt;&lt; '\n'; \
		FORN(i,SZ((x))) {\
			printf(&quot;%3d:&quot;,i); \
			cout &lt;&lt; ' ' &lt;&lt; x[i]; \
			cout &lt;&lt; '\n';}}</Snippet>		<Snippet Name="DEBUG_COMPLETE">
#define DEBUGV(x) \
		{ \
		cout &lt;&lt; '&gt;' &lt;&lt; #x &lt;&lt; ':'; \
		FORN(i,SZ((x))) cout &lt;&lt; ' ' &lt;&lt; x[i]; \
		cout &lt;&lt; '\n'; }

#define DEBUGVV(x) \
		{ \
		cout &lt;&lt; '&gt;' &lt;&lt; #x &lt;&lt; ':' &lt;&lt; '\n'; \
		FORN(i,SZ((x))) {\
			printf(&quot;%3d:&quot;,i); \
			FORN(j,SZ(x[i])) cout &lt;&lt; ' ' &lt;&lt; x[i][j]; \
			cout &lt;&lt; '\n';}}

#define DEBUGVVI(x) \
		{ \
		cout &lt;&lt; '&gt;' &lt;&lt; #x &lt;&lt; ':' &lt;&lt; '\n'; \
		int maxnumberofelement=0;\
		FORN(i,SZ(x)) MX(maxnumberofelement,SZ(x[i]));\
		cout &lt;&lt; &quot;        &quot;;\
		FORN(i,maxnumberofelement) printf(&quot; %7d&quot;,i);\
		cout &lt;&lt; endl;\
		FORN(i,SZ((x))) {\
			printf(&quot;%7d:&quot;,i); \
			FORN(j,SZ(x[i])) printf(&quot; %7d&quot;,x[i][j]); \
			cout &lt;&lt; '\n';}}

#define DEBUGVS(x) \
		{ \
		cout &lt;&lt; '&gt;' &lt;&lt; #x &lt;&lt; ':' &lt;&lt; '\n'; \
		FORN(i,SZ((x))) {\
			printf(&quot;%3d:&quot;,i); \
			cout &lt;&lt; ' ' &lt;&lt; x[i]; \
			cout &lt;&lt; '\n';}}
</Snippet>	</Category>
	<Category Name="STRING">
		<Category Name="DATASTRUCTURE">
			<Snippet Name="Ukkonen">class SuffixTreeNode;

class SuffixTreeEdge {
 public:
  SuffixTreeEdge(SuffixTreeNode* destination, int lower_limit,
                 int upper_limit)
      : destination_(destination), lower_limit_(lower_limit),
        upper_limit_(upper_limit) {}

  SuffixTreeNode* destination_;

  // Keeps which part of the string variable marks this edge.
  // Inclusive.
  int lower_limit_;
  int upper_limit_;

  int Size() const {
    return upper_limit_ - lower_limit_ + 1;
  }
};

class SuffixTreeNode {
 public:
  // Put 0 as alphabet_count to denote this is a leaf.
  SuffixTreeNode(int alphabet_count, bool is_terminal)
      : edges_(alphabet_count), is_terminal_(is_terminal) {}

  bool IsLeaf() const {
    return edges_.size() == 0;
  }

  // If this is empty, it denotes that this node is a leaf.
  vector&lt;SuffixTreeEdge*&gt; edges_;

  // If there exists a suffix ending here. Must be manually set
  bool is_terminal_;
};

class UkkonenNode : public SuffixTreeNode {
 public:
  UkkonenNode(int alphabet_count, UkkonenNode* parent, int depth)
      : SuffixTreeNode(alphabet_count, /* is_terminal = */ false),
        parent_(parent),
        depth_(depth),
        link_(NULL) {}

  void SetLink(UkkonenNode* link) {
    assert(link_ == NULL);
    assert(!IsLeaf());
    if (parent_ == NULL) {
      assert(link == this);
    }
    link_ = link;
  }

  UkkonenNode* parent_;

  // The number of characters in this node's path label. Doesn't apply
  // to leaves, you can leave it to any value you wish.
  int depth_;

  // Suffix Link.
  UkkonenNode* link_;
};

enum UkkonenEnum {
  kUkkonenEndOfSequence = -1
};

int UkkonenEdgeSize(const SuffixTreeEdge&amp; edge, int iteration) {
  if (edge.upper_limit_ != kUkkonenEndOfSequence) {
    return edge.Size();
  } else {
    return iteration - edge.lower_limit_;
  }
}

void FinalizeUkkonen(SuffixTreeNode* node, int alphabet_size, int seq_length) {
  if (node-&gt;IsLeaf()) {
    node-&gt;is_terminal_ = true;
    return;
  }

  if (node-&gt;edges_[alphabet_size - 1] != NULL) {
    assert(node-&gt;edges_[alphabet_size - 1]-&gt;upper_limit_ ==
           kUkkonenEndOfSequence);
    assert(node-&gt;edges_[alphabet_size - 1]-&gt;lower_limit_ ==
           seq_length - 1);
    delete node-&gt;edges_[alphabet_size - 1]-&gt;destination_;
    delete node-&gt;edges_[alphabet_size - 1];
    node-&gt;is_terminal_ = true;
  }

  node-&gt;edges_.pop_back();
  for (int i = 0; i &lt; alphabet_size - 1; ++i) {
    if (node-&gt;edges_[i] != NULL) {
      if (node-&gt;edges_[i]-&gt;upper_limit_ == kUkkonenEndOfSequence) {
        node-&gt;edges_[i]-&gt;upper_limit_ = seq_length - 2;
      }
      assert(node-&gt;edges_[i]-&gt;lower_limit_ &lt;= node-&gt;edges_[i]-&gt;upper_limit_);
      assert(node-&gt;edges_[i]-&gt;lower_limit_ &gt;= 0);
      assert(node-&gt;edges_[i]-&gt;upper_limit_ &lt;= seq_length - 2);
      FinalizeUkkonen(node-&gt;edges_[i]-&gt;destination_,
                      alphabet_size, seq_length);
    }
  }

}

SuffixTreeNode* Ukkonen(int alphabet_size, vector&lt;int&gt; sequence) {
  assert(alphabet_size &gt;= 0);
  for (int i = 0; i &lt; (int)sequence.size(); ++i) {
    assert(sequence[i] &gt;= 0 &amp;&amp; sequence[i] &lt; alphabet_size);
  }

  // Append sentinel
  sequence.push_back(alphabet_size);
  ++alphabet_size;

  UkkonenNode* root = new UkkonenNode(alphabet_size, NULL, 0);
  root-&gt;SetLink(root);

  UkkonenNode* last = root;
  UkkonenNode* credit = NULL;
  int last_phase = 0;

  for (int i = 0; i &lt; (int)sequence.size(); ++i) {
    int init = 1;
    for (int j = last_phase; j &lt;= i; ++j, ++last_phase) {
      // Length of suffix seeked
      int seeklen = i - j;
      // We're looking for the node [j..i-1]

      // Backtrack one position. The reason is the suffix link for
      // current node has not been found.
      if (last != root &amp;&amp; !init) {
        last = last-&gt;parent_;
      }

      // Follow the suffix link
      if (!init) last = last-&gt;link_;
      init = 0;

      assert(!last-&gt;IsLeaf());

      // Forward while edge is less than what we want
      while (true) {
        if (last-&gt;depth_ &gt;= seeklen) {
          assert(last-&gt;depth_ == seeklen);
          break;
        }
        int num = sequence[j + last-&gt;depth_];
        if (last-&gt;edges_[num] == NULL) {
          break;
        }
        if (last-&gt;depth_ + UkkonenEdgeSize(*last-&gt;edges_[num], i) &gt;
            seeklen) {
          break;
        }
        if (last-&gt;edges_[num]-&gt;destination_-&gt;IsLeaf()) break;
        last = (UkkonenNode*)last-&gt;edges_[num]-&gt;destination_;
      }

      assert(!last-&gt;IsLeaf());

      // We have arrived at the potential-suffix-link node
      // There are several cases

      // First, we may need to create a new internal node
      int num = sequence[j + last-&gt;depth_];
      if (last-&gt;edges_[num] != NULL &amp;&amp;
          last-&gt;depth_ + UkkonenEdgeSize(*last-&gt;edges_[num], i) &gt;
              seeklen) {
        int diff = seeklen - last-&gt;depth_;
        if (diff == 0) {
          // assert(seeklen == 0);
        } else {
          assert(i == j + last-&gt;depth_ + diff);

          if (sequence[i] !=
              sequence[last-&gt;edges_[num]-&gt;lower_limit_ + diff]) {
            // New internal node must be created
            UkkonenNode* internal_node =
                new UkkonenNode(alphabet_size, last, last-&gt;depth_ + diff);
            int old_num = sequence[last-&gt;edges_[num]-&gt;lower_limit_ + diff];
            internal_node-&gt;edges_[old_num] = new SuffixTreeEdge(
                last-&gt;edges_[num]-&gt;destination_,
                last-&gt;edges_[num]-&gt;lower_limit_ + diff,
                last-&gt;edges_[num]-&gt;upper_limit_);

            last-&gt;edges_[num]-&gt;destination_ = internal_node;
            last-&gt;edges_[num]-&gt;upper_limit_ =
                last-&gt;edges_[num]-&gt;lower_limit_ + diff - 1;

            assert(sequence[i] != old_num);

            last = internal_node;
            num = sequence[j + last-&gt;depth_];
          }
        }
      }

      // Link credit, if any
      if (credit != NULL) {
        assert(credit-&gt;link_ == NULL);
        credit-&gt;link_ = last;
      }

      // Update credit, if any
      credit = NULL;
      if (last-&gt;link_ == NULL) {
        credit = last;
      }

      // Now we are sure to be in the right place.
      if (last-&gt;edges_[num] != NULL) {
        // Testing for leaf extension
        if (UkkonenEdgeSize(*last-&gt;edges_[num], i) + last-&gt;depth_ ==
            seeklen) {
          assert(
              last-&gt;edges_[num]-&gt;upper_limit_ == kUkkonenEndOfSequence);
          assert(last-&gt;edges_[num]-&gt;destination_-&gt;IsLeaf());
          continue;
        }

        assert(UkkonenEdgeSize(*last-&gt;edges_[num], i) + last-&gt;depth_ &gt;
               seeklen);

        assert(sequence[i] == sequence[last-&gt;edges_[num]-&gt;lower_limit_ +
               (seeklen - last-&gt;depth_)]);

        // Rule 3, the shit already exists!
        assert(credit == NULL);
        break;
      }

      // Rule ???, we must create a new shit
      assert(num == sequence[i]);

      UkkonenNode* new_leaf = new UkkonenNode(0, last, 0);
      last-&gt;edges_[num] =
          new SuffixTreeEdge(new_leaf, i, kUkkonenEndOfSequence);
    }
  }

  // Now, all done. Let's fix this shit
  FinalizeUkkonen(root, alphabet_size, (int)sequence.size());
  return root;
}

// SuffixTreeNode* root = Ukkonen(26, {0, 1, 0, 24, 3, 25, 1})
// Itu jadi suffix tree
// node-&gt;is_terminal_ true kalau ada suffix yg end di situ
// (true buat empty string, i.e., root)
//
// node-&gt;IsLeaf() kalo true dia ga ada edge
// kalo false ada edge sebanyak alphabet (26 di atas)
// node-&gt;edges_[i] utk alphabet ke-i, NULL kalo ga ada
// kalo ada, node-&gt;edges_[i]-&gt;lower_limit_ dan upper_limit_ buat content
// node-&gt;edges_[i]-&gt;destination_ buat destinationnya</Snippet>			<Snippet Name="suffixarray">//n log^2 n

vector&lt;int&gt; suffixarray(string a) {
	vector&lt;int&gt; d(SZ(a),0);

	int iterate = 0;
	int bz = SZ(a);
	while (bz &gt; 0) {
		iterate++;
		bz /= 2;
		}

	if (iterate &gt;= 20) {
		printf(&quot;OVERFLOW ITERATION, PLEASE CHANGE 20 TO SOMETHING\n&quot;);
		return d;
		}

	FORN(i,SZ(a)) d[i] = a[i] - 'A';

	FORN(i,iterate) {
		vector&lt; pair&lt; pair&lt;int,int&gt;, int&gt; &gt; vp;
		FORN(j,SZ(a)) {
			int dpn = d[j];
			int blk = -100;
			if (j+(1 &lt;&lt; i) &lt; SZ(a)) blk = d[j+(1 &lt;&lt; i)];
			vp.PB(MP(MP(dpn,blk),j));
			}
		sort(ALL(vp));
		FORN(j,SZ(vp)) {
			d[vp[j].B] = j;
			if (j != 0 &amp;&amp; vp[j].A == vp[j-1].A) d[vp[j].B] = d[vp[j-1].B];
			}
		}
	return d;
	}</Snippet>			<Snippet Name="Weiner">class SuffixTreeNode;

class SuffixTreeEdge {
 public:
  SuffixTreeEdge(SuffixTreeNode* destination, int lower_limit,
                 int upper_limit)
      : destination_(destination), lower_limit_(lower_limit),
        upper_limit_(upper_limit) {}

  SuffixTreeNode* destination_;

  // Keeps which part of the string variable marks this edge.
  // Inclusive.
  int lower_limit_;
  int upper_limit_;

  int Size() const {
    return upper_limit_ - lower_limit_ + 1;
  }
};

class SuffixTreeNode {
 public:
  // Put 0 as alphabet_count to denote this is a leaf.
  SuffixTreeNode(int alphabet_count, bool is_terminal)
      : edges_(alphabet_count), is_terminal_(is_terminal) {}

  bool IsLeaf() const {
    return edges_.size() == 0;
  }

  // If this is empty, it denotes that this node is a leaf.
  vector&lt;SuffixTreeEdge*&gt; edges_;

  // If there exists a suffix ending here.
  bool is_terminal_;
};

class WeinerNode : public SuffixTreeNode {
 public:
  WeinerNode(int alphabet_count, int depth, WeinerNode* parent, bool is_leaf)
      : SuffixTreeNode(is_leaf ? 0 : alphabet_count, /* is_terminal = */ false),
        links_(alphabet_count),
        indicator_(alphabet_count, false),
        depth_(depth),
        parent_(parent) {}

  // L and I vectors as in Gusfield's book. These are empty if the
  // node is a leaf.
  vector&lt;WeinerNode* &gt; links_;
  vector&lt;bool&gt; indicator_;

  // Length of the pathlen until this node.
  int depth_;

  WeinerNode* parent_;
};

void FinalizeWeiner(SuffixTreeNode* node, int alphabet_size, int seq_length) {
  if (node-&gt;IsLeaf()) {
    node-&gt;is_terminal_ = true;
    return;
  }

  if (node-&gt;edges_[alphabet_size - 1] != NULL) {
    assert(node-&gt;edges_[alphabet_size - 1]-&gt;upper_limit_ ==
           seq_length - 1);
    assert(node-&gt;edges_[alphabet_size - 1]-&gt;lower_limit_ ==
           seq_length - 1);
    delete node-&gt;edges_[alphabet_size - 1]-&gt;destination_;
    delete node-&gt;edges_[alphabet_size - 1];
    node-&gt;is_terminal_ = true;
  }

  node-&gt;edges_.pop_back();
  for (int i = 0; i &lt; alphabet_size - 1; ++i) {
    if (node-&gt;edges_[i] != NULL) {
      if (node-&gt;edges_[i]-&gt;upper_limit_ == seq_length - 1) {
        node-&gt;edges_[i]-&gt;upper_limit_ = seq_length - 2;
      }
      assert(node-&gt;edges_[i]-&gt;lower_limit_ &lt;= node-&gt;edges_[i]-&gt;upper_limit_);
      assert(node-&gt;edges_[i]-&gt;lower_limit_ &gt;= 0);
      assert(node-&gt;edges_[i]-&gt;upper_limit_ &lt;= seq_length - 2);
      FinalizeWeiner(node-&gt;edges_[i]-&gt;destination_,
                     alphabet_size, seq_length);
    }
  }

}

SuffixTreeNode* Weiner(int alphabet_size, vector&lt;int&gt; sequence) {

  assert(alphabet_size &gt;= 0);
  for (int i = 0; i &lt; SZ(sequence); ++i) {
    assert(sequence[i] &gt;= 0 &amp;&amp; sequence[i] &lt; alphabet_size);
  }

  // Add a sentinel node so that no suffix is a prefix of other suffix.
  sequence.push_back(alphabet_size);
  ++alphabet_size;

  WeinerNode* root = new WeinerNode(alphabet_size, 0, NULL, /* is_leaf = */ false);

  WeinerNode* last = root;
  for (int i = SZ(sequence) - 1; i &gt;= 0; --i) {
    // Traverse back finding v and v'
    WeinerNode* v = NULL;
    WeinerNode* va = NULL;

    int num = sequence[i];

    while (true) {
      assert(v == NULL || last-&gt;indicator_[num]);
      if (last-&gt;indicator_[num] &amp;&amp; v == NULL) {
        v = last;
      }

      // We update for the next iteration
      last-&gt;indicator_[num] = true;

      if (last-&gt;links_[num] != NULL) {
        assert(v != NULL);
        assert(va == NULL);
        va = last;
        break;
      }

      if (last == root) break;
      last = last-&gt;parent_;
    }

    // There are three cases.
    assert(!(va != NULL &amp;&amp; v == NULL));
    assert(va != NULL || last == root);

    if (va == NULL &amp;&amp; v == NULL) {
      // The not found case.
      assert(last == root);
      assert(last-&gt;indicator_[num]);
      assert(last-&gt;edges_[num] == NULL);

      // In this case, S[i] was never found.
      // So, we create a new leaf.
      WeinerNode* new_leaf = new WeinerNode(alphabet_size, SZ(sequence) - i,
                                            last, /* is_leaf = */ true);
      last-&gt;edges_[num] = new SuffixTreeEdge(new_leaf, i, SZ(sequence) - 1);

      last = new_leaf;
      continue;
    }

    int diff = 0;

    if (v != NULL &amp;&amp; va == NULL) {
      // This is equivalent with the good case
      assert(last == root);
      va = root;
      diff = v-&gt;depth_ + 1;
    } else {
      assert(!va-&gt;IsLeaf());
      assert(va-&gt;links_[num] != NULL);
      diff = v-&gt;depth_ - va-&gt;depth_;
      va = va-&gt;links_[num];
    }

    assert(va != NULL || v == NULL);
    assert(!v-&gt;IsLeaf());
    assert(!va-&gt;IsLeaf());

    // Both va and v must be found.
    // Furthermore, it must be the suffix starting in va, of diff length.

    // First, we check if we need to create a new internal node.
    if (diff != 0) {
      int new_num = sequence[i + va-&gt;depth_];
      assert(va-&gt;edges_[new_num] != NULL);
      assert(va-&gt;edges_[new_num]-&gt;Size() &gt; diff);

      WeinerNode* internal_node =
          new WeinerNode(alphabet_size, va-&gt;depth_ + diff, va, /* is_leaf = */ false);
      assert(!internal_node-&gt;IsLeaf());

      WeinerNode* child = (WeinerNode*)va-&gt;edges_[new_num]-&gt;destination_;

      // First, create the new edge and update the old one.
      internal_node-&gt;edges_[sequence[va-&gt;edges_[new_num]-&gt;lower_limit_ + diff]] =
          new SuffixTreeEdge(child,
                             va-&gt;edges_[new_num]-&gt;lower_limit_ + diff,
                             va-&gt;edges_[new_num]-&gt;upper_limit_);

      va-&gt;edges_[new_num]-&gt;upper_limit_ =
          va-&gt;edges_[new_num]-&gt;lower_limit_ + diff - 1;
      va-&gt;edges_[new_num]-&gt;destination_ = internal_node;
      child-&gt;parent_ = internal_node;

      // Copies the indicator vector from child.
      internal_node-&gt;indicator_ = child-&gt;indicator_;

      // Updates the link vector from v to here.
      v-&gt;links_[num] = internal_node;

      va = internal_node;
    }

    // Now, we are sure va does not have that.
    assert(va-&gt;depth_ &lt; (SZ(sequence) - i));
    assert(!va-&gt;IsLeaf());

    int ask_num = sequence[i + va-&gt;depth_];
    assert(va-&gt;edges_[ask_num] == NULL);

    // Finally, insert an edge here
    WeinerNode* new_leaf = new WeinerNode(alphabet_size, SZ(sequence) - i,
                                          va, /* is_leaf = */ true);
    va-&gt;edges_[ask_num] = new SuffixTreeEdge(new_leaf, i + va-&gt;depth_,
                                             SZ(sequence) - 1);

    last = new_leaf;
  }

  FinalizeWeiner(root, alphabet_size, SZ(sequence));
  return root;
}

// SuffixTreeNode* root = Weiner(26, {0, 1, 0, 24, 3, 25, 1})
// Itu jadi suffix tree
// node-&gt;is_terminal_ true kalau ada suffix yg end di situ
// (true buat empty string, i.e., root)
//
// node-&gt;IsLeaf() kalo true dia ga ada edge
// kalo false ada edge sebanyak alphabet (26 di atas)
// node-&gt;edges_[i] utk alphabet ke-i, NULL kalo ga ada
// kalo ada, node-&gt;edges_[i]-&gt;lower_limit_ dan upper_limit_ buat content
// node-&gt;edges_[i]-&gt;destination_ buat destinationnya</Snippet>		</Category>
		<Category Name="BASIC">
			<Snippet Name="IsPalindrome">int IsPalindrome(string str) {
  string reversed_str = str;
  reverse(ALL(str));
  return reversed_str == str;
}
//IsPalindrome(&quot;papap&quot;) == 1</Snippet>		</Category>
		<Category Name="RARE">
			<Snippet Name="makeuppercase">string makeuppercase(string abc) {
	FORN(i,SZ(abc)) if ('a' &lt;= abc[i] &amp;&amp; abc[i] &lt;= 'z') abc[i] = toupper(abc[i]);
	return abc;
	}</Snippet>		</Category>
		<Snippet Name="kmp">vint kmp (string findthis, string fromhere) {

	//bikin tabel itu
	int n = SZ(fromhere),m=SZ(findthis);
	vint returnto(m+1,0);

	returnto[1] = 0;
	int q = 0; //terakhir return ke sini
	REP(i,2,m+1) {
		while (q &amp;&amp; findthis[q] != findthis[i-1]) {
			q = returnto[q];
			}
		if (findthis[q] == findthis[i-1]) q++;
		returnto[i] = q;
		}

	//core

	q = 0;
	vint ret;
	FORN(i,n) {
		//kalo ga cocok balik
		while (q &amp;&amp; fromhere[i] != findthis[q]) q = returnto[q];

		//terakhirnya dicek oke ga?
		if (fromhere[i] == findthis[q]) q++;

		//correct?
		if (q == m) {
			ret.PB(i-m+1);
			//next please
			q = returnto[q];
			}

		}
	return ret;
	}</Snippet>		<Snippet Name="StringSplit">vector&lt;string&gt; StringSplit(string input_str,char separator = ' ') {
	input_str += separator;
	vector&lt;string&gt; ret;
	string running_sum = &quot;&quot;;
	FORIT(i,input_str) {
		if ((*i) == separator) {
			if (running_sum != &quot;&quot;) ret.push_back(running_sum);
			running_sum = &quot;&quot;;
			continue;
			}
		running_sum += (*i);
		}

	return ret;
	}
//vector&lt;string&gt; = StringSplit(&quot; ivana  jahja&quot;, ' ') -&gt; {&quot;ivana&quot;,&quot;jahja&quot;}</Snippet>		<Snippet Name="LongestPrefixMatch">// For each position, the longest prefix of str matched by the prefix of
// the substring starting at that position
vector&lt;int&gt; LongestPrefixMatch(const string&amp; str) {
  vector&lt;int&gt; ret;
  ret.push_back(SZ(str));
  int l = 0;
  int r = 0;
  for (int si = 1; si &lt; SZ(str); ++si) {
    if (r &lt; si) {
      // no previous information is useful
      int matchlen = 0;
      for (int sj = si; sj &lt; SZ(str); ++sj) {
        if (str[sj] != str[sj-si]) break;
        ++matchlen;
      }
      if (matchlen) {
        r = si+matchlen-1;
        l = si;
      }
      ret.push_back(matchlen);
    } else {
      // a previous information is reusable
      int matched = ret[si - l];
      if (matched &lt; r - si + 1) {
        ret.push_back(matched);
      } else {
        matched = r - si + 1;
        while (r+1 &lt; SZ(str) &amp;&amp; matched &lt; SZ(str) &amp;&amp; str[matched] == str[r+1]) {
          ++matched;
          ++r;
        }
        ret.push_back(matched);
        l = si;
      }
    }
  }
  return ret;
}</Snippet>		<Category Name="SuffixArray">
			<Snippet Name="SuffixArray">// N log^2 N implementation of suffix array
class SuffixArray {
 public:
  SuffixArray(vector&lt;int&gt; arr) {
    n_ = SZ(arr);
    levels_ = 1;
    int number = 1;
    while (number &lt; n_) {
      number *= 2;
      levels_ += 1;
    }
    log_order_ = new int*[levels_];
    for (int i = 0; i &lt; levels_; ++i) {
      log_order_[i] = new int[n_];
    }
    vector&lt; pair&lt;int,int&gt; &gt; prelim_sort;
    FORN(i, n_) prelim_sort.PB(MP(arr[i], i));
    sort(ALL(prelim_sort));
    FORN(i, n_) {
      log_order_[0][prelim_sort[i].B] = i;
      if (i &amp;&amp; prelim_sort[i].A == prelim_sort[i-1].A) {
        log_order_[0][prelim_sort[i].B] = log_order_[0][prelim_sort[i-1].B];
      }
    }
    int* buffer = new int[n_];
    REP(i, 1, levels_) {
      FORN(j, n_) buffer[j] = j;
      STATIC_current_level_ = i-1;
      STATIC_log_order_ = log_order_;
      STATIC_n_ = n_;
      sort(buffer, buffer + n_, SuffixArray::CompareMergeSuffix_);
      // okay sorted &lt;3
      FORN(j, n_) {
        log_order_[i][buffer[j]] = j;
        if (j &amp;&amp;
            buffer[j] + (1 &lt;&lt; (i-1)) &lt; n_ &amp;&amp;
            buffer[j-1] + (1 &lt;&lt; (i-1)) &lt; n_ &amp;&amp;
            log_order_[i-1][buffer[j]] == log_order_[i-1][buffer[j-1]] &amp;&amp;
            log_order_[i-1][buffer[j] + (1 &lt;&lt; (i-1))] == log_order_[i-1][buffer[j-1] + (1 &lt;&lt; (i-1))]) {
          log_order_[i][buffer[j]] = log_order_[i][buffer[j-1]];
        }
      }
    }
    delete[] buffer;
    // assert
  }
  ~SuffixArray() {
    FORN(i, levels_) delete[] log_order_[i];
    delete[] log_order_;
  }
  int Get(int startpos) {
    return log_order_[levels_-1][startpos];
  }
  int LongestCommonPrefix(int pos1, int pos2) {
    if (pos1 == pos2) return n_ - pos1;
    int res = 0;
    for (int i = levels_ - 1; i &gt;= 0; --i) {
      if (pos1 &lt; n_ &amp;&amp; pos2 &lt; n_ &amp;&amp; log_order_[i][pos1] == log_order_[i][pos2]) {
        res += (1 &lt;&lt; i);
        pos1 += (1 &lt;&lt; i);
        pos2 += (1 &lt;&lt; i);
      }
    }
    return res;
  }
 private:
  static int STATIC_current_level_;
  static int STATIC_n_;
  static int** STATIC_log_order_;
  static bool CompareMergeSuffix_(int p1, int p2) {
    if (STATIC_log_order_[STATIC_current_level_][p1] != STATIC_log_order_[STATIC_current_level_][p2]) {
      return STATIC_log_order_[STATIC_current_level_][p1] &lt; STATIC_log_order_[STATIC_current_level_][p2];
    }
    if (p1 + (1 &lt;&lt; STATIC_current_level_) &gt;= STATIC_n_) {
      assert(p2 + (1 &lt;&lt; STATIC_current_level_) &lt; STATIC_n_);
      return true;
    }
    if (p2 + (1 &lt;&lt; STATIC_current_level_) &gt;= STATIC_n_) {
      return false;
    }
    return STATIC_log_order_[STATIC_current_level_][p1 + (1 &lt;&lt; STATIC_current_level_)] &lt;
           STATIC_log_order_[STATIC_current_level_][p2 + (1 &lt;&lt; STATIC_current_level_)];
  }
  int n_;  // number of elements
  int levels_;  // number of levels
  int** log_order_;  // log_order[x][i]: order of substring of length 2^x starting at i
};

int SuffixArray::STATIC_current_level_;
int SuffixArray::STATIC_n_;
int** SuffixArray::STATIC_log_order_;

// SuffixArray sarray(vector&lt;int&gt;);
// sarray.Get(i);  // who is the i-th largest?
// sarray.LongestCommonPrefix(i, j);</Snippet>		</Category>
	</Category>
	<Category Name="SEQUENCE">
		<Snippet Name="partition">template &lt;class _c&gt;
vector&lt; vector&lt; _c &gt; &gt; partition(vector&lt; _c &gt; sequence, int partsize, int startlocation=0, int partitionall=1) {
	if (partitionall) {
		startlocation -= (startlocation / partsize) * partsize;
		if (startlocation &gt; 0) startlocation -= partsize;
		}
	vector&lt; vector&lt; _c &gt; &gt; retvvc;
	REP(i,startlocation,SZ(sequence)) {
		vector&lt; _c &gt; vckecil;
		FORN(j,partsize) if (i+j &gt;= 0 &amp;&amp; i+j &lt; SZ(sequence)) vckecil.PB(sequence[i+j]);
		retvvc.PB(vckecil);
		i += (partsize-1);
		}
	return retvvc;
	}

/*
vector&lt;int&gt; a(5,3);
vector&lt; vint &gt; partition(a,2); -&gt; {{3,3},{3,3},3}
*/</Snippet>		<Snippet Name="CountFrequency">template &lt;class CItem&gt;
vector&lt; pair&lt;CItem,int&gt; &gt; CountFrequency(vector&lt;CItem&gt; items) {
	if (SZ(items) == 0) {
		return vector&lt; pair&lt;CItem, int&gt; &gt;();
	}
	sort(ALL(items));
	CItem last_element = items[0];
	int last_count = 1;
	vector&lt; pair&lt;CItem, int&gt; &gt; ret;
	REP(i, 1, SZ(items)) {
		if (items[i] == last_element) {
			++last_count;
			continue;
		} else {
			if (last_count) {
				ret.PB(MP(last_element,last_count));
			}
			last_element = items[i];
			last_count = 1;
		}
	}
	if (last_count) ret.PB(MP(last_element, last_count));
	return ret;
}

//vector&lt; sesuatu &gt; a = {1,2,5,4,4,2,2,2}
//vector&lt; pair&lt;sesuatu, int&gt; &gt; vp = CountFrequency(a);
//hasilnya &lt;1,1&gt;, &lt;2,4&gt;, &lt;4,2&gt;, &lt;5,1&gt;</Snippet>		<Snippet Name="SequenceSimplify">//O(n log n)
vector&lt;int&gt; SequenceSimplify(vector&lt;int&gt; seq) {
	int lowest = 0;
	vector&lt;int&gt; disort = seq;
	sort(ALL(disort));
	disort.erase(unique(ALL(disort)),disort.end());
	FORN(i,SZ(seq)) {
		seq[i] = (lower_bound(ALL(disort),seq[i]) - disort.begin()) + lowest;
		}
	return seq;
	}

//vint a = {10, 50, 5, 50, 10, 70}
//SequenceSimplify(a) = {1, 2, 0, 2, 1, 3}</Snippet>		<Snippet Name="MapSimplify">template &lt;class CType&gt;
map&lt;CType, int&gt; MapSimplify(vector&lt;CType&gt; sequence) {
	map&lt;CType, int&gt; retmap;
	sort(ALL(sequence));
	sequence.erase(unique(ALL(sequence)), sequence.end());
	FORN(i,SZ(sequence)) retmap[sequence[i]] = i;
	return retmap;
}

//vector&lt;string&gt; a = {&quot;ir&quot;, &quot;gan&quot;, &quot;aa&quot;, &quot;gan&quot;}
//map&lt;string, int&gt; ri = MapSimplify(a);
//ri[&quot;aa&quot;] == 0, ri[&quot;gan&quot;] == 1, ri[&quot;ir&quot;] == 2;</Snippet>		<Snippet Name="ReversedIndex">template &lt;class CType1&gt;
map&lt;CType1, int&gt; ReversedIndex(vector&lt;CType1&gt; sequence) {
	map&lt;CType1, int&gt; retmap;
	FORN(i,SZ(sequence)) retmap[sequence[i]] = i;
	return retmap;
}
//vector&lt;string&gt; a = {&quot;irvan, ganteng&quot;}
//map&lt;string, int&gt; ri = ReversedIndex(a);
//ri[&quot;ganteng&quot;] == 1;</Snippet>		<Snippet Name="IsPrefix">template&lt;class T&gt;
bool IsPrefix(const vector&lt;T&gt;&amp; prefix, const vector&lt;T&gt;&amp; text) {
  if (SZ(prefix) &gt; SZ(text)) return 0;
  FORN(i, SZ(prefix)) if (text[i] != prefix[i]) return 0;
  return 1;
}</Snippet>	</Category>
	<Category Name="GAME">
		<Snippet Name="mex">int mex (vector&lt;int&gt; a) {
	sort(ALL(a));
	int ret=0;
	FORN(i,SZ(a)) {
		if (ret == a[i]) ret++;
		}
	return ret;
	}

/*
vector&lt;int&gt; seq
int a = mex(seq);
*/</Snippet>		<Snippet Name="nimsum">int nimsum(vector&lt; int &gt; a) {
	REP(i,1,SZ(a)) a[0] ^= a[i];
	return a[0];
	}

/*
vector&lt;int&gt; a
int b = nimsum(a);
*/</Snippet>		<Snippet Name="getnextstep">//index a, kurangin sebanyak b. index -1 kalo impossible to win
pair&lt;int,int&gt; getnextstep(vector&lt; int &gt; a) {
	int ns = nimsum(a);
	FORN(i,SZ(a)) if (a[i] ^ ns &lt; a[i]) return MP(i,a[i] - (a[i] ^ ns));
	return MP(-1,-1);
	}

/*
vector&lt;int&gt; a
int index = getnextstep(a).A, kurangsebanyak = getnextstep(a).B
*/</Snippet>	</Category>
	<Category Name="STLEXTENSION">
		<Category Name="CASTING">
			<Snippet Name="StrToInt">int StrToInt (std::string inputstr) {
	int ret;
	sscanf(inputstr.c_str(),&quot;%d&quot;,&amp;ret);
	return ret;
	}</Snippet>			<Snippet Name="StrToLL">ll StrToLL (std::string inputstr) {
	ll ret;
	sscanf(inputstr.c_str(),&quot;%lld&quot;,&amp;ret);
	return ret;
}</Snippet>			<Snippet Name="IntToStr">string IntToStr(int inputint) {
	char temporary[13];
	sprintf(temporary,&quot;%d&quot;,inputint);
	return temporary;
}</Snippet>			<Snippet Name="LLToStr">string LLToStr(ll inputll) {
	char temporary[26];
	sprintf(temporary,&quot;%lld&quot;,inputll);
	return temporary;
}</Snippet>		</Category>
		<Category Name="FUNCTOR">
			<Snippet Name="CmpDbEqual">struct CmpDbEqual {
	bool operator()(const double d1, const double d2) {
		return abs(d1-d2) &lt;= EPS;
	}
};</Snippet>			<Snippet Name="CmpReverseYOrder">struct CmpReverseYOrder {
  bool operator() (const pair&lt;int, Point&gt; arg1,
                   const pair&lt;int, Point&gt; arg2) {
    return PointLess(arg1.B, arg2.B);
  }
};
// order biggest Y first, then smallest X</Snippet>		</Category>
		<Snippet Name="tri w/o comparator">template &lt;class _c1, class _c2, class _c3&gt;
struct tri {
	_c1 first; _c2 second; _c3 C;

	//CONSTRUCTOR
	tri( _c1 a1, _c2 a2, _c3 a3) {
		first = a1,second = a2,C = a3;
		}
	tri() {
		first = 0;
		second = 0;
		C = 0;
		}
	};</Snippet>		<Snippet Name="MapHash">class MapHash {
  public:
  	MapHash(int row, int col) : row_(row), col_(col) {}
  	int Get(int r,int c) const {
  		if (r &lt; 0 || r &gt;= row_ || c &lt; 0 || c &gt;= col_) {
  			DEBUG(&quot;MapHash error&quot;);
  		}
  		return r * col_ + c;
  	}

  private:
  	int row_, col_;
};

//MapHash mh(row, col);
//mh.Get(3,4);</Snippet>	</Category>
	<Category Name="DP">
		<Snippet Name="CoinChange">vector&lt;ll&gt; CoinChange(vector&lt;ll&gt; coins, ll limit, ll modulo = (ll)INF * (ll)INF) {
  vector&lt;ll&gt; ret(limit+1, 0);
  ret[0] = 1LL;
  FORN(i,SZ(coins)) FORN(j,limit-coins[i]+1) ret[j+coins[i]] = (ret[j+coins[i]] + ret[j]) % modulo;
  return ret;
}
//vector&lt;ll&gt; cc = CoinChange(vector&lt;ll&gt; coins, ll limit, ll modulo);
//i &lt;= limit, cc[i] == number of ways to make i</Snippet>	</Category>
	<Category Name="PY">
		<Category Name="DP">
			<Snippet Name="Memoized">def Memoized(func):
  memo = {}
  def _MemoizedFunc(*args):
    if args in memo:
      return memo[args]
    else:
      res = func(*args)
      memo[args] = res
      return res
  return _MemoizedFunc</Snippet>		</Category>
	</Category>
</Category>
